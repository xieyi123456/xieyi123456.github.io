<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"xieyi123456.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":true,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="think and do">
<meta property="og:type" content="website">
<meta property="og:title" content="XieYi&#39;s Blog">
<meta property="og:url" content="https://xieyi123456.github.io/page/5/index.html">
<meta property="og:site_name" content="XieYi&#39;s Blog">
<meta property="og:description" content="think and do">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XieYi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xieyi123456.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>XieYi's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="XieYi's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">XieYi's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">log something</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XieYi"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">XieYi</p>
  <div class="site-description" itemprop="description">think and do</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:2643100268@qq.com" title="E-Mail → mailto:2643100268@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Java虚拟机-类加载子系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:06:59" itemprop="dateCreated datePublished" datetime="2021-07-30T15:06:59+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="初始化顺序？"><a href="#初始化顺序？" class="headerlink" title="初始化顺序？"></a>初始化顺序？</h3><p>（非静态：默认初始化-显示初始化-代码块初始化-无参构造初始化or有参构造初始化）</p>
<p>（静态：默认-显示-静态代码块-非静态代码块-无参构造初始化or有参构造初始化）</p>
<h3 id="A类引用了B-C-C引用B，程序入口A，类加载顺序？"><a href="#A类引用了B-C-C引用B，程序入口A，类加载顺序？" class="headerlink" title="A类引用了B,C,C引用B，程序入口A，类加载顺序？"></a>A类引用了B,C,C引用B，程序入口A，类加载顺序？</h3><p>BCA，先加载父类。</p>
<h3 id="怎样将两个全路径相同的类加载到内存？"><a href="#怎样将两个全路径相同的类加载到内存？" class="headerlink" title="怎样将两个全路径相同的类加载到内存？"></a>怎样将两个全路径相同的类加载到内存？</h3><p>类相同还需类加载器相同，自定义类加载器即可</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>通过一个<strong>类的全限定名</strong>获取定义此类的二进制字节流<br>将这个字节流所代表的静态存储结构转化为<strong>方法区的运行时数据结构</strong><br>在内存中生成一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p>
<p><strong>加载class文件的方式：</strong></p>
<p>从<strong>本地系统</strong>中直接加载<br>通过<strong>网络获取</strong>，典型场景：Web Applet<br>从zip压缩包中读取，成为日后jar、war格式的基础<br><strong>运行时计算生成</strong>，使用最多的是：动态代理技术<br>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见<br>从<strong>加密文件中获取</strong>，典型的防Class文件被反编译的保护措施</p>
<h4 id="链接（验证-准备-解析）"><a href="#链接（验证-准备-解析）" class="headerlink" title="链接（验证-准备-解析）"></a>链接（验证-准备-解析）</h4><p>链接分为三个子阶段：<strong>验证 —&gt; 准备 —&gt; 解析</strong></p>
<p><strong>验证(Verify)</strong></p>
<p>目的在于确保Class文件的字节流中<strong>包含信息符合当前虚拟机要求</strong>，保证被加载类的正确性，不会危害虚拟机自身安全<br>主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p>
<p><strong>准备(Prepare)</strong></p>
<p>为<strong>类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</strong><br>这里<strong>不包含用final修饰</strong>的static，因为<strong>final在编译的时候就会分配好了默认值</strong>，准备阶段会显式初始化<br>注意：这里不会为实例变量分配初始化，<strong>类变量会分配在方法区</strong>中，而<strong>实例变量是会随着对象一起分配到Java堆中</strong></p>
<p><strong>解析(Resolve)</strong></p>
<p>将常量池内的<strong>符号引用转换为直接引用</strong>的过程<br>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行<br>符号引用就是<strong>一组符号来描述所引用的目标</strong>。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
<p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型</strong>等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>java类的初始化时机（对类的使用）：<br><strong>主动使用：</strong><br><strong>创建类的实例</strong><br><strong>访问某个类或接口的静态变量</strong>，或者对该静态变量赋值<br><strong>调用类的静态方法</strong><br><strong>反射</strong>（比如：Class.forName(“com.atguigu.Test”)）<br><strong>初始化一个类的子类</strong><br>Java虚拟机启动时被标明为启动类的类<br>JDK7开始提供的动态语言支持：</p>
<p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化<br>除了以上七种情况，其他使用Java类的方式都被看作是<strong>对类的被动使用</strong>，都不会导致类的初始化，会加载，不会初始化。即不会执行初始化阶段（<strong>不会调用 clinit() 方法和 init() 方法</strong>）</p>
<p><strong>clinit()</strong><br>初始化阶段就是执行类构造器方法**<clinit>()**的过程<br>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法<br><clinit>()方法中的指令按语句在源文件中出现的顺序执行<br><clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）</p>
<p><strong>若该类具有父类，</strong>JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕（父类先执行）。Son 类的父类是 Father 类，所以<strong>需要先执行 Father 类的加载，再执行 Son 类的加载</strong></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM严格来讲支持两种类型的类加载器 。分别为<strong>引导类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader）</p>
<h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong><br>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部<br>它用来加载<strong>Java的核心库</strong>（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类<br>并不继承自java.lang.ClassLoader，没有父加载器<br>加载扩展类和应用程序类加载器，并作为他们的父类加载器<br>出于安全考虑，Bootstrap启动类加载器只加载包名为<strong>java、javax、sun</strong>等开头的类</p>
<p><strong>扩展类加载器（Extension ClassLoader）</strong><br>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现<br>派生于ClassLoader类<br>父类加载器为启动类加载器<br>从<strong>java.ext.dirs</strong>系统属性所指定的目录中加载类库，或从JDK的安装目录的<strong>jre&#x2F;lib&#x2F;ext</strong>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</p>
<p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong><br>Java语言编写，由sun.misc.LaunchersAppClassLoader实现<br>派生于ClassLoader类<br>父类加载器为扩展类加载器<br>它负责加载<strong>环境变量classpath或系统属性java.class.path指定路径下的类库</strong><br>该类加载是程序中默认的类加载器，一般来说，<strong>Java应用的类都是由它来完成加载</strong><br>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</p>
<p><strong>用户自定义类加载器</strong></p>
<p><strong>什么时候需要自定义类加载器？</strong><br>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p>
<p><strong>隔离加载类</strong>（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过<strong>一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的</strong>）</p>
<p><strong>修改类加载的方式</strong><br>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）<br><strong>防止源码泄漏</strong>（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</p>
<p><strong>如何自定义类加载器？</strong><br>开发人员可以通过继承抽象类<strong>java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求<br>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在<strong>findclass()方法中</strong><br>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。<br>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<p>1，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；<br>2，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；<br>3，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
<p>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常。</p>
<h4 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h4><p><strong>避免类的重复加载</strong><br>保护程序安全，防止<strong>核心API</strong>被随意篡改<br>自定义类：自定义java.lang.String 没有被加载。<br>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</p>
<h4 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h4><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：<br>1，<strong>类的完整类名必须一致，包括包名</strong><br>2，加载这个类的<strong>ClassLoader（指ClassLoader实例对象）必须相同</strong></p>
<p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p>
<p><strong>对类加载器的引用</strong><br>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的<br>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中<br>当解析一个类型到另一个类型的引用的时候，<strong>JVM需要保证这两个类型的类加载器是相同的。</strong></p>
<h4 id="打破双亲委派机制？"><a href="#打破双亲委派机制？" class="headerlink" title="打破双亲委派机制？"></a>打破双亲委派机制？</h4><p>打破双亲委派机制的场景有很多：JDBC、Tomcat等</p>
<p>为什么JDBC需要破坏双亲委派模式，原因是原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 </p>
<p>原生的JDBC中的类是放在rt.jar包的，是由<strong>启动类加载器</strong>进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由<strong>应用程序启动类去进行类加载</strong>。</p>
<p>于是乎，这个时候就<strong>引入线程上下文件类加载器(Thread Context ClassLoader</strong>)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">private static Connection getConnection(</span><br><span class="line">        String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123;</span><br><span class="line">        /*</span><br><span class="line">         * When callerCl is null, we should check the application&#x27;s</span><br><span class="line">         * (which is invoking this class indirectly)</span><br><span class="line">         * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="line">         * can be loaded from here.</span><br><span class="line">         */</span><br><span class="line">        //callerCL为空的时候，其实说明这个ClassLoader是启动类加载器，但是这个启动类加载并不能识别rt.jar之外的类，这个时候就把callerCL赋值为Thread.currentThread().getContextClassLoader();也就是应用程序启动类</span><br><span class="line">        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;</span><br><span class="line">        synchronized(DriverManager.class) &#123;</span><br><span class="line">            // synchronize loading of the correct classloader.</span><br><span class="line">            if (callerCL == null) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(url == null) &#123;</span><br><span class="line">            throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">        // Walk through the loaded registeredDrivers attempting to make a connection.</span><br><span class="line">        // Remember the first exception that gets raised so we can reraise it.</span><br><span class="line">        SQLException reason = null;</span><br><span class="line"></span><br><span class="line">        for(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">            // If the caller does not have permission to load the driver then</span><br><span class="line">            // skip it.</span><br><span class="line">            //继续看这里 </span><br><span class="line">            if(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    println(&quot;    trying &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                    Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    if (con != null) &#123;</span><br><span class="line">                        // Success!</span><br><span class="line">                        println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                        return (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (SQLException ex) &#123;</span><br><span class="line">                    if (reason == null) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                println(&quot;    skipping: &quot; + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // if we got here nobody could connect.</span><br><span class="line">        if (reason != null)    &#123;</span><br><span class="line">            println(&quot;getConnection failed: &quot; + reason);</span><br><span class="line">            throw reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(&quot;getConnection: no suitable driver found for &quot;+ url);</span><br><span class="line">        throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) &#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">        if(driver != null) &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                //这一步会对类进行初始化的动作，而初始化之前自然也要进行的类的加载工作</span><br><span class="line">                aClass =  Class.forName(driver.getClass().getName(), true, classLoader);</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                result = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             result = ( aClass == driver.getClass() ) ? true : false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Java虚拟机-内存结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:06:46" itemprop="dateCreated datePublished" datetime="2021-07-30T15:06:46+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://i.loli.net/2021/08/05/y2G1hPE34wWgxtm.png" alt="image-20210805143306994"></p>
<h3 id="jvm内存分配："><a href="#jvm内存分配：" class="headerlink" title="jvm内存分配："></a>jvm内存分配：</h3><p>-Xms	初始堆大小	<strong>物理内存的1&#x2F;64</strong>(&lt;1GB)	</p>
<p>-Xmx	最大堆大小	<strong>物理内存的1&#x2F;4(&lt;1GB)</strong>	</p>
<p>-Xmn	年轻代大小    <strong>整个堆的3&#x2F;8</strong>    （eden+ 2 survivor space)</p>
<p>-Xss	<strong>每个线程的堆栈大小</strong>	 	JDK5.0以后每个线程堆栈大小为**1M,**以前每个线程堆栈大小为256K<br>一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试</p>
<p>-XX:NewRatio	年轻代与年老代的比值	&#x3D;4 年轻代占整个堆栈的1&#x2F;5</p>
<p>-XX:SurvivorRatio	Eden区与Survivor区的大小比值	设置为8,则两个Survivor区与一个Eden区的比值为2:8</p>
<p>-XX:TLABWasteTargetPercent	TLAB占eden区的百分比	1%</p>
<h3 id="jvm与java体系结构"><a href="#jvm与java体系结构" class="headerlink" title="jvm与java体系结构"></a>jvm与java体系结构</h3><h4 id="跨平台的语言"><a href="#跨平台的语言" class="headerlink" title="跨平台的语言"></a>跨平台的语言</h4><p><img src="https://i.loli.net/2021/08/05/i34EhPRJe9w6j1y.png" alt="image-20210805143331921"></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>一次编译，到处运行<br>自动内存管理<br>自动垃圾回收功能<br>JVM是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<h3 id="运行时数据区以及线程"><a href="#运行时数据区以及线程" class="headerlink" title="运行时数据区以及线程"></a>运行时数据区以及线程</h3><p><strong>线程独有：独立包括程序计数器、栈、本地方法栈</strong><br><strong>线程间共享：堆、堆外内存（永久代或元空间、代码缓存（方法区））</strong></p>
<p><strong>Runtime类</strong><br>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
<h4 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h4><p>1，线程是一个程序里的<strong>运行单元</strong>。JVM允许一个应用有多个线程并行的执行<br>2，在Hotspot JVM里，<strong>每个线程都与操作系统的本地线程直接映射</strong><br>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收<br>3，操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</p>
<h4 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h4><p>如果你使用jconsole或者是任何一个调试工具（内存监控工具），都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。</p>
<p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<br><strong>虚拟机线程：</strong>这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销<br><strong>周期任务线程：</strong>这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行<br><strong>GC线程：</strong>这种线程对在JVM里不同种类的垃圾收集行为提供了支持<br><strong>编译线程：</strong>这种线程在运行时会将字节码编译成到本地代码<br><strong>信号调度线程：</strong>这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</p>
<h3 id="机器慢了怎么查"><a href="#机器慢了怎么查" class="headerlink" title="机器慢了怎么查"></a>机器慢了怎么查</h3><h4 id="使用-top-命令检查-CPU-负载"><a href="#使用-top-命令检查-CPU-负载" class="headerlink" title="使用 top 命令检查 CPU 负载"></a>使用 top 命令检查 CPU 负载</h4><p>除了上述检查的情况之外，还可以使用命令 top 来检查 CPU 负载，将实时显示 process 的动态。资源使用最高的进程排在最前面。</p>
<h4 id="机器的io读写和网络情况，sar"><a href="#机器的io读写和网络情况，sar" class="headerlink" title="机器的io读写和网络情况，sar"></a>机器的io读写和网络情况，sar</h4><h4 id="查看具体是哪个进程有占用资源高的问题，ps"><a href="#查看具体是哪个进程有占用资源高的问题，ps" class="headerlink" title="查看具体是哪个进程有占用资源高的问题，ps"></a>查看具体是哪个进程有占用资源高的问题，ps</h4><p>Ps -mp pid -o THREAD,tid,time</p>
<p>再通过ps命令查看这个程序的线程信息,tid代码线程ID，time代表这个线程的已运行时间</p>
<h4 id="jstack查看进程信息"><a href="#jstack查看进程信息" class="headerlink" title="jstack查看进程信息"></a>jstack查看进程信息</h4><p>有了线程ID的16进制后，再在jstack中查看进程堆栈信息(之所有拿到TID信息，主要是为了查找方便)</p>
<p>通过jstack -pid 再grep查询。</p>
<h4 id="本地代码问题排查"><a href="#本地代码问题排查" class="headerlink" title="本地代码问题排查"></a>本地代码问题排查</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">操作系统-调度算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:05:56" itemprop="dateCreated datePublished" datetime="2021-07-30T15:05:56+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>不利于短作业</p>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>不利于长作业</p>
<h4 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h4><p>权衡：优先权&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间</p>
<h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><ul>
<li><p>如果时间⽚设得太短会导致过多的进程上下⽂切换，降低了 CPU 效率；</p>
</li>
<li><p>如果设得太⻓⼜可能引起对短作业进程的响应时间变⻓。</p>
</li>
<li><p>⼀般来说，时间⽚设为 <strong>20ms~50ms</strong> 通常是⼀个⽐较合理的折中值。</p>
</li>
</ul>
<h4 id="最高优先级"><a href="#最高优先级" class="headerlink" title="最高优先级"></a>最高优先级</h4><ul>
<li><p>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运⾏时间优先级都不会变化；</p>
</li>
<li><p>动态优先级：根据进程的动态变化调整优先级，⽐如如果进程运⾏时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升⾼其优先级，也就是随着时间的推移增加等待进程的优先级。<br>该算法也有两种处理优先级⾼的⽅法，⾮抢占式和抢占式：</p>
</li>
<li><p>⾮抢占式：当就绪队列中出现优先级⾼的进程，运⾏完当前进程，再选择优先级⾼的进程。</p>
</li>
<li><p>抢占式：当就绪队列中出现优先级⾼的进程，当前进程挂起，调度优先级⾼的进程运⾏。</p>
</li>
<li><p>但是依然有缺点，可能会导致低优先级的进程永远不会运⾏。</p>
</li>
</ul>
<h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>  是「时间⽚轮转算法」和「最⾼优先级算法」的综合和发展。</p>
<p><img src="https://i.loli.net/2021/08/06/6ziUqckShIRCQFN.png" alt="image-20210801222105298"></p>
<ul>
<li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从⾼到低，同时优先级越⾼时间⽚越短；</li>
<li>新的进程会被放⼊到第⼀级队列的末尾，按先来先服务的原则排队等待被调度，如果在第⼀级队列规定的时间⽚没运⾏完成，则将其转⼊到第⼆级队列的末尾，以此类推，直⾄完成；</li>
<li>当较⾼优先级的队列为空，才调度较低优先级的队列中的进程运⾏。如果进程运⾏时，有新进程进⼊较⾼优先级的队列，则停⽌当前运⾏的进程并将其移⼊到原队列末尾，接着让较⾼优先级的进程运⾏；</li>
<li>可以发现，对于短作业可能可以在第⼀级队列很快被处理完。对于⻓作业，如果在第⼀级队列处理不完，可以移⼊下次队列等待被执⾏，虽然等待的时间变⻓了，但是运⾏时间也变更⻓了，所以该算法很好的兼顾了⻓短作业，同时有较好的响应时间。</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳页面（OPT）"><a href="#最佳页面（OPT）" class="headerlink" title="最佳页面（OPT）"></a>最佳页面（OPT）</h4><p>淘汰以后最长时间不用的。<br>无法实现，不能预知未来，可以用来评价其他算法。</p>
<h4 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h4><p>淘汰最早进入的。</p>
<h4 id="最久未使用（LRU）"><a href="#最久未使用（LRU）" class="headerlink" title="最久未使用（LRU）"></a>最久未使用（LRU）</h4><h4 id="时钟页面置换（CLOCK）"><a href="#时钟页面置换（CLOCK）" class="headerlink" title="时钟页面置换（CLOCK）"></a>时钟页面置换（CLOCK）</h4><ul>
<li>LRU开销比较大。难以实现。</li>
<li>该算法的思路是，把所有的⻚⾯都保存在⼀个类似钟⾯的「环形链表」中，⼀个表针指向最⽼的⻚⾯。</li>
<li>当发⽣缺⻚中断时，算法⾸先检查表针指向的⻚⾯：</li>
<li>如果它的访问位位是 0 就淘汰该⻚⾯，并把新的⻚⾯插⼊这个位置，然后把表针前移⼀个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的⻚⾯为⽌。</li>
</ul>
<h4 id="最不常用"><a href="#最不常用" class="headerlink" title="最不常用"></a>最不常用</h4><p>设置访问计数器。</p>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="先来先服务-1"><a href="#先来先服务-1" class="headerlink" title="先来先服务"></a>先来先服务</h4><h4 id="最短寻道时间"><a href="#最短寻道时间" class="headerlink" title="最短寻道时间"></a>最短寻道时间</h4><p>找最近的。<br><strong>会产生饥饿现象。</strong></p>
<h4 id="扫描算法（Scan）"><a href="#扫描算法（Scan）" class="headerlink" title="扫描算法（Scan）"></a>扫描算法（Scan）</h4><p>磁头在⼀个⽅向上移动，访问所有未完成的请求，直到磁头到达该⽅向上的<strong>最后的磁道</strong>，才调换⽅向，这就是扫描（Scan）算法。</p>
<p><strong>问题：中间磁道比较优先级高。</strong></p>
<h4 id="循环扫描（CSCAN）"><a href="#循环扫描（CSCAN）" class="headerlink" title="循环扫描（CSCAN）"></a>循环扫描（CSCAN）</h4><p>只有磁头朝某个特定⽅向移动时，才处理磁道访问请求，⽽返回时<strong>直接快速移动⾄最靠边缘的磁道</strong>，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应⼀个⽅向上的请求。</p>
<h4 id="LOOK与CLOOK"><a href="#LOOK与CLOOK" class="headerlink" title="LOOK与CLOOK"></a>LOOK与CLOOK</h4><p>扫描算法和循环扫描算法，都是磁头移动到磁盘「<strong>最始端或最末端</strong>」才开始调换⽅向。<br>优化的思路就是磁头在移动到「<strong>最远的请求</strong>」位置，然后⽴即反向移动。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-fork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-fork/" class="post-title-link" itemprop="url">操作系统-fork</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:05:47" itemprop="dateCreated datePublished" datetime="2021-07-30T15:05:47+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简单概念介绍"><a href="#简单概念介绍" class="headerlink" title="简单概念介绍"></a>简单概念介绍</h3><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p>CPU所生成的地址。CPU产生的<strong>逻辑地址</strong>被分为 :p （页号） 它包含每个页在物理内存中的基址，用来作为页表的索引；d （页偏移），同基址相结合，用来确定送入内存设备的物理内存地址。</p>
<h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>内存单元所看到的地址。用户程序看不见真正的物理地址。<strong>用户只生成逻辑地址，且认为进程的地址空间为0到max。</strong>物理地址范围从R+0到R+max，R为基地址,地址映射－将程序地址空间中使用的逻辑地址变换成内存中的物理地址的过程。由<strong>内存管理单元（MMU）</strong>来完成。</p>
<p>可执行程序在存储（没有调入内存）时分为<strong>代码区，数据区，未初始化数据区</strong>三部分。</p>
<p>（1）代码区存放CPU执行的<strong>机器指令</strong>。通常代码区是共享的，即其它执行程序可调用它。代码段（code segment&#x2F;text segment）通常是只读的，有些构架也允许自行修改。<br>（2）数据区存放<strong>已初始化的全局变量，静态变量（包括全局和局部的），常量</strong>。static全局变量和static函数只能在当前文件中被调用。<br>（3）未初始化数据区（Block Started by Symbol,BSS)<strong>存放全局未初始化的变量</strong>。BSS的数据在程序开始执行之前被初始化为0或NULL。</p>
<p> 可执行程序在运行时又多出了两个区域：<strong>栈区和堆区。</strong><br>    （4）<strong>栈区</strong>。由编译器自动释放，存放函数的<strong>参数值，局部变量</strong>等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈中。然后这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。<strong>每调用一个函数一个新的栈就会被使用</strong>。栈区是从高地址位向低地址位增长的，<strong>是一块连续的内在区域</strong>，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。<br>    （5）<strong>堆区</strong>。用于<strong>动态内存分配</strong>，位于BSS和栈中间的地址位。由程序员<strong>申请分配（malloc)和释放（free）</strong>。堆是从低地址位向高地址位增长，<strong>采用链式存储结构</strong>。频繁地malloc&#x2F;free造成内存空间的不连续，<strong>产生碎片。</strong>当申请堆空间时库函数按照一定的算法搜索可用的足够大的空间。<strong>因此堆的效率比栈要低的多。</strong></p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork（）会<strong>产生一个和父进程完全相同的子进程</strong>，但子进程在此后多会exec<strong>系统调用</strong>，出于效率考虑，linux中引入了“<strong>写时复制</strong>“技术，也就是<strong>只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong>。在fork之后exec之前两个进程用的是<strong>相同的物理空间（内存区）</strong>，子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p>
<p><strong>当父子进程中有更改相应段的行为发生时</strong>，再为子进程相应的段分配物理空间。</p>
<p>如果<strong>不是因为exec</strong>，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而<strong>代码段继续共享父进程的物理空间</strong>（两者的代码完全相同）。</p>
<p>如果<strong>是因为exec</strong>，由于两者<strong>执行的代码不同</strong>，子进程的代码段也会分配单独的物理空间。</p>
<p>fork时子进程获得父进程<strong>数据空间、堆和栈的复制，所以变量的地址是一样的。</strong></p>
<p>fork子进程完全复制父进程的栈空间，也复制了页表，<strong>但没有复制物理页面</strong>，所以这时<strong>虚拟地址相同，物理地址也相同</strong>，但是会把父子共享的页面标记为“<strong>只读</strong>”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中<strong>任何一个进程要对共享的页面“写操作”</strong>，这时<strong>内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用</strong>。</p>
<p>这就是所谓的“<strong>写时复制</strong>”。正因为fork采用了这种写时复制的机制，所以fork出来子进程之后，父子进程哪个先调度呢？内核一般会先调度子进程，因为很多情况下子进程是要马上执行exec，会清空栈、堆。这些和父进程共享的空间，加载新的代码段，这就避免了“写时复制”拷贝共享页面的机会。<strong>如果父进程先调度很可能写共享页面，会产生“写时复制”的无用功。</strong></p>
<p>在理解时，你可以认为fork后，这两个相同的虚拟地址指向的是不同的物理地址，这样方便理解父子进程之间的独立性</p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>但实际上，linux为了提高 fork 的效率，采用了 <strong>copy-on-write</strong> 技术，fork后，这两个虚拟地址实际上指向相同的物理地址（内存页），只有任何一个进程试图修改这个虚拟地址里的内容前，两个虚拟地址才会指向不同的物理地址（新的物理地址的内容从原物理地址中复制得到）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">操作系统-线程与进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:05:47" itemprop="dateCreated datePublished" datetime="2021-07-30T15:05:47+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>更好的描述和控制程序的并发执行。<br>PCB进程控制块-进程存在的唯一标志。<br>程序的一次执行过程。<br>拥有资源的基本单位。<br>状态：运行，就绪，阻塞，创建，结束</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个基本的CPU执行单元。<br>是系统独立调度派的基本单位。<br>一个进程中可以有多个线程。<br>线程切换只需要保存设置程序计数器，虚拟机栈少量内容，开销小。轻量级进程。</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul>
<li>⼀旦操作系统把进程切换到运⾏状态，也就意味着该进程占⽤着 CPU 在执⾏，但是当操作系统把进程切换到其他状态时，那就不能在 CPU 中执⾏了，于是操作系统会选择下⼀个要运⾏的进程。</li>
<li><strong>选择⼀个进程运⾏这⼀功能是在操作系统中完成的，通常称为调度程序（scheduler）</strong></li>
<li>在进程的⽣命周期中，当<strong>进程从⼀个运⾏状态到另外⼀状态变化的时候</strong>，其实会触发⼀次调度。 </li>
<li>⾮抢占式调度算法挑选⼀个进程，然后让<strong>该进程运⾏直到被阻塞，或者直到该进程退出</strong>，才会调⽤另外⼀个进程，也就是说不会理时钟中断这个事情。 </li>
<li>抢占式调度算法挑选⼀个进程，然后让该进程只运⾏某段时间，如果在该时段结束时，该进程仍然在运⾏时，则会<strong>把它挂起</strong>，接着调度程序从就绪队列挑选另外⼀个进程。</li>
<li>这种抢占式调度处理，需要在时间间隔的末端发⽣时钟中断，以便把CPU控制返回给调度程序进⾏调度，也就是常说的<strong>时间⽚机制 。</strong></li>
</ul>
<p><strong>调度的算法评价：</strong></p>
<ol>
<li><strong>CPU 利⽤率</strong>：调度程序应确保 CPU 是始终匆忙的状态，这可提⾼ CPU 的利⽤率；</li>
<li><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，⻓作业的进程会占⽤较⻓的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li>
<li><strong>周转时间</strong>：周转时间是进程运⾏和阻塞时间总和，⼀个进程的周转时间越⼩越好；</li>
<li><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，⽽是进程处于就绪队列的时间，等待的时间越⻓，⽤户越不满意；</li>
<li><strong>响应时间</strong>：⽤户提交请求到系统第⼀次产⽣响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li>
</ol>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul>
<li>连接两个进程实现通信的一个共享文件。pipe</li>
<li><strong>字符流</strong>的形式写入接收。</li>
<li>固定大小的缓冲区，4kb。</li>
<li>同一时刻只能<strong>单向通信。</strong></li>
<li>不管是匿名管道还是命名管道，进程写⼊的数据都是<strong>缓存在内核中</strong>，另⼀个进程读取数据时候⾃然也是从内核中获取，同时通信数据都遵循<strong>先进先出原则</strong>。</li>
<li>缓冲区中有数据才能读，写数据会先写满，才会允许读。还有数据时，不允许写。</li>
</ul>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul>
<li><p>管道的通信⽅式是效率低的，因此<strong>管道不适合进程间频繁地交换数据</strong>。</p>
</li>
<li><p>消息队列的通信模式就可以解决。⽐如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
</li>
<li><p>消息队列是<strong>保存在内核中的消息链表</strong>，在发送数据时，会分成⼀个⼀个<strong>独⽴的数据单元，也就是消息体</strong>（数据块），消息体是<strong>⽤户⾃定义的数据类型</strong>，消息的发送⽅和接收⽅要约定好消息体的数据类型，所以每个消息体都是<strong>固定⼤⼩的存储块，</strong>不像管道是⽆格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
</li>
<li><p>消息队列⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，⽽前⾯提到的匿名管道的⽣命周期，是随进程的创建⽽建⽴，随进程的结束⽽销毁。</p>
</li>
<li><p>消息队列<strong>不适合⽐较⼤数据的传输，</strong>因为在内核中每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所包含的全部消息体的总⻓度也是有上限。</p>
</li>
<li><p>消息队列通信过程中，<strong>存在⽤户态与内核态之间的数据拷⻉开销。</strong></p>
</li>
</ul>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul>
<li>拿出⼀块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写⼊的东⻄，另外⼀个进程⻢上就能看到了，<strong>不需要拷⻉来拷⻉去，⼤⼤提⾼了进程间通信的速度。</strong></li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul>
<li><p>多个进程同时修改同⼀个共享内存，很有可能就冲突。<strong>信号量就实现了这⼀保护机制。</strong></p>
</li>
<li><p>信号量其实是⼀个<strong>整型的计数器</strong>，主要⽤于实现进程间的<strong>互斥与同步</strong>，⽽不是⽤于缓存进程间通信的数据。</p>
</li>
<li><p><strong>信号量表示资源的数量</strong>，控制信号量的⽅式有两种原⼦操作：</p>
</li>
<li><p><strong>⼀个是 P 操作，这个操作会把信号量减去 1，</strong>相减后如果信号量 **&lt; 0，**则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使⽤，进程可正常继续执⾏。</p>
</li>
<li><p><strong>另⼀个是 V 操作，这个操作会把信号量加上 1，</strong>相加后如果信号量 **&lt;&#x3D; 0**，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</p>
</li>
<li><p>P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须<strong>成对出现的。</strong></p>
</li>
<li><p><strong>信号量初始化为 1</strong> ，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存。</p>
</li>
<li><p>信号量来实现多进程<strong>同步的⽅式</strong>，我们可以<strong>初始化信号量为 0</strong> 。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/06/puJzalWFGyTfjmt.png" alt="image-20210801220932770"></p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><ul>
<li>对于<strong>异常情况下的⼯作模式</strong>，就需要⽤「信号」的⽅式来通知进程。</li>
<li>信号事件的来源主要有<strong>硬件来源</strong>（如键盘 Cltr+C ）和<strong>软件来源</strong>（如 kill 命令）。</li>
<li>信号是进程间通信机制中<strong>唯⼀的异步通信机制</strong>，因为可以在任何时候发送信号给某⼀进程，⼀旦有信号产⽣，我们就有下⾯这⼏种，⽤户进程对信号的处理⽅式。</li>
<li><strong>默认操作，捕捉信号，忽略信号。</strong></li>
</ul>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>  Socket 通信不仅可以<strong>跨⽹络与不同主机的进程间通信，还可以在同主机上进程间通信。</strong><br>  根据创建 socket 类型的不同，通信的⽅式也就不同：</p>
<ul>
<li><strong>实现 TCP 字节流通信</strong>： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li><strong>实现 UDP 数据报通信</strong>： socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li><strong>实现本地进程间通信：</strong> 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以AF_UNIX 也属于本地 socket。</li>
</ul>
<h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP:"></a>TCP:</h5><ul>
<li>服务端和客户端初始化 socket ，得到⽂件描述符；</li>
<li><strong>服务端调⽤ bind</strong> ，将绑定在 IP 地址和端⼝;</li>
<li><strong>服务端调⽤ listen</strong> ，进⾏监听；</li>
<li><strong>服务端调⽤ accept</strong> ，等待客户端连接；</li>
<li><strong>客户端调⽤ connect</strong> ，向服务器端的地址和端⼝发起连接请求；</li>
<li>服务端 accept 返回<strong>⽤于传输的 socket 的⽂件描述符；</strong></li>
<li>客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；</li>
<li>客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭。</li>
</ul>
<h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP:"></a>UDP:</h5><ul>
<li>每⼀个 UDP 的 socket 都需要 bind 。</li>
</ul>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h4><p>⽤⼀个数组 state 来记录每⼀位哲学家在<strong>进程、思考还是饥饿状态</strong>（正在试图拿叉⼦）。那么，⼀个哲学家只有在两个邻居都没有进餐时，才可以进⼊进餐状态。</p>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p><strong>互斥信号量 mutex ：</strong>⽤于互斥访问缓冲区，初始化值为 1；<br><strong>资源信号量 fullBuffers</strong> ：⽤于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0<br>（表明缓冲区⼀开始为空）；<br><strong>资源信号量 emptyBuffers</strong> ：⽤于⽣产者询问缓冲区是否有空位，有空位则⽣成数据，初始化值为 n<br>（缓冲区⼤⼩）；</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进程因为竞争资源造成僵局，互相等待。</p>
<p><strong>条件</strong></p>
<ul>
<li>互斥-资源仅为一个线程占有</li>
<li>不剥夺</li>
<li>请求与保持-保持了至少一个资源又在请求其他的资源</li>
<li>循环等待-进程资源的循环等待链</li>
</ul>
<h3 id="其他的锁"><a href="#其他的锁" class="headerlink" title="其他的锁"></a>其他的锁</h3><p><strong>互斥锁</strong>加锁失败后，线程会释放 CPU ，给其他线程；（两次线程上下文切换）<br><strong>⾃旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁<br>⾃旋锁是通过 CPU 提供的 <strong>CAS</strong> 函数（Compare And Swap），在「⽤户态」完成加锁和解锁操作，<strong>不会主动产⽣线程上下⽂切换，所以相⽐互斥锁来说，会快⼀些，开销也⼩⼀些。</strong></p>
<p><strong>互斥锁、⾃旋锁、读写锁，都是属于悲观锁</strong>。<br>悲观锁做事⽐较悲观，它认为多线程同时修改共享资源的概率⽐较⾼，于是很容易出现冲突，所以访问共享资源前，先要上锁。<br>那相反的，如果<strong>多线程同时修改共享资源的概率⽐较低，就可以采⽤乐观锁。</strong></p>
<p>乐观锁做事⽐较乐观，它假定冲突的概率很低，它的⼯作⽅式是：<strong>先修改完共享资源，再验证这段时间内有没有发⽣冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</strong></p>
<p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很⾼，但是冲突的概率⾜够低的话，还是可以接受的。</p>
<p><strong>场景例⼦：在线⽂档。</strong><br>我们都知道在线⽂档可以同时多⼈编辑的，如果使⽤了悲观锁，那么只要有⼀个⽤户正在编辑⽂档，此时其他⽤户就⽆法打开相同的⽂档了，这⽤户体验当然不好了。<br>那实现多⼈同时编辑，实际上是⽤了乐观锁，它允许多个⽤户打开同⼀个⽂档进⾏编辑，编辑完提交之后才验证修改的内容是否有冲突。<br>怎么样才算发⽣冲突？这⾥举个例⼦，⽐如⽤户 A 先在浏览器编辑⽂档，之后⽤户 B 在浏览器也打开了相同的⽂档进⾏编辑，但是⽤户 B ⽐⽤户 A 提交改动，这⼀过程⽤户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并⾏修改的地⽅就会发⽣冲突。</p>
<p>服务端要怎么验证是否冲突了呢？<br>当⽤户提交修改时，发给服务端的请求<strong>会带上原始⽂档版本号</strong>，服务器收到后将它与当前版本号进⾏⽐较，<strong>如果版本号⼀致则修改成功，否则提交失败</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统-内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:05:30" itemprop="dateCreated datePublished" datetime="2021-07-30T15:05:30+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h3><p><img src="https://i.loli.net/2021/08/06/gY7BE1UoqzbDnLO.png" alt="image-20210801212559233"></p>
<p><img src="https://i.loli.net/2021/08/06/EevMmVO14PZa8gF.png" alt="image-20210801214351270"></p>
<p>进程的地址空间：按照程序自身的<strong>逻辑关系划分</strong>（代码段，数据段….）为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。<br>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p>
<p>由于是按逻辑功能模块划分，用户编程更方便，程序可读性更高。</p>
<p><strong>逻辑地址</strong>：段号：段内地址</p>
<p><strong>段表</strong>：段号&#x3D;段基地址&#x3D;段长。<br>缺点：</p>
<ul>
<li><strong>内存碎片。</strong></li>
<li><strong>内存交换效率低。</strong></li>
</ul>
<h3 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h3><h4 id="分页式："><a href="#分页式：" class="headerlink" title="分页式："></a>分页式：</h4><ul>
<li><p><strong>固定分区会产生碎片</strong>。把内存划分为很多块，作为进程内存分配的最小单位。</p>
</li>
<li><p>页面大小要权衡，应该是2的幂次。太大会产生页内碎片，太小，页表会占用大量内存，降低换入换出效率。<br><strong>分页管理的地址结构：页号：页内偏移量</strong></p>
<p>为32位，<strong>0-11为页内偏移，12-31为页号。</strong></p>
<p>每页大小2^12&#x3D;<strong>4kb。</strong></p>
</li>
<li><p>为了方便每个进程<strong>在内存中找到每个页面对应的物理块</strong>，会为每个进程创建一张<strong>页表</strong>（存储在内存中&#x3D;&#x3D;&#x3D;访问一次数据需要<strong>访问两次内存</strong>）。<br>页表由<strong>页表项</strong>组成<strong>第一部分是，页号，第二部分是物理块号。</strong></p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/06/CjPalYZUGqMAsEn.png" alt="image-20210801213808642"></p>
<h4 id="分页管理问题："><a href="#分页管理问题：" class="headerlink" title="分页管理问题："></a>分页管理问题：</h4><ul>
<li>每次访问内存<strong>都需要进行地址的转换</strong>。速度受限制。</li>
<li><strong>页表不能太大</strong>，否则内存利用率会降低。</li>
</ul>
<h4 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h4><ul>
<li><p>具有并行查找能力的高速缓冲存储器&#x3D;&#x3D;<strong>快表（联想存储器TLB）</strong>–把最常访问的⼏个⻚表项存储到访问速度更快的硬件。</p>
</li>
<li><p>这时先查快表，没有再查慢表。（局部性原理）</p>
</li>
</ul>
<h4 id="多级页表："><a href="#多级页表：" class="headerlink" title="多级页表："></a>多级页表：</h4><ul>
<li><p>虚拟内存地址空间4Gb，页表大小是4kb，需要100万个页，假设每个页表项大小为4b。那么需要4Mb来存储页表。</p>
</li>
<li><p>每个进程都有自己的页表，假设有200个进程，就需要800Mb来存储页表，很大了。</p>
</li>
<li><p>建立上一级页表存储页表间的映射关系。</p>
</li>
<li><p><strong>顶级页表一般只有一个页面。</strong></p>
</li>
</ul>
<p>建立多级页表：建立索引，不用去存储无用页表项，也不用去盲目的查找页表项。</p>
<p><img src="https://i.loli.net/2021/08/06/ZQH2XSo81gRuCa7.png" alt="image-20210801213945467"></p>
<h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><ul>
<li>分段<strong>利于反应程序的逻辑结构以及段的共享</strong>。</li>
<li>先将程序划分为<strong>多个有逻辑意义的段</strong>，接着再把<strong>每个段划分为多个⻚</strong>，也就是对分段划分出来的连续空间，再划分固定⼤⼩的⻚；</li>
<li>地址结构就由<strong>段号、段内⻚号和⻚内位移</strong>三部分组成。</li>
<li>⽤于段⻚式地址变换的数据结构是每⼀个程序⼀张段表，每个段⼜建⽴⼀张⻚表，段表中的地址是⻚表的起始地址，⽽⻚表中的地址则为某⻚的物理⻚号。</li>
</ul>
<p><img src="https://i.loli.net/2021/08/06/knoWqyRxGDMKC1P.png" alt="image-20210801214844351"></p>
<ul>
<li>第⼀次访问段表，得到<strong>⻚表起始地址；</strong></li>
<li>第⼆次访问⻚表，得到<strong>物理⻚号；</strong></li>
<li>第三次将物理⻚号与⻚内位移组合，得到物理地址。</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>基于局部性原理：程序装入时，先装入一部分，其他的驻留在外存，当访问的信息不在内存时，再换入。<br>这好像给用户提供了一个比实际内存大的内存空间。</p>
<p><strong>使用外存的空间来扩展内存的空间。</strong><br><strong>实现：</strong><br>    分页<br>    分段<br>    段页式<br>需要：<br>    内外存<br>    页表机制<br>    中断机构（缺页中断）<br>    地址变换（先检索快表）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了在多进程环境下，使得<strong>进程之间的内存地址不受影响</strong>，相互隔离，于是操作系统就为每个进程独⽴分<br>配⼀套<strong>虚拟地址空间</strong>，每个程序只关⼼⾃⼰的虚拟地址就可以，实际上⼤家的虚拟地址都是⼀样的，但分<br>布到物理地址内存是不⼀样的。作为程序，也不⽤关⼼物理地址的事情。</p>
<p>每个进程都有⾃⼰的虚拟空间，⽽物理内存只有⼀个，所以当启⽤了⼤量的进程，物理内存必然会很紧<br>张，于是操作系统会通过<strong>内存交换</strong>技术，把不常使⽤的内存暂时存放到硬盘（换出），在需要的时候再装<br>载回物理内存（换⼊）。</p>
<p>那既然有了虚拟地址空间，那必然要把<strong>虚拟地址「映射」到物理地址</strong>，这个事情通常由操作系统来维护。<br>那么对于虚拟地址与物理地址的映射关系，可以有<strong>分段和分⻚</strong>的⽅式，同时两者结合都是可以的。</p>
<p>内存分段是根据<strong>程序的逻辑⻆度</strong>，分成了<strong>栈段、堆段、数据段、代码段</strong>等，这样可以分离出不同属性的<br>段，同时是⼀块连续的空间。但是每个段的⼤⼩都不是统⼀的，这就会导致<strong>内存碎⽚和内存交换效率低</strong>的<br>问题。</p>
<p>于是，就出现了内存分⻚，把虚拟空间和物理空间分成⼤⼩固定的⻚，如在 Linux 系统中，每⼀⻚的⼤⼩<br>为 <strong>4KB</strong> 。由于分了⻚后，就不会产⽣细⼩的内存碎⽚。同时在内存交换的时候，写⼊硬盘也就⼀个⻚或<br>⼏个⻚，这就⼤⼤提⾼了内存交换的效率。</p>
<p>再来，为了解决简单分⻚产⽣的<strong>⻚表过⼤的问题</strong>，就有了<strong>多级⻚表</strong>，它解决了空间上的问题，但这就会导<br>致 CPU 在寻址的过程中，需要有很多层表参与，加⼤了时间上的开销。于是根据程序的局部性原理，在<br>CPU 芯⽚中加⼊了 <strong>TLB，负责缓存最近常被访问的⻚表项，⼤⼤提⾼了地址的转换速度。</strong></p>
<p><strong>Linux 系统主要采⽤了分⻚管理</strong>，但是由于 Intel 处理器的发展史，Linux 系统⽆法避免分段管理。于是<br>Linux 就把<strong>所有段的基地址设为 0</strong> ，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相<br>当于屏蔽了 CPU 逻辑地址的概念，所以段只被⽤于访问控制和内存保护。</p>
<p>另外，Linxu 系统中虚拟空间分布可分为<strong>⽤户态和内核态</strong>两部分，其中⽤户态的分布：<strong>代码段、全局变量、</strong><br><strong>BSS、函数栈、堆内存、映射区</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">计算机网络-IO多路复用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:05:11" itemprop="dateCreated datePublished" datetime="2021-07-30T15:05:11+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="解释名词"><a href="#解释名词" class="headerlink" title="解释名词"></a>解释名词</h3><h4 id="用户空间内核空间"><a href="#用户空间内核空间" class="headerlink" title="用户空间内核空间"></a>用户空间内核空间</h4><p>现在操作系统都是采用虚拟存储技术，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节，供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<p>每个进程可以通过<strong>系统调用</strong>进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
<h4 id="系统调用："><a href="#系统调用：" class="headerlink" title="系统调用："></a>系统调用：</h4><ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程控制</li>
<li>进程通信</li>
<li>内存管理</li>
</ul>
<h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p>为控制进程的执行，操作系统内核挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为称为上下文切换（context switch）。通过上下文切换技术，即使在单处理器系统上也能够并发执行多个任务。</p>
<p>进程切换的原因：</p>
<ol>
<li>在CPU上运行进程的<strong>时间片耗尽</strong>，便会被操作系统挂起，调度器选择其他进程执行。</li>
<li>在CPU上运行进程被<strong>更高优先级的进程抢占</strong>。</li>
<li>在CPU上运行进程需要<strong>等待某种设备资源时</strong>，进程会被挂起，从运行状态（TASK_RUNNING）改为就绪状态（TASK_INTERRUPTIBLE）。</li>
<li>在CPU上运行进程的时间片尚未耗尽时，<strong>发生硬件中断</strong>，CPU中断当前执行的进程，转而去调用对应的中断处理程序处理中断。</li>
</ol>
<p>进程切换细节：</p>
<ul>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ul>
<p>进程的阻塞是进程自身的一种<strong>主动行为</strong>，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是<strong>不占用CPU资源的</strong>。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符形式上是一个非负整数。它是一个<strong>索引值</strong>，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>
<p>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h4 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h4><p>缓存 I&#x2F;O 又被称作标准 I&#x2F;O，大多数文件系统的默认 I&#x2F;O 操作都是缓存 I&#x2F;O。在 Linux 的缓存 I&#x2F;O 机制中，操作系统会将 I&#x2F;O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</strong></p>
<p>缺点：<br>数据在传输过程中需要<strong>在应用程序地址空间和内核进行多次数据拷贝操作</strong>，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p>当用户进程调用了recvfrom这个系统调用，内核就开始了IO的第一个阶段：<strong>准备数据</strong>（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候内核就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当内核一直等到数据准备好了，它就会<strong>将数据从kernel中拷贝到用户内存</strong>，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<p><strong>两个阶段都被阻塞。</strong></p>
<h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>当用户进程发出read操作时，如果内核中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，nonblocking IO的特点是<strong>用户进程需要不断的主动询问内核</strong></p>
<p>NIO在一些<strong>短业务线，访问量高</strong>的程序中使用，会提高系统的吞吐量，但是对于业务线长，且访问量低的程序来说，就未必是件好事，使用BIO可能会更好一些，<strong>不然线程就会空转，浪费CPU。</strong></p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>优点：<strong>一个进程可以同时处理多个连接。</strong></p>
<p>I&#x2F;O 多路复用的特点是通过一种机制<strong>一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>异步（线程自己不去获得结果，而是由其他的线程送来结果）</p>
<p><img src="https://i.loli.net/2021/08/06/UxFNmyufwlKnLhE.png" alt="image-20210731094812802">异步情况下一定是非阻塞的。</p>
<p>异步意味着：在进行读写操作时，线程不必等待结果，而是通过回调的方式由另外的线程来获取。linux在2.6底层通过多路复用模拟了异步IO。windows通过IOCP真正实现了异步IO。</p>
<p>select，poll，epoll本质上都是<strong>同步I&#x2F;O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会由其他线程负责把数据从内核拷贝到用户空间。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 实现多路复⽤的⽅式：</p>
<p>将已连接的 Socket 都放到⼀个<strong>⽂件描述符集合</strong>，然后调⽤ select 函数<strong>将⽂件描述符集合拷⻉到内核</strong>⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历⽂件描述符集合的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写。</p>
<p>接着<strong>再把整个⽂件描述符集合拷⻉回⽤户态</strong>⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，然后再对其处理。</p>
<p>对于 select 这种⽅式，需要进⾏ 2 次「遍历」⽂件描述符集合，⼀次是在内核态⾥，⼀个次是在⽤户态⾥ ，⽽且还会发⽣ 2 次「拷⻉」⽂件描述符集合，先从⽤户空间传⼊内核空间，由内核修改后，再传出到⽤户空间中。</p>
<p>select 使⽤3个固定⻓度的 BitsMap（表示可读，可写，except），表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 <strong>1024</strong> ，只能监听 0~1023 的⽂件描述符。</p>
<p>select<strong>目前几乎在所有的平台上支持，</strong>其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，<strong>在Linux上一般为1024，</strong>可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤<strong>动态数组，以链表形式来组织</strong>，（pollfd的指针）突破了select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。</p>
<p><img src="https://i.loli.net/2021/08/06/2kPGI6thcdoiLUe.png" alt="image-20210731095816033"></p>
<p>但是 poll 和 select 并没有太⼤的本质区别，都是使⽤「线性结构」存储进程关注的 Socket 集合，因此都需要遍历⽂件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>第⼀点，epoll 在内核⾥使⽤<strong>红⿊树</strong>来跟踪进程所有待检测的⽂件描述字，把需要监控的 socket 通过epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select&#x2F;poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，减少了内核和⽤户空间⼤量的数据拷⻉和内存分配。</p>
<p>第⼆点， epoll 使⽤<strong>事件驱动的机制</strong>，内核⾥维护了⼀个链表来记录就绪事件，当某个 socket 有事件发⽣时，通过回调函数内核会将其加⼊到这个就绪事件列表中，<strong>当⽤户调⽤ epoll_wait() 函数时</strong>，只会返回有事件发⽣的⽂件描述符，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。</p>
<p><img src="https://i.loli.net/2021/08/11/fHIJbCpiOan5ymZ.png" alt="image-20210811133207962"></p>
<p>epoll对文件描述符的操作有两种模式<strong>：LT（level trigger）和ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p><strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。<strong>下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></p>
<p><strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，<strong>下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</strong></p>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<p>ET(edge-triggered)是<strong>高速工作方式，</strong>只支持<strong>no-block socket</strong>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后<strong>它会假设你知道文件描述符已经就绪，</strong>并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，<strong>内核不会发送更多的通知(only once)</strong></p>
<p>ET模式在很大程度上<strong>减少了epoll事件被重复触发的次数</strong>，因此效率要比LT模式高。</p>
<p>（会循环从⽂件描述符读写数据，那么<strong>如果⽂件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那⾥</strong>，程序就没办法继续往下执⾏。所以，<strong>边缘触发模式⼀般和⾮阻塞 I&#x2F;O 搭配使⽤</strong>，程序会⼀直执⾏ I&#x2F;O 操作，直到系统调⽤（如 read 和write ）返回错误。）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-tcp/" class="post-title-link" itemprop="url">计算机网络-tcp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:04:43" itemprop="dateCreated datePublished" datetime="2021-07-30T15:04:43+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>TCP 是<strong>⾯向连接的、可靠的、基于字节流</strong>的传输层通信协议 。</li>
<li>TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下： <strong>源地址 源端⼝ ⽬的地址 ⽬的端⼝</strong> 。</li>
<li><strong>源地址和⽬的地址的字段（32位）是在 IP 头部中</strong>，作⽤是通过 IP 协议发送报⽂给对⽅主机。</li>
<li><strong>源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中</strong>，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。</li>
</ul>
<p>服务端最⼤并发 TCP 连接数远不能达到理论上限。</p>
<p>主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬。<br>另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的。</p>
<h4 id="头部格式"><a href="#头部格式" class="headerlink" title="头部格式"></a>头部格式</h4><p><img src="https://i.loli.net/2021/08/05/LJjRVuwsymNHSn3.png" alt="image-20210731112848824"></p>
<p>序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。</p>
<p>确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。⽤来解决不丢包的问题。</p>
<p>控制位：</p>
<ul>
<li>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。</li>
<li>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li>SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。</li>
<li>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
<h4 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h4><p><img src="https://i.loli.net/2021/08/05/dJwpgNLSEkFMq84.png" alt="image-20210731113120885"></p>
<p>TCP 和 UDP 区别：</p>
<ol>
<li><p>连接<br> TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。<br> UDP 是不需要连接，即刻传输数据。</p>
</li>
<li><p>服务对象<br> TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。<br> UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信</p>
</li>
<li><p>可靠性<br> TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不᯿复、按需到达。<br> UDP 是尽最⼤努⼒交付，不保证可靠交付数据。</p>
</li>
<li><p>拥塞控制、流量控制<br> TCP 有拥塞控制和流ᰁ控制机制，保证数据传输的安全性。UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。</p>
</li>
<li><p>⾸部开销<br> TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的。<br> UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。</p>
</li>
<li><p>传输⽅式<br> TCP 是流式传输，没有边界，但保证顺序和可靠。<br> UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。</p>
</li>
<li><p>分⽚不同<br> TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。</p>
</li>
</ol>
<p> UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。</p>
<ol start="8">
<li><p>TCP 和 UDP 应⽤场景：<br> 由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于：<br> FTP ⽂件传输<br> HTTP &#x2F; HTTPS</p>
<p> 由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：<br> 包总数较少的通信，如 DNS 、 SNMP 等<br> 视频、⾳频等多媒体通信<br> ⼴播通信</p>
</li>
</ol>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP:"></a>UDP:</h4><p>UDP 是⼀个简单、不可靠的传输协议，⽽且是 UDP 包之间是⽆序的，也没有依赖关系。⽽且，UDP 是不需要连接的，也就不需要握⼿和挥⼿的过程，所以天然的就⽐ TCP 快。</p>
<p>当然，HTTP&#x2F;3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应⽤层」实现了 QUIC 协议，它具有类似 TCP 的连接管理、拥塞窗⼝、流ᰁ控制的⽹络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不⽤担⼼数据包丢失的问题。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://i.loli.net/2021/08/05/tFSzZdBAvgEK27o.png" alt="image-20210731113603327"></p>
<p>注意序列号和确认应答号的变化。<br>第三次握手可以携带数据。</p>
<p>注意序列号和确认应答号的变化。</p>
<p>第三次握手可以携带数据。</p>
<h4 id="为什么是三次？"><a href="#为什么是三次？" class="headerlink" title="为什么是三次？"></a>为什么是三次？</h4><ol>
<li>避免历史连接！！！。</li>
<li>同步双方序列号（去重，按序接收）。</li>
<li>避免资源浪费。（只有两次，客户端的syn阻塞，就会重新发送syn，那么服务端每收到一个syn就要建立连接。）</li>
</ol>
<ul>
<li>在⽹络拥堵情况下，⼀个「旧 SYN 报⽂」⽐「最新的 SYN 」 报⽂早到达了服务端；</li>
<li>那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端；</li>
<li>客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送RST 报⽂给服务端，表示中⽌这⼀次连接。</li>
<li>如果是两次握⼿连接，就不能判断当前连接是否是历史连接，三次握⼿则可以在客户端（发送⽅）准备发送第三次报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接。</li>
</ul>
<h4 id="既然-IP-层会分⽚，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分⽚，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？</h4><p>MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节；<br>MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度；</p>
<ul>
<li>当 IP 层有⼀个超过 MTU ⼤⼩的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成若⼲⽚，保证每⼀个分⽚都⼩于 MTU。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏组装后，再交给上⼀层 TCP 传输层。</li>
<li>那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分⽚都得重传。</li>
<li>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</li>
<li>当接收⽅发现 TCP 报⽂（头部 + 数据）的某⼀⽚丢失后，则不会响应 ACK 给对⽅，那么发送⽅的 TCP 在超时后，就会重发「整个 TCP 报⽂（头部 + 数据）」。</li>
</ul>
<h4 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p>攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的ACK 应答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务。</p>
<p><img src="https://i.loli.net/2021/08/05/CE9ZOqDpnFK4joB.png" alt="image-20210731145537881"></p>
<p><img src="https://i.loli.net/2021/08/05/QZeGdAhMkUXjLYt.png" alt="image-20210731145610582"></p>
<p><strong>解决办法：</strong></p>
<p>控制该队列的最⼤值：SYN_RCVD 状态连接的最⼤个数：net.core.netdev_max_backlog</p>
<ul>
<li>tcp_syncookies 的⽅式可以应对 SYN 攻击的⽅法：<br>net.ipv4.tcp_syncookies &#x3D; 1<br>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进⼊「 SYN 队列」；<br>计算出⼀个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，<br>服务端接收到客户端的应答报⽂时，服务器会检查这个 ACK 包的合法性。如果合法，直接放⼊到「Accept队列」。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://i.loli.net/2021/08/05/FsewJVSbrgqBzUp.png" alt="image-20210731145722373"></p>
<p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了<strong>但是还能接收数据</strong>。服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <strong>FIN 报⽂给客户端来表示同意现在关闭连接</strong>。</p>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL"></a>为什么 TIME_WAIT 等待的时间是 2MSL</h4><p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。<br>⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。<br>⽐如如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。<br>在 Linux 系统⾥ 2MSL 默认是 60 秒，那么⼀个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。</p>
<h4 id="需要-TIME-WAIT-状态"><a href="#需要-TIME-WAIT-状态" class="headerlink" title="需要 TIME-WAIT 状态"></a>需要 TIME-WAIT 状态</h4><ul>
<li>防⽌具有相同「四元组」的「旧」数据包被收到；<br>经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。</li>
<li>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收。</li>
</ul>
<h4 id="如果已经建⽴了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建⽴了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建⽴了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建⽴了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP 有⼀个机制是<strong>保活机制</strong>。这个机制的原理是这样的：ping-pong<br>定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，每隔⼀个时间间隔，发送⼀个探测报⽂，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。</p>
<h3 id="socket编程？"><a href="#socket编程？" class="headerlink" title="socket编程？"></a>socket编程？</h3><h4 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h4><p><img src="https://i.loli.net/2021/08/05/cXSudR6i82maxOI.png" alt="image-20210731150237375"></p>
<h4 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a>listen 时候参数 backlog 的意义？</h4><p>参数⼀ socketfd 为 socketfd ⽂件描述符<br>参数⼆ <strong>backlog</strong>，这参数在历史版本有⼀定的变化<br>在早期 Linux 内核 backlog 是 <strong>SYN 队列⼤⼩</strong>，也就是未完成的队列⼤⼩。<br>在 Linux 内核 2.2 之后，backlog 变成 <strong>accept 队列</strong>，也就是已完成连接建⽴的队列⻓度，所以现在通常认为backlog 是 accept 队列长度</p>
<p>客户端 connect 成功返回是在第⼆次握⼿，服务端 accept 成功返回是在三次握⼿成功之后。</p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p><strong>序列号、确认应答、重发控制、连接管理以及窗⼝控制等。</strong></p>
<h4 id="自动重传请求（Automatic-Repeat-reQuest，ARQ）"><a href="#自动重传请求（Automatic-Repeat-reQuest，ARQ）" class="headerlink" title="自动重传请求（Automatic Repeat-reQuest，ARQ）"></a>自动重传请求（Automatic Repeat-reQuest，ARQ）</h4><p>OSI模型中数据链路层的错误纠正协议之一。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。<strong>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</strong><br>当发送窗口和接收窗口的大小都等于 1时，就是停止等待协议。<br>当发送窗口大于1，接收窗口等于1时，就是回退N步协议。<br>当发送窗口和接收窗口的大小均大于1时，就是选择重发协议</p>
<h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>序列号与确认应答！</p>
<p><strong>超时重传</strong>-数据包丢失，确认应答丢失。</p>
<p><img src="https://i.loli.net/2021/08/05/OFfCLUwdjGsRPZI.png" alt="image-20210731150635851"></p>
<p>当超时时间 RTO 较⼤时，重发就慢，没有效率，性能差；<br>当超时时间 RTO 较⼩时，会导致可能并没有丢就重发。<br>超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值。<br>如果超时重发的数据，再次超时的时候，TCP 的策略是超时间隔加倍。<br>也就是每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。</p>
<p><strong>快速重传</strong><br>三次同样的ACK。</p>
<p><strong>SACK</strong><br> SACK （ Selective Acknowledgment 选择性确认）。<br>这种⽅式需要在 <strong>TCP 头部「选项」字段⾥加⼀个 SACK</strong> 的东⻄，它可以将缓存的地图发送给发送⽅，这样<strong>发送⽅就可以知道哪些数据收到了，哪些数据没收到，</strong>知道了这些信息，就可以只重传丢失的数据。<br>D-SACK</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值。</p>
<p>如果每次传输数据都只能发送一个MSS，就需要等待接收方的ACK，这显然会极大的影响传输的速率。在发送数据的时候，最好的方式是一下将所有的数据全部发送出去，然后一起确认。</p>
<p>首先TCP在进行数据传输的时候都是<strong>先将数据放在数据缓冲区中的</strong>，TCP维护了两个缓冲区，<strong>发送方缓冲区和接收方缓冲区。</strong></p>
<p>发送方缓冲区：发送方缓冲区用于存储<strong>已经准备就绪数据和发送了但是没有被确认的数据</strong>。<br>接收方缓冲区：接收方缓冲区用于存储<strong>已经被接收但是还没有被用户进程消费的数据。</strong></p>
<p>滑动窗口机制是<strong>TCP的一种流量控制方法</strong>，该机制允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率<strong>提高应用的吞吐量。</strong></p>
<p>TCP的包可以分为四种状态</p>
<p>已发送并且已经确认的包。<br>已发送但是没有确认的包。<br>未发送但是可以发送的包。<br>不允许被发送的包。</p>
<p>滑动窗口协议的基本工作流程就是由<strong>接收方通告窗口的大小</strong>，这个窗口称为提出窗口，也就是接收方窗口。接收方提出的窗口则是被接收缓冲区所影响的，如果数据没有被用户进程使用那么接收方通告的窗口就会相应得到减小，发送窗口取决于接收方窗口的大小。可用窗口的大小等于<strong>接收方窗口减去发送但是没有被确认的数据包大小。</strong></p>
<p>最基本的传输可靠性来源于<strong>“确认重传”</strong>机制。</p>
<p>TCP的滑动窗口的可靠性也是建立在“确认重传”基础上的。</p>
<p><strong>发送窗口</strong>只有收到对端对于本段发送窗口内字节的ACK确认，才会<strong>移动发送窗口的左边界。</strong></p>
<p><strong>接收窗口</strong>只有在<strong>前面所有的段都确认的情况下才会移动左边界。</strong>当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。</p>
<p><strong>累计确认：</strong></p>
<p><img src="https://i.loli.net/2021/08/05/To93btGQDuPNFpl.png" alt="image-20210731150833402"></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>怎么让发送⽅<strong>避免发送⼩数据呢？</strong><br>发送⽅通常的策略:<br>使⽤ <strong>Nagle 算法</strong>，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据：<br>窗⼝⼤⼩ &gt;&#x3D; MSS 或是 数据⼤⼩ &gt;&#x3D; MSS<br>收到之前发送数据的 ack 回包<br>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。<br>另外，Nagle 算法默认是打开的，可以在 <strong>Socket 设置 TCP_NODELAY</strong> 选项来关闭这个算法。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p><strong>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</strong><br>拥塞窗⼝ cwnd是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。<br>我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。<br><strong>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</strong><br><strong>但⽹络中出现了拥塞， cwnd 就减少</strong>；</p>
<p><strong>那么怎么知道当前⽹络是否出现了拥塞呢？</strong><br>其实只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是<strong>发⽣了超时重传</strong>，就会认为⽹络出现了⽤拥塞。</p>
<h5 id="拥塞控制有哪些控制算法？"><a href="#拥塞控制有哪些控制算法？" class="headerlink" title="拥塞控制有哪些控制算法？"></a><strong>拥塞控制有哪些控制算法？</strong></h5><p><strong>慢启动开始</strong></p>
<p>1.开始时发送方cwnd&#x3D;1，发送报文段M1，如果收到确认M1，那么此时增大cwnd&#x3D;2，并发送M2，M3</p>
<p>2.要注意，发送方每收到一个确认报文段，cwnd+1（不包括缺失重传的确认）</p>
<p>也就是说，<strong>每经过一个传输伦次（RTT时间）</strong>，cwnd加倍。</p>
<p>但是，为了防止拥塞窗口cwnd增长过大而引起网络拥塞，<strong>设置一个慢开始门限ssthresh</strong>。</p>
<p>1.当cwnd&lt;ssthresh，使用上述的慢开始算法</p>
<p>2.当cwnd&gt;ssthresh，停止使用慢开始，使用拥塞避免算法</p>
<p>3.当cwnd&#x3D;&#x3D;ssthresh，两者都可以使用</p>
<p><strong>拥塞避免</strong></p>
<p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口<strong>cwnd+1，</strong>而不是加倍，这样cwnd就按线性增大。</p>
<p><strong>快重传</strong></p>
<p>快重传规定，发送方只要连续收到3个重复确认，立即重传对方发来的M3。</p>
<p><img src="https://i.loli.net/2021/08/05/zJP16DFvGAOWirM.png" alt="image-20210805160153353"></p>
<p><strong>快恢复</strong></p>
<p>当发送方连续收到三个重复确认，执行乘法减小，ssthresh减半</p>
<p>1，由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把cwnd值设置为ssthresh减半之后的值，然后执行拥塞避免算法，线性增大cwnd。</p>
<p>2，既然发送方收到<strong>三个重复的确认</strong>，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p><img src="https://i.loli.net/2021/08/05/pvt5AOQLyq2WUa8.png" alt="image-20210731151028278"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http/" class="post-title-link" itemprop="url">计算机网络-http</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:04:12" itemprop="dateCreated datePublished" datetime="2021-07-30T15:04:12+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>HTTP 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和 规范」。</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><table>
<thead>
<tr>
<th align="left">方法 get：获取资源。 post：传输内容实体。 put：传输文件。 head：与get类似，不返回内容主体。</th>
<th>URI</th>
<th>协议版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可选的首部字段</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">内容实体</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>协议版本</th>
<th>状态码</th>
<th>状态码原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>可选的响应首部字段</td>
<td></td>
<td></td>
</tr>
<tr>
<td>主体</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。 </p>
<p>2xx 类状态码表示<strong>服务器成功处理了客户端的请求</strong>，也是我们最愿意看到的状态。 </p>
<ul>
<li>「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。 </li>
<li>「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽ 是其中的⼀部分，也是服务器处理成功的状态。</li>
</ul>
<p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是重定向。 </p>
<ul>
<li>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。 </li>
<li>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。 301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。</li>
</ul>
<p>4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。 </p>
<ul>
<li>「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。 </li>
<li>「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。 </li>
<li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</li>
</ul>
<p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。 </p>
<ul>
<li>「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</li>
<li>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</li>
<li>「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器 发⽣了错误。 </li>
<li>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器。</li>
</ul>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>Host 字段 客户端发送请求时，⽤来指定服务器的域名。</p>
<p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。</p>
<p>Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。</p>
<p>Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<p>Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式</p>
<h3 id="get-post"><a href="#get-post" class="headerlink" title="get post"></a>get post</h3><h4 id="区别？"><a href="#区别？" class="headerlink" title="区别？"></a>区别？</h4><p>Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。</p>
<p>POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。⽐如，留⾔后点击「提交」，浏览器就会执⾏⼀次 POST 请求，把你的留⾔⽂字放进了报⽂ body ⾥，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</p>
<h4 id="安全幂等？"><a href="#安全幂等？" class="headerlink" title="安全幂等？"></a>安全幂等？</h4><p>在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。</p>
<p>所谓的「幂等」，意思是<strong>多次执⾏相同的操作</strong>，结果都是「相同」的。</p>
<p>那么很明显 <strong>GET ⽅法就是安全且幂等</strong>的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong>。</p>
<h3 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议,如何保存用户状态?"></a>HTTP 是不保存状态的协议,如何保存用户状态?</h3><p><img src="https://i.loli.net/2021/08/06/PvL5K2BYp18URHu.png" alt="image-20210806103941528"></p>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p>
<p><strong>Session 机制</strong>的存在就是为了解决这个问题，Session 的主要作用就是<strong>通过服务端记录用户的状态</strong>。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。</p>
<p>服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，<strong>我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</strong></p>
<p>Cookie 被禁用怎么办?</p>
<p><strong>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</strong></p>
<h3 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么?和 Session 有什么区别？"></a>Cookie 的作用是什么?和 Session 有什么区别？</h3><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>Cookie 一般用来保存用户信息 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><table>
<thead>
<tr>
<th>http</th>
<th>不安全</th>
<th>三次握手</th>
<th>80端口</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>https</td>
<td>安全（SSL&#x2F;TSL）</td>
<td>三次握手+SSL握手</td>
<td>443端口</td>
<td>需要向CA申请数字证书</td>
</tr>
</tbody></table>
<h3 id="解决了啥？"><a href="#解决了啥？" class="headerlink" title="解决了啥？"></a>解决了啥？</h3><blockquote>
<p>窃听-信息加密</p>
<p>篡改-校验</p>
<p>冒充-身份证书</p>
</blockquote>
<h3 id="如何解决不安全的问题？"><a href="#如何解决不安全的问题？" class="headerlink" title="如何解决不安全的问题？"></a>如何解决不安全的问题？</h3><p>混合加密</p>
<p>对称加密（只有一个密钥，速度快）（通信过程中）+非对称加密（两个密钥）（通信建立前）</p>
<p>摘要算法实现完整性：每份数据都生成独一无二的指纹。</p>
<p>服务器公钥放到数字证书中</p>
<p><img src="https://i.loli.net/2021/08/08/YsWAFXOp5Mbx1vy.png" alt="image-20210808135009407"></p>
<h2 id="http演变"><a href="#http演变" class="headerlink" title="http演变"></a>http演变</h2><h3 id="什么是HTTP-2-0"><a href="#什么是HTTP-2-0" class="headerlink" title="什么是HTTP 2.0"></a>什么是HTTP 2.0</h3><p>HTTP&#x2F;2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP&#x2F;2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。</p>
<h3 id="与HTTP-1-1相比，主要区别包括"><a href="#与HTTP-1-1相比，主要区别包括" class="headerlink" title="与HTTP 1.1相比，主要区别包括"></a>与HTTP 1.1相比，主要区别包括</h3><p>HTTP&#x2F;2<strong>采用二进制格式而非文本格式</strong><br>HTTP&#x2F;2是<strong>完全多路复用的</strong>，而非有序并阻塞的——只需一个连接即可实现并行<br>使用<strong>报头压缩</strong>，HTTP&#x2F;2降低了开销<br>HTTP&#x2F;2让服务器可以将响应主动“推送”到客户端缓存中</p>
<h3 id="HTTP-x2F-2为什么是二进制？"><a href="#HTTP-x2F-2为什么是二进制？" class="headerlink" title="HTTP&#x2F;2为什么是二进制？"></a>HTTP&#x2F;2为什么是二进制？</h3><p>比起像HTTP&#x2F;1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。</p>
<h3 id="为什么-HTTP-x2F-2-需要多路传输"><a href="#为什么-HTTP-x2F-2-需要多路传输" class="headerlink" title="为什么 HTTP&#x2F;2 需要多路传输?"></a>为什么 HTTP&#x2F;2 需要多路传输?</h3><p>HTTP&#x2F;1.x 有个问题叫<strong>线端阻塞</strong>(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP&#x2F;1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。</p>
<p>而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。</p>
<h3 id="消息头为什么需要压缩"><a href="#消息头为什么需要压缩" class="headerlink" title="消息头为什么需要压缩?"></a>消息头为什么需要压缩?</h3><p>假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。</p>
<h3 id="服务器推送的好处是什么？"><a href="#服务器推送的好处是什么？" class="headerlink" title="服务器推送的好处是什么？"></a>服务器推送的好处是什么？</h3><p>当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。<strong>服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">计算机网络-网络模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:04:02" itemprop="dateCreated datePublished" datetime="2021-07-30T15:04:02+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>999</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h3><p><strong>应用层</strong></p>
<p>服务与用户应用。</p>
<p><strong>表示层</strong></p>
<p>解决信息的语法表示问题，比如加密解密。</p>
<p><strong>会话层</strong></p>
<p>实现不同主机上用户进程之间的通信。</p>
<p><strong>传输层</strong></p>
<p><strong>网络层</strong></p>
<p><strong>链路层</strong></p>
<p><strong>物理层</strong></p>
<h3 id="五层标准模型"><a href="#五层标准模型" class="headerlink" title="五层标准模型"></a>五层标准模型</h3><p><strong>应用层</strong></p>
<p>专注于为用户提供应用功能，不关心如何传输。工作于用户态。<br>决定了向用户提供应用服务时的通信活动。</p>
<p>DNS（域名系统）&#x3D;域名和IP的映射,HTTP（生成针对目标服务器的HTTP请求报文）,FTP（文件传输协议）</p>
<p>HTTP报文</p>
<p><strong>传输层</strong></p>
<p>两台计算机之间的数据传输。为应用层提供网络支持。</p>
<p>TCP(传输控制协议)&#x2F;UDP（用户数据报协议）</p>
<p>TCP报文段</p>
<p><strong>网络层</strong></p>
<p>规定了通过怎样的路径到达对方计算机。（选择一条传输路线）将数据从一个设备传输到另一个设备。</p>
<p>IP（寻址，路由）一边中转一边传送</p>
<p>IP数据包</p>
<p><strong>链路层</strong></p>
<p>（处理连接网络的硬件部分）标识网络中的设备，为网络层提供链路级别的服务。</p>
<p>ARP&#x3D;&#x3D;<strong>ip地址到硬件地址的动态映射</strong>-ARP高速缓存。</p>
<p><strong>物理层</strong></p>
<p>为链路层提供二进制传输服务。</p>
<h3 id="打开百度到显示具体过程？"><a href="#打开百度到显示具体过程？" class="headerlink" title="打开百度到显示具体过程？"></a>打开百度到显示具体过程？</h3><p><strong>解析URL</strong></p>
<p><strong>DNS 解析</strong></p>
<p><strong>TCP 连接</strong></p>
<p><strong>发送 HTTP 请求</strong></p>
<p><strong>服务器处理请求并返回 HTTP 报文</strong></p>
<p><strong>浏览器解析渲染页面</strong></p>
<p><strong>连接结束</strong></p>
<p><img src="https://i.loli.net/2021/08/06/pIaiW62BMZtPrmS.png" alt="image-20210806103355600"></p>
<p><strong>解析url</strong></p>
<p><strong>生成http消息</strong></p>
<p><strong>真实地址查询dns</strong></p>
<p><img src="https://i.loli.net/2021/08/05/imGRJ3j4PqUerE7.png" alt="image-20210731105736261"></p>
<p><strong>应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。</strong></p>
<p>协议栈的上半部分有两块，是负责收发数据的TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。</p>
<p>协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽<br>将⽹络包发送给对⽅的操作就是由 IP 负责的。</p>
<p>此外 IP 中还包括 ICMP 协议和 ARP 协议。<br>ICMP ⽤于<strong>告知⽹络包传送过程中产⽣的错误以及各种控制信息。</strong><br>ARP ⽤于<strong>根据 IP 地址查询相应的以太⽹ MAC 地址。</strong></p>
<p><strong>可靠传输 TCP</strong></p>
<p><strong>远程定位 IP</strong></p>
<p><strong>两点传输 MAC</strong></p>
<p>在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输。<br>⼀般在 TCP&#x2F;IP 通信⾥，MAC 包头的协议类型只使⽤：<br>0800 ： IP 协议<br>0806 ： ARP 协议</p>
<p><strong>先查询 ARP 缓存</strong>，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中 的地址。 ⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP <strong>⼴播查询。</strong></p>
<p><strong>出⼝ ⽹卡</strong></p>
<p>⽹卡驱动从 IP 模块获取到包之后，会将其复制到⽹卡内的缓存区中，接着会在其开头加上报头和起始帧分界符， 在末尾加上⽤于检测错误的帧校验序列</p>
<p><img src="https://i.loli.net/2021/08/05/gpoRLKxYM84Xcwn.png" alt="image-20210731104901289"></p>
<p><img src="https://i.loli.net/2021/08/05/74mbiBgpHStlhnx.png" alt="image-20210731104830860"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XieYi</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">263k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:59</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
