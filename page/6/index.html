<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"xieyi123456.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":true,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="think and do">
<meta property="og:type" content="website">
<meta property="og:title" content="XieYi&#39;s Blog">
<meta property="og:url" content="https://xieyi123456.github.io/page/6/index.html">
<meta property="og:site_name" content="XieYi&#39;s Blog">
<meta property="og:description" content="think and do">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XieYi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xieyi123456.github.io/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>XieYi's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="XieYi's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">XieYi's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">log something</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XieYi"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">XieYi</p>
  <div class="site-description" itemprop="description">think and do</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:2643100268@qq.com" title="E-Mail → mailto:2643100268@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E5%9F%BA%E7%A1%80-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E5%9F%BA%E7%A1%80-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java基础-Java集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:03:18" itemprop="dateCreated datePublished" datetime="2021-07-30T15:03:18+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p><img src="https://i.loli.net/2021/08/04/6xejDEtAQKSRpwv.png" alt="image-20210804212935827"></p>
<p><img src="https://i.loli.net/2021/08/04/leZ9CILv4hTbsYz.png" alt="image-20210804213053882"></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>在 JDK 1.8，HashMap 底层是由 “数组+链表+红黑树” 组成，如下图所示，而在 JDK 1.8 之前是由 “数组+链表” 组成。</p>
<p>使用 “数组+链表” 是为了解决 hash 冲突的问题。</p>
<p>数组和链表有如下特点：</p>
<p>数组：查找容易，通过 index 快速定位；插入和删除困难，需要移动插入和删除位置之后的节点；<br>链表：查找困难，需要从头结点或尾节点开始遍历，直到寻找到目标节点；插入和删除容易，只需修改目标节点前后节点的 next 或 prev 属性即可；</p>
<p>HashMap 巧妙的将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做 “拉链法” 的方式来解决哈希冲突。<br>首先通过 index 快速定位到索引位置，这边利用了数组的优点；然后遍历链表找到节点，进行节点的新增&#x2F;修改&#x2F;删除操作，这边利用了链表的优点。</p>
<h3 id="为什么要改成“数组-链表-红黑树”？"><a href="#为什么要改成“数组-链表-红黑树”？" class="headerlink" title="为什么要改成“数组+链表+红黑树”？"></a>为什么要改成“数组+链表+红黑树”？</h3><p>“数组+链表” 在定位到索引位置后，需要先遍历链表找到节点，这个地方如果链表很长的话，也就是 hash 冲突很严重的时候，会有查找性能问题，因此在 JDK1.8 中，通过引入红黑树，来优化这个问题。<br>使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</p>
<h3 id="那在什么时候用链表？什么时候用红黑树？"><a href="#那在什么时候用链表？什么时候用红黑树？" class="headerlink" title="那在什么时候用链表？什么时候用红黑树？"></a>那在什么时候用链表？什么时候用红黑树？</h3><p>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后超过 8 个（阈值 8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于 64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</p>
<p>对于移除，当同一个索引位置的节点在移除后<strong>达到 6 个（阈值 6）</strong>，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。</p>
<h3 id="为什么链表转红黑树的阈值是-8？"><a href="#为什么链表转红黑树的阈值是-8？" class="headerlink" title="为什么链表转红黑树的阈值是 8？"></a>为什么链表转红黑树的阈值是 8？</h3><p>我们平时在进行方案设计时，必须考虑的两个很重要的因素是：时间和空间。对于 HashMap 也是同样的道理，简单来说，阈值为 8 是在时间和空间上权衡的结果。</p>
<p>红黑树节点大小约为链表节点的 2 倍，在节点太少时，红黑树的查找性能优势并不明显，付出 2 倍空间的代价不值得。</p>
<p>理想情况下，使用随机的哈希码，节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的公式计算，链表中<strong>节点个数为 8 时的概率</strong>为 0.00000006，这个概率足够低了，并且到 8 个节点时，红黑树的性能优势也会开始展现出来，因此 8 是一个较合理的数字。</p>
<h3 id="那为什么转回链表节点是用的-6-而不是复用-8？"><a href="#那为什么转回链表节点是用的-6-而不是复用-8？" class="headerlink" title="那为什么转回链表节点是用的 6 而不是复用 8？"></a>那为什么转回链表节点是用的 6 而不是复用 8？</h3><p>如果我们设置节点多于 8 个转红黑树，少于 8 个就马上转链表，<strong>当节点个数在 8 徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗。</strong></p>
<h3 id="HashMap-有哪些重要属性？分别用于做什么的？"><a href="#HashMap-有哪些重要属性？分别用于做什么的？" class="headerlink" title="HashMap 有哪些重要属性？分别用于做什么的？"></a>HashMap 有哪些重要属性？分别用于做什么的？</h3><p>除了用来存储我们的节点 table 数组外，HashMap 还有以下几个重要属性：<br>1）size：HashMap 已经存储的节点个数；<br>2）<strong>threshold</strong>：1）扩容阈值（主要），当 HashMap 的个数达到该值，触发扩容。2）初始化时的容量，在我们新建HashMap 对象时， threshold 还会被用来存初始化时的容量。HashMap 直到我们第一次插入节点时，才会对 table进行初始化，避免不必要的空间浪费。<br>3）<strong>loadFactor</strong>：负载因子，扩容阈值 &#x3D; 容量 * 负载因子。</p>
<h3 id="HashMap-的默认初始容量是多少？HashMap-的容量有什么限制吗？"><a href="#HashMap-的默认初始容量是多少？HashMap-的容量有什么限制吗？" class="headerlink" title="HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？"></a>HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？</h3><p>默认初始容量是 16。HashMap 的容量必须是 2 的 N 次方，HashMap 会根据我们传入的容量计算一个“大于等于该容量的最小的 2 的 N 次方”，例如传 16，容量为 16；传 17，容量为 32。</p>
<h3 id="HashMap-的容量必须是-2-的-N-次方，这是为什么？"><a href="#HashMap-的容量必须是-2-的-N-次方，这是为什么？" class="headerlink" title="HashMap 的容量必须是 2 的 N 次方，这是为什么？"></a>HashMap 的容量必须是 2 的 N 次方，这是为什么？</h3><p>计算索引位置的公式为：**(n - 1) &amp; hash**</p>
<p>当 n 为 2 的 N 次方时，n - 1 为低位全是 1 的值，此时任何值跟 n - 1 进行 &amp; 运算的结果为该值的低 N 位，达到了和取模同样的效果，实现了均匀分布。</p>
<p>实际上，这个设计就是基于式：<br><strong>x mod 2^n &#x3D; x &amp; (2^n - 1)，因为 &amp; 运算比 mod 具有更高的效率。</strong></p>
<h3 id="插入流程"><a href="#插入流程" class="headerlink" title="插入流程"></a>插入流程</h3><p><img src="https://i.loli.net/2021/08/04/CDL1MPFjsV5k9Tw.png" alt="image-20210804211704324"></p>
<h3 id="ConcurrenHashMap，1-7-和-1-8-的区别"><a href="#ConcurrenHashMap，1-7-和-1-8-的区别" class="headerlink" title="ConcurrenHashMap，1.7 和 1.8 的区别"></a>ConcurrenHashMap，1.7 和 1.8 的区别</h3><p>ConcurrentHashMap 是 HashMap 的线程安全版本，和 HashMap 一样，在 JDK 1.8 中进行了较大的优化。</p>
<p>JDK1.7：底层结构为：分段的数组+链表；实现线程安全的方式：分段锁（Segment，继承ReentrantLock），</p>
<p><img src="https://i.loli.net/2021/08/04/FliNj7RXtm2oSv5.png" alt="image-20210804212122257"></p>
<p>JDK1.8：底层结构为：数组+链表+红黑树；实现线程安全的方式：CAS + Synchronized，synchronized只会锁定当前链表或者红黑树的首节点。效率大大提高。</p>
<p><img src="https://i.loli.net/2021/08/04/uMemQzWqZdTXxK1.png" alt="image-20210804212314272"></p>
<p><strong>区别：</strong></p>
<p>1、JDK1.8 中降低锁的粒度。JDK1.7 版本锁的粒度是基于 Segment 的，包含多个节点（HashEntry），而 JDK1.8 锁的粒度就是单节点（Node）。</p>
<p>2、JDK1.8 版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用 synchronized 来进行同步，所以不需要分段锁的概念，也就不需要 Segment 这种数据结构了，当前还保留仅为了兼容。</p>
<p>3、JDK1.8 使用红黑树来优化链表，跟 HashMap 一样，优化了极端情况下，链表过长带来的性能问题。</p>
<p>4、JDK1.8 使用内置锁 synchronized 来代替重入锁 ReentrantLock，synchronized 是官方一直在不断优化的，现在性能已经比较可观，也是官方推荐使用的加锁方式</p>
<h3 id="map对比？"><a href="#map对比？" class="headerlink" title="map对比？"></a>map对比？</h3><p><img src="https://i.loli.net/2021/08/04/jIZsbOmcCagN18q.png" alt="image-20210804212504959"></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><p>Vector 和 ArrayList 的实现几乎是一样的，区别在于：</p>
<p>1）最重要的的区别：Vector 在方法上使用了 synchronized 来保证线程安全，同时由于这个原因，在性能上 ArrayList会有更好的表现。</p>
<p>2） Vector 扩容后容量默认变为原来 2 倍，而 ArrayList 为原来的 1.5 倍。</p>
<h3 id="ArrayList-和-LinkedList-的区别？"><a href="#ArrayList-和-LinkedList-的区别？" class="headerlink" title="ArrayList 和 LinkedList 的区别？"></a>ArrayList 和 LinkedList 的区别？</h3><h4 id="arraylist扩容"><a href="#arraylist扩容" class="headerlink" title="arraylist扩容"></a>arraylist扩容</h4><p>第一种情况，当ArrayList的容量为0时，此时添加元素的话，需要扩容，三种构造方法创建的ArrayList在扩容时略有不同：</p>
<p>1.无参构造，创建ArrayList后容量为0，添加第一个元素后，<strong>容量变为10</strong>，此后若需要扩容，则正常扩容。</p>
<p>2.传容量构造，当参数为0时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</p>
<p>3.传列表构造，当列表为空时，创建ArrayList后容量为0，添加第一个元素后，容量为1，此时ArrayList是满的，下次添加元素时需正常扩容。</p>
<p>第二种情况，当ArrayList的容量大于0，并且ArrayList是满的时，此时添加元素的话，进行正常扩容，每次扩容<strong>到原来的1.5倍。</strong></p>
<p>1、ArrayList 底层基于<strong>动态数组</strong>实现，LinkedList 底层基于<strong>双向链表</strong>实现。</p>
<p>2、对于<strong>随机访问（按 index 访问，get&#x2F;set 方法）</strong>：ArrayList 通过 index 直接定位到数组对应位置的节点，而 LinkedList需要从头结点或尾节点开始遍历，直到寻找到目标节点，<strong>在效率上 ArrayList 优于 LinkedList</strong>。</p>
<p>3、对于<strong>随机插入和删除</strong>：ArrayList 需要移动目标节点后面的节点（使用 System.arraycopy 方法移动节点），而LinkedList 只需修改目标节点前后节点的 next 或 prev 属性即可，因此在效率上 LinkedList 优于 ArrayList。</p>
<p>4、对于<strong>顺序插入和删除：由于 ArrayList 不需要移动节点，因此在效率上比 LinkedList 更好</strong>。这也是为什么在实际使用中 ArrayList 更多，因为<strong>大部分情况下我们的使用都是顺序插入。</strong></p>
<p>5、两者都不是线程安全的。</p>
<p>6、内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会<strong>预留一定的容量空间</strong>，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="hashmap对比hashtable"><a href="#hashmap对比hashtable" class="headerlink" title="hashmap对比hashtable"></a>hashmap对比hashtable</h3><p>线程安全：hashmap不安全，hashtable安全（方法被synchronized修饰过）。</p>
<p>效率：hashtable效率很低，被淘汰。</p>
<p>null key value？：hashmap支持一个null key。hashtable不支持。</p>
<p>扩容：hashtable初始：不指定的话为11，之后变为原来的2n+1。hashmap初始16，每次扩充两倍。hashmap在指定了初始容量后会扩充为2的幂次大小。</p>
<p>底层：解决hash冲突，hashmap在链表大于8会转化成红黑树（如果数组长度小于64，会先进性扩容）。</p>
<h3 id="List、Set、Map-三者的区别"><a href="#List、Set、Map-三者的区别" class="headerlink" title="List、Set、Map 三者的区别?"></a>List、Set、Map 三者的区别?</h3><p>List（对付<strong>顺序</strong>的好帮手）： 存储的对象是可重复的、有序的。<br>Set（注重<strong>独一无二</strong>的性质）：存储的对象是不可重复的、无序的。<br>Map（<strong>用 Key 来搜索的专业户</strong>）: 存储键值对（key-value），不能包含重复的键（key），每个键只能映射到一个值</p>
<h3 id="map遍历方式："><a href="#map遍历方式：" class="headerlink" title="map遍历方式："></a>map遍历方式：</h3><p>HashMap 遍历从大的方向来说，可分为以下 4 类：</p>
<p><strong>迭代器（Iterator）方式遍历；</strong></p>
<p><strong>For Each 方式遍历；</strong></p>
<p><strong>Lambda 表达式遍历（JDK 1.8+）;</strong></p>
<p><strong>Streams API 遍历（JDK 1.8+）。</strong></p>
<p>使用迭代器（Iterator）<strong>EntrySet</strong> 的方式进行遍历；</p>
<p>使用迭代器（Iterator）<strong>KeySet</strong> 的方式进行遍历；</p>
<p>使用 For Each <strong>EntrySet</strong> 的方式进行遍历；</p>
<p>使用 For Each <strong>KeySet</strong> 的方式进行遍历；</p>
<p>使用 Lambda 表达式的方式进行遍历；</p>
<p>使用 Streams API <strong>单线程</strong>的方式进行遍历；</p>
<p>使用 Streams API <strong>多线程</strong>的方式进行遍历</p>
<p><img src="https://i.loli.net/2021/08/05/ZP9ot578UVrd2RN.png" alt="计算机生成了可选文字: Iterator(Map. Entry(Integer, Strlng»  (iterator.hasNext()) {  Map. Strlng) entry  ma p ． entrySet() ． iterator();  iterator ． n 巳 〔 ） ；  Sysæn. out ． println(entry ． getKey());  Sysæn. out ． println(entry ． getVa1ue()) ； "></p>
<p><img src="https://i.loli.net/2021/08/05/jNw9YtiOlCLV2Bf.png" alt="计算机生成了可选文字: map.keyset().iterator();  Iterator(Integer) Iterator  (iterator.hasNext()) {  Integer key  iterator ． n 巳 〔 ） ；  Sysæn. out ． println(key);  Sysæn. out.println(map• get 〔 k ey ） ); "></p>
<p><img src="https://i.loli.net/2021/08/05/7qwG2cHSj514gf3.png" alt="计算机生成了可选文字: (Map.Entry(lnteger, String) entry ： ma p ． entrySet()) {  Sysæn. out ． println(entry ． getKey());  Sysæn. out ． println(entry ． getVa1ue()) ； "></p>
<p><img src="https://i.loli.net/2021/08/05/qfBMmXg3ljFUEko.png" alt="计算机生成了可选文字: 〔 Integer key ： map.keySet()) {  Sysæn. out ． println(key);  Sysæn. out.println(map• get 〔 k ey ） ); "></p>
<p><img src="https://i.loli.net/2021/08/05/hrf2daRyeQqODsx.png" alt="计算机生成了可选文字: map.forEach((key, value) 一 》 {  Sysæn. out ． println(key);  Sysæn. out ． println(ualue) ； "></p>
<p><img src="https://i.loli.net/2021/08/05/oKvs6jBOxzQUZhJ.png" alt="计算机生成了可选文字: ma p ． entrySet().stream(). forEach((entry) 一 》 {  Sysæn. out ． println(entry ． getKey());  Sysæn. out ． println(entry ． getVa1ue()) ； "></p>
<p><img src="https://i.loli.net/2021/08/05/KMzILTYf1nwu8ci.png" alt="计算机生成了可选文字: ma p ． entrySet().para11e1Stream(). forEach((entry) 一 》 {  Sysæn. out ． println(entry ． getKey());  Sysæn. out ． println(entry ． getVa1ue()) ； "></p>
<p><strong>EntrySet</strong> 之所以比 <strong>KeySet</strong> 的性能高是因为，**KeySet 在循环时使用了 map.get(key)**，而 map.get(key) 相当于又遍历了一遍 Map 集合去查询 key 所对应的值。为什么要用“又”这个词？那是因为在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 map.get(key) 查询时，相当于遍历了两遍。</p>
<p>而 <strong>EntrySet</strong> 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry &#x3D; iterator.next()”把对象的 key 和 value 值都放入到了 Entry 对象中，因此再获取 key 和 value 值时就无需再遍历 Map 集合，只需要从 Entry 对象中取值就可以了。</p>
<p>所以，<strong>EntrySet 的性能比 KeySet 的性能高出了一倍</strong>，因为 KeySet 相当于循环了两遍 Map 集合，而 EntrySet 只循环了一遍。</p>
<p>我们不能在<strong>遍历中使用</strong>集合 map.remove() 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <strong>iterator.remove() 的方法来删除数据</strong>，这是安全的删除集合的方式。</p>
<p>同样的我们也可以使用 Lambda 中的 removeIf 来提前删除数据，或者是使用 Stream 中的 filter 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 for 循环前删除数据在遍历也是线程安全的。</p>
<p>综合性能和安全性来看，我们应该尽量使用<strong>迭代器（Iterator）来遍历 EntrySet 的遍历方式来操作 Map 集合</strong>，这样就会既安全又高效。</p>
<h3 id="Comparable-和-Comparator-比较？"><a href="#Comparable-和-Comparator-比较？" class="headerlink" title="Comparable 和 Comparator 比较？"></a>Comparable 和 Comparator 比较？</h3><p>1、Comparable 是<strong>排序接口</strong>，一个类实现了 Comparable 接口，意味着“该类支持排序”。Comparator 是<strong>比较器，我们可以实现该接口，自定义比较算法，创建一个 “该类的比较器” 来进行排序</strong>。</p>
<p>2、Comparable 相当于“内部比较器”，而 Comparator 相当于“外部比较器”。</p>
<p>3、Comparable 的耦合性更强，<strong>Comparator 的灵活性和扩展性更优。</strong></p>
<p>4、Comparable 可以用作类的默认排序方法，而 Comparator 则用于默认排序不满足时，提供自定义排序</p>
<h3 id="Collection-与-Collections-的区别"><a href="#Collection-与-Collections-的区别" class="headerlink" title="Collection 与 Collections 的区别"></a>Collection 与 Collections 的区别</h3><p>Collection：<strong>集合类的一个顶级接口</strong>，提供了对集合对象进行基本操作的通用接口方法。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式，常见的 List 与 Set 就是直接继承 Collection 接口。</p>
<p>Collections：<strong>集合类的一个工具类&#x2F;帮助类</strong>，提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="HashSet-是如何保证不重复的？"><a href="#HashSet-是如何保证不重复的？" class="headerlink" title="HashSet 是如何保证不重复的？"></a>HashSet 是如何保证不重复的？</h3><p>HashSet 底层使用 <strong>HashMap</strong> 来实现，元素放在 HashMap 的 key 里，value 为固定的 Object 对象。</p>
<p>当 add 时调用 HashMap 的 put 方法，如果元素不存在，则返回 null 表示 add 成功，否则 add 失败。</p>
<p>由于 HashMap 的 Key 值本身就不允许重复，HashSet 正好利用 HashMap 中 key 不重复的特性来校验重复元素。<img src="https://i.loli.net/2021/08/04/I2VuKypq5o7xWrd.png" alt="image-20210804213228204"></p>
<h3 id="Map、List、Set-它们有的线程安全类和线程不安全的类？"><a href="#Map、List、Set-它们有的线程安全类和线程不安全的类？" class="headerlink" title="Map、List、Set 它们有的线程安全类和线程不安全的类？"></a>Map、List、Set 它们有的线程安全类和线程不安全的类？</h3><p><strong>Map</strong></p>
<p>线程安全：<strong>CocurrentHashMap、Hashtable</strong><br>线程不安全：HashMap、LinkedHashMap、TreeMap、WeakHashMap</p>
<p><strong>List</strong></p>
<p>线程安全<strong>：Vector（线程安全版的 ArrayList）、Stack（继承 Vector，增加 pop、push 方法）、CopyOnWriteArrayList</strong><br>线程不安全：ArrayList、LinkedList</p>
<p><strong>Set</strong></p>
<p><strong>线程安全：CopyOnWriteArraySet（底层使用 CopyOnWriteArrayList，通过在插入前判断是否存在实现 Set 不重复的效果</strong></p>
<p>线程不安全：HashSet（基于 HashMap）、LinkedHashSet（基于 LinkedHashMap）、TreeSet（基于 TreeMap）、EnumSe</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E5%9F%BA%E7%A1%80-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E5%9F%BA%E7%A1%80-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Java基础-常见问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:03:04" itemprop="dateCreated datePublished" datetime="2021-07-30T15:03:04+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Java对象判空？"><a href="#Java对象判空？" class="headerlink" title="Java对象判空？"></a>Java对象判空？</h3><p>null：一个对象如果有可能是null的话，首先要做的就是判断是否为null：object &#x3D;&#x3D; null，否则就有可能会出现空指针异常，这个通常是我们在进行数据库的查询操作时，查询结果首先用object !&#x3D; null，进行非空判断，然后再进行其他的业务逻辑，这样可以避免出现空指针异常。</p>
<p>isempty：此方法可以使用于字符串，数组，集合都可以用。</p>
<pre><code>public boolean isEmpty() &#123;
    return value.length == 0;
&#125;
</code></pre>
<p>这里是一个对象的长度，使用这个方法，首先要排除对象不为null，否则当对象为null时，调用isEmpty方法就会报空指针了。</p>
<p>要想返回true，也就是一个对象的长度为0，也就是说首先这个对象肯定不为null了，内容为空时，才能返回true。</p>
<p>当创建一个新的对象时，栈里面有一个对象，堆里面有一个对象，栈里的对象指向堆里面的对象。对象包含引用对象和实际对象，也就是栈和值的关系，比如String a &#x3D; new String();，这句代码就在堆内存中产生了一个String对象””，和栈内存中一个引用对象a，也就是a指向了一个为空的字符串。当没有再次给引用对象a进行赋值时，操作a也即是操作这个空字符串。</p>
<h3 id="后端和前端交互接口"><a href="#后端和前端交互接口" class="headerlink" title="后端和前端交互接口"></a>后端和前端交互接口</h3><h3 id="Obiect类有哪些方法"><a href="#Obiect类有哪些方法" class="headerlink" title="Obiect类有哪些方法"></a>Obiect类有哪些方法</h3><p>1、 getClass()：获取类的class对象。<br>2、 hashCode:获取对象的hashCode值<br>3、 equals():比较对象是否相等，比较的是值和地址，子类可重写以自定义。<br>4、 clone()：克隆方法。<br>5、 toString():如果没有重写，应用对象将打印的是地址值。<br>6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>9、 finalize()：对象回收时调用</p>
<h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p>Java 中有 8 种基本数据类型，分别为：</p>
<p>6 种数字类型 ：byte-1、short-2、int-4、long-8、float-4、double-8<br>1 种字符类型：char-2<br>1 种布尔型：boolean-1位</p>
<p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。</p>
<p>包装类型不赋值就是 Null ，而基本类型有默认值且不是 Null。</p>
<p>基本数据类型直接存放在 <strong>Java 虚拟机栈中的局部变量表</strong>中，而包装类型属于<strong>对象类型</strong>，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p>
<p><strong>自动装箱与拆箱</strong></p>
<p>装箱：将基本类型用它们对应的引用类型包装起来；<br>拆箱：将包装类型转换为基本数据类型；</p>
<p>从字节码中，我们发现装箱其实就是调用了 <strong>包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法</strong>。</p>
<p>因此，</p>
<p>Integer i &#x3D; 10 等价于 Integer i &#x3D; Integer.valueOf(10)<br>int n &#x3D; i 等价于 int n &#x3D; i.intValue();</p>
<h4 id="为什么存在这两种类型呢？"><a href="#为什么存在这两种类型呢？" class="headerlink" title="为什么存在这两种类型呢？"></a>为什么存在这两种类型呢？</h4><p>我们都知道在Java语言中，new一个对象存储在堆里，我们通过栈中的引用来使用这些对象；但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在栈中，因此更加高效。</p>
<h4 id="有了基本类型为什么还要有包装类型呢？"><a href="#有了基本类型为什么还要有包装类型呢？" class="headerlink" title="有了基本类型为什么还要有包装类型呢？"></a>有了基本类型为什么还要有包装类型呢？</h4><p>我们知道Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<p>另外，当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。</p>
<h3 id="关键字总结"><a href="#关键字总结" class="headerlink" title="关键字总结"></a>关键字总结</h3><h4 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h4><p>final 关键字，意思是<strong>最终的、不可修改的</strong>，用来修饰类、方法和变量，具有以下特点：</p>
<p>final 修饰的类<strong>不能被继承</strong>，final 类中的所有成员方法都会被隐式的指定为 final 方法；</p>
<p>final 修饰的方法<strong>不能被重写</strong>；</p>
<p>final <strong>修饰的变量是常量</strong>，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</p>
<h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><p>static 关键字主要有以下四种使用场景：</p>
<p><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的<strong>成员属于类</strong>，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议<strong>通过类名调用</strong>。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p>
<p>调用格式：类名.静态变量名 类名.静态方法名()</p>
<p><strong>静态代码块:</strong> 静态代码块定义在<strong>类中方法外</strong>, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p>
<p><strong>静态内部类（static 修饰类的话只能修饰内部类</strong>）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>
<ol>
<li><strong>它的创建是不需要依赖外围类的创建。</strong></li>
<li>它<strong>不能使用任何外围类的非 static 成员变量和方法。</strong></li>
</ol>
<p><strong>静态导包</strong>(用来导入类中的静态资源，1.5 之后的新特性): 格式为：import static 这两个关键字连用可以<strong>指定导入某个类中的指定静态资源</strong>，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</p>
<h4 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h4><p>this 关键字用于<strong>引用类的当前实例</strong>。 例如：<br>此关键字是可选的， 但是，使用此关键字可能会使代码更易读或易懂。</p>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>super 关键字用于<strong>从子类访问父类的变量和方法</strong>。 例如：</p>
<p>使用 this 和 super 要注意的问题：</p>
<p>在构造器中使用 <strong>super() 调用父类中的其他构造方法时</strong>，<strong>该语句必须处于构造器的首行</strong>，否则编译器会报错。另外，<strong>this 调用本类中的其他构造方法时，也要放在首行。</strong></p>
<p><strong>this、super 不能用在 static 方法中。</strong></p>
<p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。</p>
<p><strong>而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象</strong>；所以， this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西。</p>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p><img src="https://i.loli.net/2021/08/05/Dg8pvr4FJswPIGn.png" alt="image-20210805171804390"></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了<strong>编译时类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p>
<p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？</p>
<p>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p>
<h3 id="x3D-x3D-与equals"><a href="#x3D-x3D-与equals" class="headerlink" title="&#x3D;&#x3D;与equals()?"></a>&#x3D;&#x3D;与equals()?</h3><p>&#x3D;&#x3D;判断两个对象的<strong>地址</strong>是不是相等，<strong>对于基本数据类型：值。引用数据类型：内存地址。</strong><br>equals()没有被覆盖重写，与&#x3D;&#x3D;一样。</p>
<p><strong>可以覆盖重写比较引用对象值的大小。</strong><br>举例：String中的equals方法是被重写过的。</p>
<h4 id="hashcode（）与equal（）？hashset去重？"><a href="#hashcode（）与equal（）？hashset去重？" class="headerlink" title="hashcode（）与equal（）？hashset去重？"></a>hashcode（）与equal（）？hashset去重？</h4><p><strong>为什么要有hashcode？</strong></p>
<p>当你把对象加⼊ HashSet 时， <strong>HashSet 会先计算对象的 hashcode 值来判断对象加⼊的位置</strong>，同时也会与其他已经加⼊的对象的 hashcode 值比较，如果没有相符的 hashcode， HashSet会假设对象没有重复出现。</p>
<p>但是如果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查 hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。</p>
<p><strong>这样我们就⼤⼤减少了 equals 的次数，相应就⼤⼤提⾼了执⾏速度。</strong><br><strong>hash优越的查询性能。</strong></p>
<h4 id="为什么重写equals必须重写hashcode-？"><a href="#为什么重写equals必须重写hashcode-？" class="headerlink" title="为什么重写equals必须重写hashcode()？"></a>为什么重写equals必须重写hashcode()？</h4><p>对象相等，hashcode一定相等，反之不一定（hash碰撞）。<br>hashcode()默认对堆上面的对象产生独特值，hashcode不同，对象一定不同。</p>
<p>举例：student s1&#x3D;new student(name&#x3D;”11”);<br>student s2&#x3D;new student(name&#x3D;”11”);</p>
<p>假如只重写equals而不重写hashcode，那么默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!&#x3D;s2。然而重写了equals，且s1.equals(s2)返回true。</p>
<p>根据hashcode的规则，<strong>两个对象相等其哈希值一定相等</strong>，所以矛盾就产生了，因此重写equals一定要重写hashcode。</p>
<h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><ol>
<li><p>重载(overloading) 是在一个类里面，<strong>方法名字相同，而参数不同。返回类型可以相同也可以不同。</strong></p>
<p>每个重载的方法（或者构造函数）都必须<strong>有一个独一无二的参数类型列表</strong>。</p>
<p>最常用的地方就是构造器的重载。</p>
</li>
<li><p>重写（发生于<strong>运行期</strong>）：<strong>子类继承父类的方法，输入一样，做出不同的操作就要覆盖重写父类方法。</strong></p>
</li>
</ol>
<p>  方法名，参数列表必须一样。</p>
<p>  抛出异常范围小于父类。<br>  访问修饰符可以降低限制。</p>
<p>  <strong>父类方法由private，final，static修饰时不能被重写。</strong></p>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>抽象类和接口的区别</strong></p>
<p>接口(interface)和抽象类(abstract class)是<strong>支持抽象类定义的两种机制。</strong></p>
<p><strong>接口是公开的</strong>，不能有私有的方法或变量，<strong>接口中的所有方法都没有方法体</strong>，通过关键字interface实现。</p>
<p><strong>抽象类</strong>是可以有私有方法或私有变量的，通过把类或者类中的方法声明为abstract来表示一个类是抽象类，<strong>被声明为抽象的方法不能包含方法体</strong>。子类实现方法必须含有相同的或者更低的访问级别(public-&gt;protected-&gt;private)。抽象类的子类为父类中所有抽象方法的具体实现，否则也是抽象类。</p>
<p><strong>接口可以被看作是抽象类的变体</strong>，接口中所有的方法都是抽象的，<strong>可以通过接口来间接的实现多重继承</strong>。接口中的成员变量都是static final类型，<strong>由于抽象类可以包含部分方法的实现</strong>，所以，在一些场合下抽象类比接口更有优势。</p>
<p><strong>相同点</strong></p>
<p><strong>接口的实现类</strong>或<strong>抽象类的子类</strong>都只有实现了接口或抽象类中的方法后才能实例化。</p>
<p><strong>不同点</strong></p>
<p><img src="https://i.loli.net/2021/08/05/thjlgoUynpEJR4P.png" alt="image-20210805171623086"></p>
<p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。</p>
<p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：就可以把该抽象类改写为接口：interface。</p>
<p><strong>那么接口的作用是什么呢？</strong></p>
<p>1、Java单继承的原因所以需要曲线救国 作为继承关系的一个补充。</p>
<p>2、把程序模块进行固化的契约,降低偶合。把若干功能拆分出来，按照契约来进行实现和依赖。（依赖倒置原则）</p>
<p>3、定义接口有利于代码的规范。（接口分离原则）</p>
<p><strong>abstract class 表示的是is a关系</strong>，<strong>interface表示的是like a关系。</strong></p>
<p><strong>抽象类强调的是从属关系，接口强调的是功能。</strong></p>
<p>抽象类作为很多子类的父类，它是一种<strong>模板式</strong>设计。</p>
<p>而接口是一种<strong>行为规范</strong>，它是一种辐射式设计。</p>
<p>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；</p>
<p>而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>
<h3 id="成员变量与局部变量？"><a href="#成员变量与局部变量？" class="headerlink" title="成员变量与局部变量？"></a>成员变量与局部变量？</h3><p>根据定义变量位置的不同，可以将变量分为成员变量和局部变量<br>     成员变量是在<strong>类范围</strong>内定义的变量<br>     局部变量是在<strong>一个方法内</strong>定义的变量<br>1，成员变量可以分为：<br>     实例属性 （不用static修饰）<br>            随着实例属性的存在而存在<br>     类属性 （static修饰）<br>            随着类的存在而存在<br>成员变量无需显式初始化，系统会自动对其进行默认初始化</p>
<p>2，局部变量可分为：<br>     形参（形式参数）<br>            在整个方法内有效<br>     方法局部变量 （方法内定义）<br>            从定义这个变量开始到方法结束这一段时间内有效<br>     代码块局部变量 （代码块内定义）<br>            从定义这个变量开始到代码块结束这一段时间内有效</p>
<p><strong>局部变量除了形参外</strong>，<strong>都必须显示初始化</strong>，也就是要指定一个初始值，否则不能访问。<br>java允许局部变量和成员变量重名，<strong>局部变量会覆盖成员变量的值</strong></p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ol>
<li>单一职责原则（Single Responsibility Principle）</li>
</ol>
<p>每一个类应该专注于做一件事情。</p>
<ol start="2">
<li>里氏替换原则（Liskov Substitution Principle）</li>
</ol>
<p>超类存在的地方，子类是可以替换的。</p>
<ol start="3">
<li>依赖倒置原则（Dependence Inversion Principle）</li>
</ol>
<p>实现尽量依赖抽象，不依赖具体实现。</p>
<ol start="4">
<li>接口隔离原则（Interface Segregation Principle）</li>
</ol>
<p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</p>
<ol start="5">
<li>迪米特法则（Law Of Demeter）</li>
</ol>
<p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p>
<ol start="6">
<li>开闭原则（Open Close Principle）</li>
</ol>
<p>面向扩展开放，面向修改关闭。</p>
<ol start="7">
<li>组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle CARP）</li>
</ol>
<p>尽量使用合成&#x2F;聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p>
<p><strong>面向过程：以事件为中心，一步一步实现每个步骤。以步骤划分。</strong></p>
<p>任务明确</p>
<p>效率高</p>
<p>扩展性差，复用性弱，逻辑需要深入思考。</p>
<p><strong>面向对象：以对象为中心，以功能划分，每个对象都有自己的属性与行为。</strong></p>
<p>程序模块化，结构化。</p>
<p>易于扩展，维护。</p>
<p>性能相对于面向过程低。</p>
<p>java性能相对低的原因主要在于其是半编译语言。</p>
<p><strong>封装</strong></p>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以<strong>提供一些可以被外界访问的方法来操作属性</strong>。</p>
<p>就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p>
<p><strong>继承</strong></p>
<p>不同类型的对象，<strong>相互之间经常有一定数量的共同点</strong>。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。</p>
<p>同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。</p>
<p>继承是<strong>使用已存在的类的定义作为基础建立新类的技术</strong>，新类的定义可以<strong>增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</strong></p>
<p>关于继承如下 3 点请记住：</p>
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是<strong>父类中的私有属性和方法子类是无法访问</strong>，只是拥有。<br>子类可以拥有自己属性和方法，即<strong>子类可以对父类进行扩展。</strong><br>子类可以用自己的方式实现父类的方法。</p>
<p><strong>多态</strong></p>
<p>多态，顾名思义，表示<strong>一个对象具有多种的状态</strong>。一种类型的变量可以引用多种实际类型的对象。实现方式：	  继承（多个子类重写同一方法）<br>      接口（实现接口并覆盖同一方法）</p>
<p><strong>多态的特点:</strong></p>
<p>对象类型和引用类型之间具有<strong>继承（类）&#x2F;实现（接口）的</strong>关系；<br>引用类型变量发出的方法调用的到底是哪个类中的方法，<strong>必须在程序运行期间才能确定；</strong><br>多态不能调用“只在子类存在但在父类不存在”的方法；<br>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p>
<h3 id="hash冲突解决"><a href="#hash冲突解决" class="headerlink" title="hash冲突解决"></a>hash冲突解决</h3><p><strong>开放地址法</strong></p>
<p>​	线性探测法：冲突之后，在紧跟着的地方安放数据。（大部分的数据都会聚集）。<br>​	二次探测法：往后找1,4,9,16,25,…位置有没有空位。<br>​	再哈希法：多个散列函数。</p>
<p>链地址法：</p>
<h3 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h3><p>String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。</p>
<p><strong>在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value</strong></p>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p><strong>线程安全性</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量<strong>，线程安全。</strong></p>
<p>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>
<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p>
<p>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
<p>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结：</p>
<p>操作少量的数据: 适用 String<br>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder<br>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p><img src="https://i.loli.net/2021/08/05/Hb642mCQlxy3M5o.png" alt="image-20210805134232290"></p>
<p>自定义异常：继承Exception类。</p>
<p><strong>异常的处理：</strong></p>
<ol>
<li><p>使用try  catch捕获异常。可以有多个catch，总会根据异常的类型优先找到第一个匹配的。因此，基类exception放在前面会导致后面的catch无法执行。</p>
</li>
<li><p>重新抛出异常。在catch中可以throw 新的或者原来的异常，表示当前代码不能完全处理。可以通过getCause()获取原始异常。</p>
</li>
<li><p>try catch finally。finally中语句始终会执行。适合释放资源，比如数据库连接，文件流释放等等。<br> 如果try  catch中有return，会在finally之后执行，但是finally不能改变其返回值。<br> finally中有return，try catch中的return会丢失，实际上会返回finally中的值。还会掩盖try catch中的异常。</p>
</li>
<li><p>try with resourses，用于资源的释放，无需写finally，会自动执行close（）。</p>
</li>
<li><p>throws，声明一个方法可能抛出的异常。</p>
</li>
</ol>
<p>  异常体系可以：<strong>对异常集中处理，还可以向上传递，不需要每层都处理，也可以向上传递，也不会被自动忽略。处理异常情况的代码可以大大减少。</strong></p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p><img src="https://i.loli.net/2021/08/05/gXcmZMILa2EnuiW.png" alt="image-20210805134331023"></p>
<p>为何有了字节流，还要有字符流？</p>
<p><strong>字符流是由java虚拟机将字节流转化而成。这个过程耗时，也容易出错。</strong></p>
<p>所以提供了字符流，对于字符进行流操作。<br>而对于音频，图片等等推荐字节流。</p>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 以GBK格式,读取文件</span><br><span class="line">FileInputStream fis = new FileInputStream(file);</span><br><span class="line">InputStreamReader isr = new InputStreamReader(fis, &quot;GBK&quot;);</span><br><span class="line">BufferedReader br = new BufferedReader(isr);</span><br><span class="line">String str = null;</span><br><span class="line">// 创建StringBuffer字符串缓存区</span><br><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">// 通过readLine()方法遍历读取文件</span><br><span class="line">while ((str = br.readLine()) != null) &#123;</span><br><span class="line">// 使用readLine()方法无法进行换行,需要手动在原本输出的字符串后面加&quot;\n&quot;或&quot;\r&quot;</span><br><span class="line">	str += &quot;\n&quot;;</span><br><span class="line">	sb.append(str);</span><br><span class="line">&#125;</span><br><span class="line">String str2 = sb.toString();</span><br><span class="line">// 以UTF-8格式写入文件,file.getAbsolutePath()即该文件的绝对路径,false代表不追加直接覆盖,true代表追加文件</span><br><span class="line">FileOutputStream fos = new FileOutputStream(file.getAbsolutePath(), false);</span><br><span class="line">OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;UTF-8&quot;);</span><br><span class="line">osw.write(str2);</span><br><span class="line">osw.flush();</span><br><span class="line">osw.close();</span><br><span class="line">fos.close();</span><br><span class="line">br.close();</span><br><span class="line">isr.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>



<h3 id="java-8新特性"><a href="#java-8新特性" class="headerlink" title="java 8新特性"></a>java 8新特性</h3><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><p>首先看看在老版本的Java中是如何排列字符串的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String a, String b) &#123;</span><br><span class="line">        return b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p>
<p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>


<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>

<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>什么叫函数式编程？</p>
<p>就可以理解成用什么参数执行了一件什么事情，这就是函数式编程，它是匿名内部类进一步的简化，可以让代码更加的简洁。</p>
<p>但它有一个使用的前提，接口得是函数式接口。</p>
<p>有且仅有一个抽象方法需要被重写的接口。</p>
<p>这个怎么理解？很简单，函数式编程和匿名内部类相比，它省略了啥？</p>
<p>它省略了接口中的方法名，为什么可以省略？</p>
<p>因为就只有一个方法，那就算省略了方法名字，也知道是用的那个方法。</p>
<p><strong>函数式接口：</strong> <strong>只有一个方法的接口。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface Runnable &#123;</span><br><span class="line"></span><br><span class="line">public abstract void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; <strong>简化编程模型</strong>，在新版本的框架底层大量应用！</p>
<p><img src="https://i.loli.net/2021/08/05/pbTIZtNPr8Q5v63.png" alt="image-20210805191320866"></p>
<p>　</p>
<p><strong>浏览器在接收到html文件后，会分几个步骤html文件转化成界面，这个过程就是渲染。</strong></p>
<p>　　1、解析html</p>
<p>　　2、构建dom树</p>
<p>　　3、dom树结合css文件，构建呈现树</p>
<p>　　4、布局</p>
<p>　　5、绘制</p>
<p>1、解析html和构建dom树是同步进行的，这个过程就是逐行解析代码，包括html标签和js动态生成的标签，最终生成dom树。</p>
<p>2、构建呈现树，就是把css文件和style标签的中的内容，结合dom树的模型，构建一个呈现树，写到内存，等待进一步生成界面。呈现树一定依赖dom树，呈现节点一定会有对应的dom节点，但是dom节点不一定会有对应的呈现节点，比如，被隐藏的一个div。</p>
<p>3、布局，这一步就是结合呈现树，把dom节点的大小、位置计算出来。虽然呈现节点已经附着在都没节点上，会有对元素大小、位置的定义，但是浏览器还需要根据实际窗口大小进行计算，比如对auto的处理。</p>
<p>4、绘制，把css中有关颜色的设置，背景、字体颜色等呈现出来。</p>
<h3 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h3><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。<br>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p><img src="https://i.loli.net/2021/08/05/PkHUFX6xJNeTbt2.png" alt="image-20210805200519957"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/" class="post-title-link" itemprop="url">最长回文子串（子序列）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 10:37:44" itemprop="dateCreated datePublished" datetime="2021-07-30T10:37:44+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="1，最长回文子串"><a href="#1，最长回文子串" class="headerlink" title="1，最长回文子串"></a>1，最长回文子串</h4><h5 id="动态规划：o（n-2）空间复杂度。"><a href="#动态规划：o（n-2）空间复杂度。" class="headerlink" title="动态规划：o（n^2）空间复杂度。"></a>动态规划：o（n^2）空间复杂度。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[i][j] 表示 s[i, j] 是否是回文串</span></span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="最优解：中心扩散法。o（1）空间复杂度。"><a href="#最优解：中心扩散法。o（1）空间复杂度。" class="headerlink" title="最优解：中心扩散法。o（1）空间复杂度。"></a>最优解：中心扩散法。o（1）空间复杂度。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (len - i &lt;= max / <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i, right = i;</span><br><span class="line">           <span class="keyword">while</span> (right &lt; len - <span class="number">1</span> &amp;&amp; s.charAt(right + <span class="number">1</span>) == s.charAt(right))</span><br><span class="line">               ++right; <span class="comment">//过滤掉重复的</span></span><br><span class="line">           <span class="comment">//下次在判断的时候从重复的下一个字符开始判断</span></span><br><span class="line">           i = right + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//然后往两边判断，找出回文子串的长度</span></span><br><span class="line">           <span class="keyword">while</span> (right &lt; len - <span class="number">1</span> &amp;&amp; left &gt; <span class="number">0</span> &amp;&amp; s.charAt(right + <span class="number">1</span>) == s.charAt(left - <span class="number">1</span>)) &#123;</span><br><span class="line">               ++right;</span><br><span class="line">               --left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">               max = right - left + <span class="number">1</span>;</span><br><span class="line">               start = left;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s.substring(start, start + max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，最长回文子序列"><a href="#2，最长回文子序列" class="headerlink" title="2，最长回文子序列"></a>2，最长回文子序列</h4><h5 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h5><p>dp[i][j]表示i,j范围的最长回文子序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.length() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，无重复最长子串"><a href="#3，无重复最长子串" class="headerlink" title="3，无重复最长子串"></a>3，无重复最长子串</h4><p>高频</p>
<p>思路：滑动窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=s.length();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i=Math.max(i,map.get(s.charAt(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,j-i+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j),j+<span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">核心：发现了重复的字符，左边窗口就要向右一位。</span><br><span class="line">    如下写法亦可。</span><br><span class="line">     <span class="keyword">if</span> (map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i=Math.max(i,map.get(s.charAt(j)+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,j-i+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j),j);<span class="comment">//</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/06/a-RPC-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/a-RPC-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">RPC-概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-06 11:03:03" itemprop="dateCreated datePublished" datetime="2021-07-06T11:03:03+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:58" itemprop="dateModified" datetime="2023-07-11T23:32:58+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>42k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>38 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>面试官下午好，我叫谢谊，今年23岁，来自湖北恩施，本科和硕士都就读于华中科技大学。<br>在本科的时候，我做了一个基于matlab机器视觉文字分割的课程设计，对于编程有了初步的了解。<br>在研究生期间，我自学了计算机专业的相关课程，比如计算机网络，操作系统，数据结构，也学习了有关java后端有关的知识，比如，java基础，java虚拟机，数据库，等等<br>然后自己做了个仿写rpc框架的小项目，实现了调用远程服务器上的方法的功能。<br>希望可以在未来从事后端开发的工作，谢谢</p>
<p>client 调用远程方法-&gt; request序列化 -&gt; 协议编码 -&gt; 网络传输-&gt; 服务端 -&gt; 反序列化request -&gt; 调用本地方法得到response -&gt; 序列化 -&gt;编码-&gt;…..</p>
<h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call）即<strong>远程过程调用</strong>。</p>
<p>为什么要 RPC  ？因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，<strong>需要通过网络编程才能传递方法调用所需要的参数</strong>。并且，<strong>方法调用的结果也需要通过网络编程来接收</strong>。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。</p>
<p>RPC 能帮助我们做什么呢？ 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。</p>
<p>RPC 的出现就是为了让你<strong>调用远程方法像调用本地方法一样简单。</strong></p>
<h3 id="RPC-VS-HTTP"><a href="#RPC-VS-HTTP" class="headerlink" title="RPC VS HTTP"></a>RPC VS HTTP</h3><p>无论是微服务还是分布式服务（都是SOA，都是面向服务编程），都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p>
<p>常见的远程调用方式有以下几种：</p>
<p><strong>RPC</strong>：Remote Produce Call远程过程调用。<strong>自定义数据格式，基于原生TCP通信，速度快，效率高</strong>。早期的webservice，现在热门的dubbo，都是RPC的典型</p>
<p><strong>Http</strong>：http其实是一种网络传输协议，基于TCP，<strong>规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。</strong></p>
<p>现在热门的Rest风格，就可以通过http协议来实现。</p>
<p>相同点：<strong>底层通讯都是基于网络编程</strong>，都可以实现远程调用，都可以实现服务调用服务。</p>
<p>不同点：<br>当使用RPC框架实现服务间调用的时候，要求服务提供方和服务消费方 都必须使用统一的RPC框架，跨操作系统在同一编程语言内使用<br><strong>优势：调用快、处理快</strong></p>
<p>http：<br><strong>当使用http进行服务间调用的时候，无需关注服务提供方使用的编程语言，也无需关注服务消费方使用的编程语言，服务提供方只需要提供restful风格的接口，服务消费方，按照restful的原则，请求服务，即可跨系统跨编程语言的远程调用框架</strong></p>
<p><strong>优势：通用性强</strong></p>
<h4 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h4><p>在 REST 样式的 Web 服务中，<strong>每个资源都有一个地址</strong>。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEAD 和 OPTIONS。</p>
<p>在 RPC 样式的架构中，<strong>关注点在于方法</strong>，而在 REST 样式的架构中，关注点在于资源 —— 将使用标准方法检索并操作信息片段（使用表示的形式）。资源表示形式在表示形式中使用超链接互联。</p>
<p>RESTful架构是对MVC架构改进后所形成的一种架构，<strong>通过使用事先定义好的接口与不同的服务联系起来</strong>。在RESTful架构中，<strong>浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作</strong>。因此，<strong>RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。</strong></p>
<p>RESTful架构将服务器分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。<br>项目开发引入RESTful架构，利于团队并行开发。在RESTful架构中，将多数HTTP请求转移到前端服务器上，降低服务器的负荷，使视图获取后端模型失败也能呈现。但RESTful架构却不适用于所有的项目，当项目比较小时无需使用RESTful架构，项目变得更加复杂。</p>
<p>（1）每一个URI代表一种资源；<br>（2）客户端和服务器之间，传递这种资源的某种表现层；<br>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<p><img src="https://i.loli.net/2021/08/08/rG74PqAnCzLyYQ6.png" alt="image-20210808143751929"></p>
<h4 id="RPC-中网络传输协议"><a href="#RPC-中网络传输协议" class="headerlink" title="RPC 中网络传输协议"></a>RPC 中网络传输协议</h4><p>基于 TCP 协议的 RPC 调用</p>
<p>由服务的调用方与服务的提供方建立 Socket 连接，并由服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法。</p>
<p>将结果返回给服务的调用方，整个基于 TCP 协议的 RPC 调用大致如此。</p>
<p>但是在实例应用中则会进行一系列的封装，如 RMI 便是在 TCP 协议上传递可序列化的 Java 对象。</p>
<p>基于 HTTP 协议的 RPC 调用</p>
<p>该方法更像是访问网页一样，只是它的返回结果更加单一简单。</p>
<p>其大致流程为：由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 GET、POST、PUT、DELETE 等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。</p>
<p>而调用的具体方法则是根据 URL 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 XML 数据或者 JSON 数据解析后的结果，返回 JOSN 或者 XML 的数据结果。</p>
<p>由于前有很多开源的 Web 服务器，如 Tomcat，所以其实现起来更加容易，就像做 Web 项目一样。</p>
<p>两种方式对比</p>
<p>基于 TCP 的协议实现的 RPC 调用，由于 TCP 协议处于协议栈的下层，<strong>能够更加灵活地对协议字段进行定制，</strong>减少网络开销，提高性能，实现更大的吞吐量和并发数。</p>
<p>但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。</p>
<p>基于 HTTP 协议实现的 RPC 则可以使用 JSON 和 XML 格式的请求或响应数据。</p>
<p>而 JSON 和 XML 作为通用的格式标准(使用 HTTP 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 Web 程序已经做好了序列化内容)，开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。</p>
<p>但是由于 HTTP 协议是上层协议，发送包含同等内容的信息，使用 HTTP 协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。</p>
<p>因此在同等网络下，通过 HTTP 协议传输相同内容，效率会比基于 TCP 协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距。</p>
<h5 id="简单对比-RPC-和-Restful-API"><a href="#简单对比-RPC-和-Restful-API" class="headerlink" title="简单对比 RPC 和 Restful API"></a><strong>简单对比 RPC 和 Restful API</strong></h5><p>RESTful API 架构</p>
<p>REST 的几个特点为：资源、统一接口、URI 和无状态。</p>
<p>①资源</p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，就是一个具体的实在。</p>
<p>②统一接口</p>
<p>RESTful 架构风格规定，数据的元操作，即 CRUD(Create，Read，Update 和 Delete，即数据的增删查改)操作，分别对应于 HTTP 方法：GET 用来获取资源，POST 用来新建资源(也可以用于更新资源)，PUT 用来更新资源，DELETE 用来删除资源，这样就统一了数据操作的接口，仅通过 HTTP 方法，就可以完成对数据的所有增删查改工作。</p>
<p>③URL</p>
<p>可以用一个 URI(统一资源定位符)指向资源，即每个 URI 都对应一个特定的资源。</p>
<p>要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或识别符。</p>
<p>④无状态</p>
<p>所谓无状态的，即所有的资源，都可以通过 URI 定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。有状态和无状态的区别，举个简单的例子说明一下。</p>
<p>如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的。</p>
<p>因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行。</p>
<p>如果输入一个 URI 即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态。</p>
<p>且这种情况下，员工工资是一个资源，由一个 URI 与之对应，可以通过 HTTP 中的 GET 方法得到资源，这是典型的 RESTful 风格。</p>
<h5 id="RPC-和-Restful-API-对比"><a href="#RPC-和-Restful-API-对比" class="headerlink" title="RPC 和 Restful API 对比"></a>RPC 和 Restful API 对比</h5><p>面对对象不同：</p>
<p>RPC 更侧重于动作。</p>
<p>REST 的主体是资源。</p>
<p>RESTful 是<strong>面向资源</strong>的设计架构，但在系统中有很多对象不能抽象成资源，比如登录，修改密码等而 RPC 可以通过动作去操作资源。所以在操作的全面性上 RPC 大于 RESTful。</p>
<p>传输效率：</p>
<p>RPC 效率更高。RPC，使用自定义的 TCP 协议，可以让请求报文体积更小，或者使用 HTTP2 协议，也可以很好的减少报文的体积，提高传输效率。</p>
<p>复杂度：</p>
<p>RPC 实现复杂，流程繁琐。</p>
<p>REST 调用及测试都很方便。</p>
<p>RPC 实现需要实现编码，序列化，网络传输等。而 RESTful 不要关注这些，RESTful 实现更简单。</p>
<p>灵活性：</p>
<p>HTTP 相对更规范，更标准，更通用，无论哪种语言都支持 HTTP 协议。</p>
<p>RPC 可以实现跨语言调用，但整体灵活性不如 RESTful。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>RPC 主要用于公司内部的服务调用，性能消耗低，传输效率高，实现复杂。</p>
<p>HTTP 主要用于对外的异构环境，浏览器接口调用，App 接口调用，第三方接口调用等。</p>
<p>RPC 使用场景(大型的网站，内部子系统较多、接口非常多的情况下适合使用 RPC)：</p>
<p>长链接。不必每次通信都要像 HTTP 一样去 3 次握手，减少了网络开销。</p>
<p>注册发布机制。RPC 框架一般都有注册中心，有丰富的监控管理;发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p>
<p>安全性，没有暴露资源操作。</p>
<p>微服务支持。就是最近流行的服务化架构、服务化治理，RPC 框架是一个强力的支撑。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://i.loli.net/2021/08/06/KWeIP5wtzvQ8SVU.png" alt="image-20210806114259901"></p>
<p>client 调用远程方法-&gt; request序列化 -&gt; 协议编码 -&gt; 网络传输-&gt; 服务端 -&gt; 解码-&gt;反序列化request -&gt; 调用本地方法得到response -&gt; 序列化 -&gt;编码-&gt;…..</p>
<h3 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h3><h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p>是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：</p>
<p>面向接口的远程方法调用<br>智能容错和负载均衡<br>服务自动注册和发现。</p>
<p>简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。</p>
<p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>
<h4 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a>Motan</h4><p>motan 是2016 年新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。</p>
<p>很多人喜欢拿 motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：motan 更像是一个精简版的 dubbo，可能是借鉴了 Dubbo 的思想，motan 的设计更加精简，功能更加纯粹。</p>
<p>不过，我不推荐你在实际项目中使用 motan。如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</p>
<h4 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h4><p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP&#x2F;2 协议标准而设计，基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p>
<p>通过 ProtoBuf 定义接口和数据类型还挺繁琐的，虽然 gRPC 确实很多亮点的地方，但是我还是选择 Dubbo。</p>
<h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p>
<p>Thrift支持多种不同的编程语言，包括C++、Java、Python、PHP、Ruby等（相比于 gRPC 支持的语言更多 ）。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>gRPC 和 Thrift</strong> 虽然支持跨语言的 RPC 调用，但是因为它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p>
<p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。最重要的是其在国内有很多成功的案例比如当当网、滴滴等等。下图展示了 Dubbo 的生态系统。</p>
<p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨语言调用的话，可以考虑一下 Thrift 和 gRPC。</p>
<h3 id="自己实现RPC框架的思路"><a href="#自己实现RPC框架的思路" class="headerlink" title="自己实现RPC框架的思路"></a>自己实现RPC框架的思路</h3><p><img src="https://i.loli.net/2021/08/06/aG7gWErNb9iymIU.png" alt="image-20210806144123153"></p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a><strong>注册中心</strong></h4><h5 id="zookeeper作为注册中心的问题？"><a href="#zookeeper作为注册中心的问题？" class="headerlink" title="zookeeper作为注册中心的问题？"></a>zookeeper作为注册中心的问题？</h5><p>在实践中，注册中心不能因为自身的任何原因<strong>破坏服务之间本身的可连通性</strong><br>注册中心需要的是 AP，而 Zookeeper 是 CP</p>
<p>CAP ：一致性、可用性、分区容忍性<br>一致性：是指在同一时刻，分布式系统中的所有数据备份为相同值<br>可用性：指集群中的某一个节点故障宕机后，集群还能响应客户端请求。<br>分区容忍性：当分布式系统中因为一些原因导致无法通信而分成多个分区，系统还能正常对外服务。</p>
<p>在 CAP 模型中，<strong>zookeeper 是 CP，意味着面对网络分区时，为了保持一致性，他是不可用的。</strong></p>
<p>因为 zookeeper 是一个<strong>分布式协调系统</strong>，如果使用最终一致性（AP）的话，将是一个糟糕的设计，他的核心算法是 <strong>ZAb，所有设计都是为了一致性。</strong></p>
<p>对于协调系统，这是非常正确的，<strong>但是对于服务发现，可用性是第一位的，例如发生了短暂的网络分区时，即使拿到的信息是有瑕疵的、旧的，也好过完全不可用。</strong></p>
<p>注册中心本质上的功能就是一个<strong>查询函数：</strong></p>
<p>ServiceList &#x3D; F(service-name)<br>以 service-name 为查询参数，得到对应的可用的服务端点列表 endpoints(ip:port)。</p>
<p>1，我们假设<strong>不同的客户端得到的服务列表数据是不一致的，看看有什么后果。</strong></p>
<p>现在有 2 个服务调用者 service1 和 service2，从注册中心获取 serviceB 的服务列表，但取得的数据不一致。</p>
<p>s1 &#x3D; { ip1,ip2 … ip9 }<br>s2 &#x3D; { ip2,ip3 … ip10 }<br>这个不一致带来的影响是什么？</p>
<p><strong>就是 serviceB 各个实例的流量不均衡。</strong></p>
<p>这个不均衡有什么严重影响吗？并没有，完全可以接受，而且，又不会一直这样。</p>
<p>所以，注册中心使用最终一致性模型（AP）完全可以的。</p>
<p><strong>2，现在我们看一下 CP 带来的不可用的影响。</strong></p>
<p>3个机房部署 5 个 ZK 节点。</p>
<p>现在机房3出现网络分区了，形成了孤岛。</p>
<p>发生网络分区时，各个区都会开始选举 leader，那么节点数少的那个分区将会停止运行，也就是 ZK5 不可用了。</p>
<p>这时，serviceA 就访问不了机房1和机房2的 serviceB 了，而且连自己所在机房的 serviceB 也访问不了了。</p>
<p>不能访问其他机房还可以理解，不能访问自己机房的服务就理解不了了，本机房内部的网络好好的，不能因为你注册中心有问题就不能访问了吧。</p>
<p><strong>因为注册中心为了保障数据一致性而放弃了可用性，导致同机房服务之间无法调用，这个是接受不了的。</strong></p>
<p><strong>所以，注册中心的可用性比数据强一致性更加重要，所以注册中心应该是偏向 AP，而不是 CP。</strong></p>
<p><strong>zookeeper 的性能不适合注册中心</strong></p>
<p>在大规模服务集群场景中，zookeeper 的性能也是瓶颈。</p>
<p>zookeeper 所有的写操作都是 leader 处理的，在大规模服务注册写请求时，压力巨大，而且 leader 是单点，无法水平扩展。</p>
<p>还有所有服务于 zookeeper 的长连接也是很重的负担。</p>
<p>zookeeper 对每一个写请求，都会写一个事务日志，同时会定期将内存数据镜像dump到磁盘，保持数据一致性和持久性。这个动作会降低性能，而且对于注册中心来讲，是不需要的。</p>
<p><strong>小结</strong></p>
<p>从 CP 模型上来讲，zookeeper 并不适合注册中心高可用的需要。</p>
<p>从性能上来讲，zookeeper 也无法满足注册中心大规模且频繁注册写的场景。</p>
<p><strong>zookeeper 的特长是做分布式协调服务，</strong>例如 kafka、hbase、flink、hadoop 等大项目都在用 zookeeper。</p>
<h5 id="redis注册中心"><a href="#redis注册中心" class="headerlink" title="redis注册中心"></a>redis注册中心</h5><p>redis 作为dubbo的注册中心，实现的功能跟 zk相同，但是内部的实现机制大相径庭，因为zk 有临时节点，服务端在zk 中创建临时节点会一直保持连接，如果服务器出现崩溃，自动断连，而redis 则要靠主服务器 进行定时轮询</p>
<h5 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ZkServiceDiscoveryImpl implements ServiceDiscovery &#123;</span><br><span class="line">    private final LoadBalance loadBalance;//负载均衡</span><br><span class="line"></span><br><span class="line">    public ZkServiceDiscoveryImpl() &#123;</span><br><span class="line">        this.loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(&quot;loadBalance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public InetSocketAddress lookupService(RpcRequest rpcRequest) &#123;</span><br><span class="line">    	//服务名</span><br><span class="line">        String rpcServiceName = rpcRequest.getRpcServiceName();</span><br><span class="line">        CuratorFramework zkClient = CuratorUtils.getZkClient();</span><br><span class="line">        //找子节点</span><br><span class="line">        List&lt;String&gt; serviceUrlList = CuratorUtils.getChildrenNodes(zkClient, rpcServiceName);</span><br><span class="line">        //找不到，就抛出not found</span><br><span class="line">        if (serviceUrlList == null || serviceUrlList.size() == 0) &#123;</span><br><span class="line">            throw new RpcException(RpcErrorMessageEnum.SERVICE_CAN_NOT_BE_FOUND, rpcServiceName);</span><br><span class="line">        &#125;</span><br><span class="line">        // load balancing</span><br><span class="line">        String targetServiceUrl = loadBalance.selectServiceAddress(serviceUrlList, rpcRequest);</span><br><span class="line">        </span><br><span class="line">        String[] socketAddressArray = targetServiceUrl.split(&quot;:&quot;);</span><br><span class="line">        String host = socketAddressArray[0];</span><br><span class="line">        int port = Integer.parseInt(socketAddressArray[1]);</span><br><span class="line">        return new InetSocketAddress(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ZkServiceRegistryImpl implements ServiceRegistry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerService(String rpcServiceName, InetSocketAddress inetSocketAddress) &#123;</span><br><span class="line">        String servicePath = CuratorUtils.ZK_REGISTER_ROOT_PATH + &quot;/&quot; + rpcServiceName + inetSocketAddress.toString();</span><br><span class="line">        CuratorFramework zkClient = CuratorUtils.getZkClient();</span><br><span class="line">        //创建一个持久节点</span><br><span class="line">        CuratorUtils.createPersistentNode(zkClient, servicePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>推荐使用 Zookeeper 作为注册中心。当然了，你也可以使用 Nacos ，甚至是 Redis。</p>
<p>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且<strong>，ZooKeeper 将数据保存在内存中，性能是非常棒的</strong>。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</p>
<p>当然了，如果你想通过文件来存储服务地址的话也是没问题的，不过性能会比较差。</p>
<p>注册中心负责<strong>服务地址的注册与查找，相当于目录服务</strong>。 <strong>服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心</strong>，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p><strong>查看常用命令(help 命令)</strong></p>
<p>通过 help 命令查看 ZooKeeper 常用命令</p>
<p><strong>创建节点(create 命令)</strong></p>
<p>通过 create 命令在根目录创建了 node1 节点，与它关联的字符串是”node1”</p>
<p>create &#x2F;node1 “node1”</p>
<p><strong>更新节点数据内容(set 命令)</strong></p>
<p> set &#x2F;node1 “set node1”</p>
<p><strong>获取节点的数据(get 命令)</strong></p>
<p>get 命令可以获取指定节点的数据内容和节点的状态</p>
<p><strong>查看某个目录下的子节点(ls 命令)</strong></p>
<p>通过 ls 命令查看根目录下的节点</p>
<p>ls &#x2F;</p>
<p>通过 ls 命令查看 node1 目录下的节点</p>
<p>ls &#x2F;node1</p>
<p><strong>查看节点状态(stat 命令)</strong></p>
<p>通过 stat 命令查看节点状态</p>
<p>stat &#x2F;node1<br>比如 cversion、aclVersion、numChildren 等等</p>
<p><strong>查看节点信息和状态(ls2 命令)</strong></p>
<p>ls2 命令更像是  ls 命令和 stat 命令的结合。 ls2 命令返回的信息包括 2 部分：</p>
<p>子节点列表<br>当前节点的 stat 信息。</p>
<p><strong>删除节点(delete 命令)</strong></p>
<p>这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么这个节点必须无子节点才行。</p>
<h5 id="连接zookeeper"><a href="#连接zookeeper" class="headerlink" title="连接zookeeper"></a>连接zookeeper</h5><p>通过 CuratorFrameworkFactory 创建 CuratorFramework 对象，然后再调用  CuratorFramework 对象的 start() 方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework zkClient = CuratorFrameworkFactory.builder()</span><br><span class="line">    // the server to connect to (can be a server list)</span><br><span class="line">    .connectString(&quot;127.0.0.1:2181&quot;)</span><br><span class="line">    .retryPolicy(retryPolicy)</span><br><span class="line">    .build();</span><br><span class="line">zkClient.start();</span><br></pre></td></tr></table></figure>

<p>baseSleepTimeMs：重试之间等待的初始时间<br>maxRetries ：最大重试次数<br>connectString ：要连接的服务器列表<br>retryPolicy ：重试策略</p>
<h5 id="zookeeper常见概念"><a href="#zookeeper常见概念" class="headerlink" title="zookeeper常见概念"></a>zookeeper常见概念</h5><h6 id="ZooKeeper-典型应用场景"><a href="#ZooKeeper-典型应用场景" class="headerlink" title="ZooKeeper 典型应用场景"></a><strong>ZooKeeper 典型应用场景</strong></h6><p>分布式锁 ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。<br>命名服务 ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID<br>数据发布&#x2F;订阅 ：通过 Watcher 机制 可以很方便地实现数据发布&#x2F;订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</p>
<h6 id="Data-model（数据模型）"><a href="#Data-model（数据模型）" class="headerlink" title="Data model（数据模型）"></a>Data model（数据模型）</h6><p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“&#x2F;”来代表。每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p>
<p>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。</p>
<p><img src="https://i.loli.net/2021/08/06/U4PZ357vfcK2QDT.png" alt="image-20210806184839468"></p>
<h6 id="znode-4-种类型"><a href="#znode-4-种类型" class="headerlink" title="znode 4 种类型"></a>znode 4 种类型</h6><p><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。<br><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。<br><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 &#x2F;node1&#x2F;app0000000001 、&#x2F;node1&#x2F;app0000000002 。<br><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</p>
<p>每个 znode 由 2 部分组成:</p>
<p>stat ：状态信息<br>data ： 节点存放的数据的具体内容</p>
<p><img src="https://i.loli.net/2021/08/06/CAHXpy2Qitw8M1h.png" alt="image-20210806184946339"></p>
<h6 id="ACL（权限控制）"><a href="#ACL（权限控制）" class="headerlink" title="ACL（权限控制）"></a>ACL（权限控制）</h6><p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</p>
<p>对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：</p>
<p>CREATE : 能创建子节点<br>READ ：能获取节点数据和列出其子节点<br>WRITE : 能设置&#x2F;更新节点数据<br>DELETE : 能删除子节点<br>ADMIN : 能设置节点 ACL 的权限</p>
<h6 id="Watcher（事件监听器）"><a href="#Watcher（事件监听器）" class="headerlink" title="Watcher（事件监听器）"></a>Watcher（事件监听器）</h6><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在<strong>指定节点上注册一些 Watcher</strong>，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<p><img src="https://i.loli.net/2021/08/06/cYBTq4IkzRsagZF.png" alt="image-20210806185101550"></p>
<h6 id="ZooKeeper-集群"><a href="#ZooKeeper-集群" class="headerlink" title="ZooKeeper 集群"></a>ZooKeeper 集群</h6><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。</p>
<p>集群间通过 <strong>ZAB 协议（ZooKeeper Atomic Broadcast）</strong>来保持数据的一致性。</p>
<p>ZooKeeper 中没有选择传统的 Master&#x2F;Slave 概念，而是引入了 <strong>Leader、Follower 和 Observer</strong> 三种角色。</p>
<p><img src="https://i.loli.net/2021/08/06/xSmqUpYf78lrvHk.png" alt="image-20210806185249694"></p>
<p>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程 来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，<strong>Follower 和 Observer 都只能提供读服务</strong>。Follower 和 Observer 唯一的区别在于 <strong>Observer 机器不参与 Leader 的选举过程</strong>，<strong>也不参与写操作的“过半写成功”策略，</strong>因此 <strong>Observer 机器可以在不影响写性能的情况下提升集群的读性能。</strong></p>
<p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p>
<p><strong>Leader election（选举阶段）</strong>：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。<br><strong>Discovery（发现阶段）</strong> ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。<br><strong>Synchronization（同步阶段）</strong> :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。<br><strong>Broadcast（广播阶段）</strong> :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</p>
<h6 id="ZooKeeper-集群为啥最好奇数台？"><a href="#ZooKeeper-集群为啥最好奇数台？" class="headerlink" title="ZooKeeper 集群为啥最好奇数台？"></a>ZooKeeper 集群为啥最好奇数台？</h6><p>ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。假如我们的集群中有 n 台 ZooKeeper 服务器，那么也就是剩下的服务数必须大于 n&#x2F;2。先说一下结论，2n 和 2n-1 的容忍度是一样的，都是 n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。</p>
<p>比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。 假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。</p>
<h6 id="何为集群脑裂？"><a href="#何为集群脑裂？" class="headerlink" title="何为集群脑裂？"></a>何为集群脑裂？</h6><p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。</p>
<p>举例说明：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。仿佛是 1 个大脑（leader）分散成了 2 个大脑，这就发生了脑裂现象。脑裂期间 2 个大脑都可能对外提供了服务，这将会带来数据一致性等问题。</p>
<h6 id="ZAB-协议介绍"><a href="#ZAB-协议介绍" class="headerlink" title="ZAB 协议介绍"></a>ZAB 协议介绍</h6><p>ZAB（<strong>ZooKeeper Atomic Broadcast 原子广播</strong>） 协议是为分布式协调服务 ZooKeeper 专门设计的一种<strong>支持崩溃恢复的原子广播协议</strong>。 在 ZooKeeper 中，主要依赖 <strong>ZAB 协议来实现分布式数据一致性</strong>，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<p>ZAB 协议包括<strong>两种基本的模式</strong>，分别是</p>
<p><strong>崩溃恢复 ：</strong>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中<strong>已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。</strong>其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。</p>
<p><strong>消息广播 ：</strong>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入<strong>消息广播模式</strong>了。 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>
<h5 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h5><p>分布式系统的最大难点，就是各个节点的状态如何保持一致。CAP理论是在设计分布式系统的过程中，处理数据一致性问题时必须考虑的理论。</p>
<p>CAP即：</p>
<p>Consistency（一致性）<br>Availability（可用性）<br>Partition tolerance（分区容忍性）</p>
<p>①一致性：对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是<strong>数据正确</strong>。</p>
<p>②可用性：任何客户端的请求都<strong>能得到响应数据，不会出现响应错误</strong>。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。</p>
<p>③分区容忍性：由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：<strong>我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。</strong></p>
<p>假设N1和N2之间通信的时候网络突然出现故障，有用户向N1发送数据更新请求，那N1中的数据DB0将被更新为DB1，由于网络是断开的，N2中的数据库仍旧是DB0；</p>
<p>如果这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据DB1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据DB0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作完成之后，再给用户响应最新的数据DB1。</p>
<h5 id="raft协议"><a href="#raft协议" class="headerlink" title="raft协议"></a>raft协议</h5><p>有三个节点：a，b，c。客户端对这个由3个节点组成的数据库集群进行操作时的值一致性如何保证，就是分布式一致性问题。Raft就是一种实现了<strong>分布式一致性的协议</strong>（还有其他一些一致性算法，例如：ZAB、PAXOS等）</p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>为了<strong>保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行</strong>，在传统单体应用单机部署的情况下，可以使用并发处理相关的功能进行互斥控制。但是，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的应用并不能提供分布式锁的能力。为了解决这个问题就需要一种跨机器的互斥机制来控制共享资源的访问。</p>
<h6 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h6><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p>
<p><strong>问题：</strong></p>
<p>1、这把锁强<strong>依赖数据库的可用性</strong>，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p>
<p>2、这把<strong>锁没有失效时间，一旦解锁操作失败</strong>，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p>
<p>3、这把锁<strong>只能是非阻塞的</strong>，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</p>
<p>4、这把锁是<strong>非重入的</strong>，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p>
<p>解决：</p>
<p>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。<br>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>非阻塞的？搞一个while循环，直到insert成功再返回成功。<br>非重入的？在数据库表中加个字段，<strong>记录当前获得锁的机器的主机信息和线程信息</strong>，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p>
<p><strong>基于数据库排它锁</strong></p>
<p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，<strong>只有通过索引进行检索的时候才会使用行级锁</strong>，否则会使用表级锁。这里我们希望使用行级锁，就要给<strong>method_name添加索引</strong>，值得注意的是，这个索引一定要创建成<strong>唯一索引</strong>，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。）。</p>
<p>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p>
<p>我们可以认为<strong>获得排它锁的线程即可获得分布式锁</strong>，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过**connection.commit()**操作来释放锁。</p>
<p>这种方法可以有效的解决上面提到的<strong>无法释放锁和阻塞锁</strong>的问题。</p>
<p>阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。<br>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</p>
<p><strong>问题？</strong></p>
<p>MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。</p>
<p>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p>
<h6 id="基于redis"><a href="#基于redis" class="headerlink" title="基于redis"></a>基于redis</h6><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。</p>
<p>（1）SETNX<br>SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。<br>（2）expire<br>expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。<br>（3）delete<br>delete key：删除key</p>
<p>实现思想：<br>（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的<strong>value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</strong><br>（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。<br>（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，<strong>则执行delete进行锁释放。</strong></p>
<p>设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。</p>
<h6 id="基于zookeeper"><a href="#基于zookeeper" class="headerlink" title="基于zookeeper"></a>基于zookeeper</h6><p>基于zookeeper临时有序节点可以实现的分布式锁。</p>
<p>大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
<p><strong>锁无法释放？</strong>使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，<strong>一旦客户端获取到锁之后突然挂掉（Session连接断开）</strong>，<strong>那么这个临时节点就会自动删除掉。</strong>其他客户端就可以再次获得锁。</p>
<p><strong>非阻塞锁？</strong>使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，<strong>并且在节点上绑定监听器，一旦节点有变化</strong>，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p>
<p><strong>不可重入？</strong>使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p>
<p><strong>单点问题？</strong>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p>
<p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端和ZK集群的session连接断了，那么ZK以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。</p>
<p>这个问题不常见是因为zk有重试机制，<strong>一旦zk集群检测不到客户端的心跳，就会重试</strong>，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。</p>
<p><strong>从性能角度（从高到低）</strong><br><strong>缓存 &gt; Zookeeper &gt;&#x3D; 数据库</strong></p>
<p><strong>从可靠性角度（从高到低）</strong><br><strong>Zookeeper &gt; 缓存 &gt; 数据库</strong></p>
<h4 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h4><h5 id="网络传输实体类"><a href="#网络传输实体类" class="headerlink" title="网络传输实体类"></a>网络传输实体类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class RpcRequest implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1905122041950251207L;//序列化版本控制</span><br><span class="line">    private String requestId;</span><br><span class="line">    private String interfaceName;</span><br><span class="line">    private String methodName;</span><br><span class="line">    private Object[] parameters;</span><br><span class="line">    private Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    private String version;</span><br><span class="line">    private String group;//处理一个接口有多个实现类的情况</span><br><span class="line">    //服务名称：接口名加对应的实现方法。</span><br><span class="line">    public String getRpcServiceName() &#123;</span><br><span class="line">        return this.getInterfaceName() + this.getGroup() + this.getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class RpcResponse&lt;T&gt; implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 715745410605631233L;</span><br><span class="line">    private String requestId;//唯一标识每一个请求</span><br><span class="line">    private Integer code;//返回数字</span><br><span class="line">    private String message;//返回的string</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RpcResponse&lt;T&gt; success(T data, String requestId) &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = new RpcResponse&lt;&gt;();</span><br><span class="line">        response.setCode(RpcResponseCodeEnum.SUCCESS.getCode());</span><br><span class="line">        response.setMessage(RpcResponseCodeEnum.SUCCESS.getMessage());</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        if (null != data) &#123;</span><br><span class="line">            response.setData(data);</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RpcResponse&lt;T&gt; fail(RpcResponseCodeEnum rpcResponseCodeEnum) &#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = new RpcResponse&lt;&gt;();</span><br><span class="line">        response.setCode(rpcResponseCodeEnum.getCode());</span><br><span class="line">        response.setMessage(rpcResponseCodeEnum.getMessage());</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="netty网络客户传输"><a href="#netty网络客户传输" class="headerlink" title="netty网络客户传输"></a>netty网络客户传输</h5><p><strong>NettyClient.java</strong></p>
<p>doConnect() :用于连接服务端（目标方法所在的服务器）并返回对应的 Channel。当我们知道了服务端的地址之后，我们就可以通过 NettyClient 成功连接服务端了。（有了 Channel 之后就能发送数据到服务端了）</p>
<p>sendRpcRequest() : 用于传输 rpc 请求(RpcRequest) 到服务端。</p>
<p><strong>UnprocessedRequests.java</strong></p>
<p>用于存放未被服务端处理的请求（建议限制 map 容器大小，避免未处理请求过多 OOM)。</p>
<p><strong>NettyClientHandler</strong></p>
<p>自定义客户端 ChannelHandler 用于处理服务器发送的数据。</p>
<p>从代码中，可以看出当 rpc 请求被成功处理（客户端收到服务端的执行结果）之后，我们调用了 <strong>unprocessedRequests.complete(rpcResponse) 方法</strong>，这样的话，你只需要通过下面的方式就能成功接收到客户端返回的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) clientTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">rpcResponse = completableFuture.get();</span><br></pre></td></tr></table></figure>

<p><strong>ChannelProvider.java</strong></p>
<p>用于存放 Channel（Channel用于在服务端和客户端之间传输数据）。</p>
<p><strong>NettyRpcServer.java</strong></p>
<p>Netty 服务端。并监听客户端的连接。</p>
<p><strong>NettyServerHandler.java</strong></p>
<p>自定义服务端 ChannelHandler 用于处理客户端发送的数据。</p>
<p>当客端发的 rpc 请求(RpcRequest) 来了之后，服务端就会处理 rpc 请求(RpcRequest) ，处理完之后就把得到 rpc 相应(RpcResponse)传输给客户端。</p>
<p>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</p>
<p>网络传输具体实现你可以使用 Socket （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。</p>
<p>你也可以使用同步非阻塞的 I&#x2F;O 模型 NIO ，但是用它来进行网络编程真的太麻烦了。不过没关系，你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择。</p>
<p>Netty 是一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。<br>它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。<br>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</p>
<h5 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h5><p><strong>服务器端：</strong></p>
<p>创建 <strong>ServerSocket 对象</strong>并且绑定地址（ip）和端口号(port)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.bind(new InetSocketAddress(host, port))</span><br></pre></td></tr></table></figure>

<p>通过 <strong>accept()方法监听</strong>客户端请求<br>连接建立后，通过输入流读取客户端发送的请求信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message message = (Message) objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p>通过输出流向客户端发送响应信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectOutputStream.writeObject(message);</span><br></pre></td></tr></table></figure>

<p>关闭相关资源</p>
<h6 id="管理多个客户端"><a href="#管理多个客户端" class="headerlink" title="管理多个客户端"></a>管理多个客户端</h6><p><img src="https://i.loli.net/2021/08/06/1bNwXIjGmecq7K9.png" alt="image-20210806153434387"></p>
<p> 比较简单并且实际的改进方法就是使用<strong>线程池</strong>。线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p>
<p><strong>客户端：</strong></p>
<p>创建Socket 对象并且连接指定的服务器的地址（ip）和端口号(port)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.connect(inetSocketAddress)</span><br></pre></td></tr></table></figure>

<p>连接建立后，通过输出流向服务器端发送请求信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectOutputStream.writeObject(message)</span><br></pre></td></tr></table></figure>

<p>通过输入流获取服务器响应的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p>关闭相关资源</p>
<h5 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h5><p>Netty 是一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</p>
<p>它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</p>
<p>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</p>
<p>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</p>
<p>这个应该是老铁们最关心的一个问题了，凭借自己的了解，简单说一下，理论上 NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做网络通信 :</p>
<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><p>作为 RPC 框架的网络通信工具 </p>
<p>实现一个自己的 HTTP 服务器 </p>
<p>实现一个即时通讯系统</p>
<p>消息推送系统<br>……</p>
<p>Dubbo、RocketMQ、Elasticsearch、gRPC 等等都用到了 Netty。</p>
<h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><p>客户端中主要有一个用于向服务端发送消息的 **sendMessage()**方法，通过这个方法你可以将消息也就是RpcRequest 对象发送到服务端，并且你可以同步获取到服务端返回的结果也就是RpcResponse 对象。 </p>
<p><strong>sendMessage()方法分析：</strong></p>
<p>首先初始化了一个 Bootstrap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">protected void initChannel(SocketChannel ch) &#123;</span><br><span class="line">/*</span><br><span class="line">自定义序列化编解码器</span><br><span class="line">*/</span><br><span class="line">// RpcResponse -&gt; ByteBuf</span><br><span class="line">ch.pipeline().addLast(new NettyKryoDecoder(kryoSerializer, RpcResponse.class));</span><br><span class="line">// ByteBuf -&gt; RpcRequest</span><br><span class="line">ch.pipeline().addLast(new NettyKryoEncoder(kryoSerializer, RpcRequest.class));</span><br><span class="line">ch.pipeline().addLast(new NettyClientHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过 Bootstrap 对象连接服务端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">Channel futureChannel = f.channel();</span><br></pre></td></tr></table></figure>

<p>通过 Channel 向服务端发送消息RpcRequest</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">futureChannel.writeAndFlush(rpcRequest)</span><br></pre></td></tr></table></figure>

<p>发送成功后，阻塞等待 ，直到Channel关闭</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">futureChannel.closeFuture().sync();</span><br></pre></td></tr></table></figure>

<p>拿到服务端返回的结果 RpcResponse</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NettyClientHandler</span><br><span class="line"></span><br><span class="line">// 声明一个 AttributeKey 对象</span><br><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(&quot;rpcResponse&quot;);</span><br><span class="line">// 将服务端的返回结果保存到 AttributeMap 上，AttributeMap 可以看作是一个Channel的共享数据源</span><br><span class="line">// AttributeMap的key是AttributeKey，value是Attribute</span><br><span class="line">ctx.channel().attr(key).set(rpcResponse);</span><br></pre></td></tr></table></figure>

<p>（<strong>NettyClientHandler</strong>用于读取服务端发送过来的 RpcResponse 消息对象，并将 RpcResponse 消息对象保存到 AttributeMap 上。</p>
<p>AttributeMap 可以看作是一个Channel的共享数据源。这样的话，我们就能通过 channel 和 key 将数据读取出来。</p>
<p>AttributeMap ,AttributeMap 是一个接口，但是类似于 Map 数据结构 。</p>
<p>Channel 实现了 <strong>AttributeMap 接口</strong>，这样也就表明它存在了AttributeMap 相关的属性。 <strong>每个 Channel上的AttributeMap属于共享数据</strong>。AttributeMap 的结构，和Map很像，我们可以把 key 看作是AttributeKey，value 看作是Attribute，我们可以根据 AttributeKey找到对应的Attribute。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(&quot;rpcResponse&quot;);</span><br><span class="line">return futureChannel.attr(key).get();</span><br></pre></td></tr></table></figure>



<h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    // TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                    // 是否开启 TCP 底层心跳机制</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                    //表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                    .handler(new LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel ch) &#123;</span><br><span class="line">     ch.pipeline().addLast(new NettyKryoDecoder(kryoSerializer, RpcRequest.class));</span><br><span class="line">     ch.pipeline().addLast(new NettyKryoEncoder(kryoSerializer, RpcResponse.class));</span><br><span class="line">     ch.pipeline().addLast(new NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            // 绑定端口，同步等待绑定成功</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            // 等待服务端监听端口关闭</span><br><span class="line">            f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>

<h6 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h6><p>NettyKryoEncoder 是我们自定义的编码器。它负责处理”出站”消息，将消息格式转换为字节数组然后写入到字节数据的容器 ByteBuf 对象中。</p>
<p>4B  magic code（魔法数）  </p>
<p>1B version（版本）   </p>
<p>4B full length（消息长度）   </p>
<p>1B messageType（消息类型）</p>
<p>1B compress（压缩类型） </p>
<p>1B codec（序列化类型）    </p>
<p>4B  requestId（请求的Id）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">protected void encode(ChannelHandlerContext ctx, RpcMessage rpcMessage, ByteBuf out) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            out.writeBytes(RpcConstants.MAGIC_NUMBER);//魔数4</span><br><span class="line">            out.writeByte(RpcConstants.VERSION);//版本1</span><br><span class="line">            out.writerIndex(out.writerIndex() + 4);//跳过4字节，留着写长度</span><br><span class="line">            byte messageType = rpcMessage.getMessageType();</span><br><span class="line">            out.writeByte(messageType);//消息类型1</span><br><span class="line">            out.writeByte(rpcMessage.getCodec());//序列化类型1</span><br><span class="line">            out.writeByte(CompressTypeEnum.GZIP.getCode());//压缩类型1</span><br><span class="line">            out.writeInt(ATOMIC_INTEGER.getAndIncrement());//请求ID4</span><br><span class="line">            </span><br><span class="line">            byte[] bodyBytes = null;</span><br><span class="line">            int fullLength = RpcConstants.HEAD_LENGTH;//头部长度</span><br><span class="line">            </span><br><span class="line">            if (messageType != RpcConstants.HEARTBEAT_REQUEST_TYPE</span><br><span class="line">                    &amp;&amp; messageType != RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">                // 序列化</span><br><span class="line">         String codecName = SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">         Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span><br><span class="line">                        .getExtension(codecName);</span><br><span class="line">          bodyBytes = serializer.serialize(rpcMessage.getData());//序列化</span><br><span class="line">                // 压缩</span><br><span class="line">        String compressName = CompressTypeEnum.getName(rpcMessage.getCompress());</span><br><span class="line">        Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span><br><span class="line">                        .getExtension(compressName);</span><br><span class="line">         bodyBytes = compress.compress(bodyBytes);//压缩后的长度</span><br><span class="line">          </span><br><span class="line">         fullLength += bodyBytes.length;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (bodyBytes != null) &#123;</span><br><span class="line">                out.writeBytes(bodyBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            int writeIndex = out.writerIndex();</span><br><span class="line">            //跳过魔术加版本</span><br><span class="line">            out.writerIndex(writeIndex - fullLength + RpcConstants.MAGIC_NUMBER.length + 1);</span><br><span class="line">            //写全长</span><br><span class="line">            out.writeInt(fullLength);</span><br><span class="line">            out.writerIndex(writeIndex);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;Encode request error!&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private Object decodeFrame(ByteBuf in) &#123;</span><br><span class="line">        // 有序的bytebuf</span><br><span class="line">        checkMagicNumber(in);//魔术</span><br><span class="line">        checkVersion(in);//版本</span><br><span class="line">        int fullLength = in.readInt();</span><br><span class="line">        // 构建返回对象</span><br><span class="line">        byte messageType = in.readByte();</span><br><span class="line">        byte codecType = in.readByte();</span><br><span class="line">        byte compressType = in.readByte();</span><br><span class="line">        int requestId = in.readInt();</span><br><span class="line">        RpcMessage rpcMessage = RpcMessage.builder()</span><br><span class="line">                .codec(codecType)</span><br><span class="line">                .requestId(requestId)</span><br><span class="line">                .messageType(messageType).build();</span><br><span class="line">        //心跳请求？</span><br><span class="line">        if (messageType == RpcConstants.HEARTBEAT_REQUEST_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PING);</span><br><span class="line">            return rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        //心跳返回？</span><br><span class="line">        if (messageType == RpcConstants.HEARTBEAT_RESPONSE_TYPE) &#123;</span><br><span class="line">            rpcMessage.setData(RpcConstants.PONG);</span><br><span class="line">            return rpcMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        //正文长度</span><br><span class="line">        int bodyLength = fullLength - RpcConstants.HEAD_LENGTH;</span><br><span class="line">        if (bodyLength &gt; 0) &#123;</span><br><span class="line">            byte[] bs = new byte[bodyLength];</span><br><span class="line">            in.readBytes(bs);</span><br><span class="line">            // 解压缩</span><br><span class="line">            String compressName = CompressTypeEnum.getName(compressType);</span><br><span class="line">            Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span><br><span class="line">                    .getExtension(compressName);</span><br><span class="line">            bs = compress.decompress(bs);</span><br><span class="line">            // 反序列化</span><br><span class="line">            String codecName = SerializationTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">            Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span><br><span class="line">                    .getExtension(codecName);</span><br><span class="line">            //rqcreauest？</span><br><span class="line">            if (messageType == RpcConstants.REQUEST_TYPE) &#123;</span><br><span class="line">                RpcRequest tmpValue = serializer.deserialize(bs, RpcRequest.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                RpcResponse tmpValue = serializer.deserialize(bs, RpcResponse.class);</span><br><span class="line">                rpcMessage.setData(tmpValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rpcMessage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>要在网络传输数据就要涉及到序列化。为什么需要序列化和反序列化呢？ </p>
<p>因为<strong>网络传输的数据必须是二进制</strong>的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其序列化为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次反序列化。</p>
<p>另外，<strong>不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。</strong></p>
<p>JDK 自带的序列化，只需实现 java.io.Serializable接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。</p>
<p>现在比较常用序列化的有 hessian、kyro、protostuff ….</p>
<h5 id="属于哪一层？"><a href="#属于哪一层？" class="headerlink" title="属于哪一层？"></a>属于哪一层？</h5><p><img src="https://i.loli.net/2021/08/06/G4DzcJvQf2Z9mku.png" alt="image-20210806150427787"></p>
<p>OSI七层协议模型中，<strong>表示层</strong>做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。</p>
<p>因为，OSI七层协议模型中的应用层、表示层和会话层对应的都是TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于TCP&#x2F;IP协议应用层的一部分。</p>
<h5 id="常见序列化协议对比"><a href="#常见序列化协议对比" class="headerlink" title="常见序列化协议对比"></a>常见序列化协议对比</h5><p>JDK自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 <strong>hessian、kyro、protostuff。</strong></p>
<p>下面提到的都是基于二进制的序列化协议，像 <strong>JSON 和 XML</strong>这种属于文本类序列化方式。虽然 JSON 和 XML可读性比较好，但是性能较差。</p>
<p><strong>JDK自带的序列化方式</strong></p>
<p>JDK 自带的序列化，只需实现 <strong>java.io.Serializable</strong>接口即可。</p>
<p>序列化号 serialVersionUID 属于<strong>版本控制</strong>的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会<strong>检查serialVersionUID是否和当前类的serialVersionUID一致</strong>。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的序列化号。</p>
<p><strong>kyro</strong></p>
<p>Kryo是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class KryoSerializer implements Serializer &#123;</span><br><span class="line">    //Lambda方式传入实现了 Supplier 函数接口的参数。</span><br><span class="line">    private final ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(new Supplier&lt;Kryo&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Kryo get() &#123;</span><br><span class="line">            //先注册</span><br><span class="line">            Kryo kryo = new Kryo();</span><br><span class="line">            kryo.register(RpcResponse.class);</span><br><span class="line">            kryo.register(RpcRequest.class);</span><br><span class="line">            return kryo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object obj) &#123;</span><br><span class="line">        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">             Output output = new Output(byteArrayOutputStream)) &#123;</span><br><span class="line">            Kryo kryo = kryoThreadLocal.get();</span><br><span class="line">            // Object-&gt;byte:将对象序列化为byte数组</span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return output.toBytes();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SerializeException(&quot;Serialization failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T deserialize(byte[] bytes, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);</span><br><span class="line">             Input input = new Input(byteArrayInputStream)) &#123;</span><br><span class="line">            Kryo kryo = kryoThreadLocal.get();</span><br><span class="line">            // byte-&gt;Object:从byte数组中反序列化出对对象</span><br><span class="line">            Object o = kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return clazz.cast(o);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SerializeException(&quot;Deserialization failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>hession</strong></p>
<p>hessian 是一个轻量级的,自定义描述的二进制RPC协议。hessian是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<p><strong>Protobuf</strong></p>
<p>Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是，另一方面导致protobuf没有序列化漏洞的风险。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。</p>
<p>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输。</p>
<p>当你调用远程方法的时候，<strong>实际会通过代理对象来传输网络请求</strong>，不然的话，怎么可能直接就调用到远程方法。</p>
<h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>在 Java 动态代理机制中 <strong>InvocationHandler 接口和 Proxy 类是核心。</strong></p>
<p>Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p>
<pre><code>public static Object newProxyInstance(ClassLoader loader,
                                      Class&lt;?&gt;[] interfaces,
                                      InvocationHandler h)
</code></pre>
<p>这个方法一共有 3 个参数：</p>
<p>loader :类加载器，用于加载代理对象。<br>interfaces : 被代理类实现的一些接口；<br>h : 实现了 InvocationHandler 接口的对象；</p>
<p>要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。</p>
<p>invoke() 方法有下面三个参数：</p>
<p>proxy :动态生成的代理类<br>method : <strong>与代理类对象调用的方法相对应</strong><br>args : <strong>当前 method 方法的参数</strong></p>
<p>也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，<strong>实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑</strong>，比如在方法执行前后做什么事情。</p>
<p><strong>步骤</strong>：</p>
<p>定义一个接口及其实现类；<br>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；<br>通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) &#123;</span><br><span class="line">      //生成RPCrequest</span><br><span class="line">       RpcRequest rpcRequest = RpcRequest.builder().methodName(method.getName())</span><br><span class="line">               .parameters(args)</span><br><span class="line">               .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">               .paramTypes(method.getParameterTypes())</span><br><span class="line">               .requestId(UUID.randomUUID().toString())</span><br><span class="line">               .group(rpcServiceConfig.getGroup())</span><br><span class="line">               .version(rpcServiceConfig.getVersion())</span><br><span class="line">               .build();</span><br><span class="line">       RpcResponse&lt;Object&gt; rpcResponse = null;</span><br><span class="line">       </span><br><span class="line">       if (rpcRequestTransport instanceof NettyRpcClient) &#123;</span><br><span class="line">           CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) </span><br><span class="line">           //发送rpcrequest</span><br><span class="line">           rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">           rpcResponse = completableFuture.get();</span><br><span class="line">       &#125;</span><br><span class="line">       if (rpcRequestTransport instanceof SocketRpcClient) &#123;</span><br><span class="line">           rpcResponse = (RpcResponse&lt;Object&gt;) </span><br><span class="line">           rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">       &#125;</span><br><span class="line">       this.check(rpcResponse, rpcRequest);</span><br><span class="line">       return rpcResponse.getData();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</p>
<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>
<p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p>
<p>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>
<p><strong>CGLIB 动态代理类使用步骤</strong></p>
<p>定义一个类；<br>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；<br>通过 Enhancer 类的 create()创建代理类；</p>
<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p><strong>JDK 动态代理和 CGLIB 动态代理对比</strong></p>
<p>JDK 动态代理只能<strong>只能代理实现了接口的类</strong>，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过<strong>生成一个被代理类的子类</strong>来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。<br>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p>
<p><strong>静态代理和动态代理的对比</strong></p>
<p>灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，<strong>静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改</strong>。</p>
<p>JVM 层面 ：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在<strong>运行时动态生成类字节码</strong>，并加载到 JVM 中的。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>RpcClientProxy.java</p>
<p>当我们去调用一个远程的方法的时候，实际上是通过代理对象调用的。</p>
<p>网络传输细节都被封装在了  <code>invoke()</code>  方法中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) &#123;</span><br><span class="line">      //构造rpcrequset</span><br><span class="line">       RpcRequest rpcRequest = RpcRequest.builder().methodName(method.getName())</span><br><span class="line">               .parameters(args)</span><br><span class="line">               .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">               .paramTypes(method.getParameterTypes())</span><br><span class="line">               .requestId(UUID.randomUUID().toString())</span><br><span class="line">               .group(rpcServiceProperties.getGroup())</span><br><span class="line">               .version(rpcServiceProperties.getVersion())</span><br><span class="line">               .build();</span><br><span class="line">       RpcResponse&lt;Object&gt; rpcResponse = null;</span><br><span class="line">       if (rpcRequestTransport instanceof NettyRpcClient) &#123;</span><br><span class="line">           CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">           rpcResponse = completableFuture.get();</span><br><span class="line">       &#125;</span><br><span class="line">       if (rpcRequestTransport instanceof SocketRpcClient) &#123;</span><br><span class="line">           rpcResponse = (RpcResponse&lt;Object&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);</span><br><span class="line">       &#125;</span><br><span class="line">       this.check(rpcResponse, rpcRequest);</span><br><span class="line">       return rpcResponse.getData();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>我们定义了两个接口 ServiceDiscovery.java 和 ServiceRegistry.java，这两个接口分别定义了服务发现和服务注册行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ZkServiceRegistryImpl implements ServiceRegistry &#123;</span><br><span class="line">@Override</span><br><span class="line">public void registerService(String rpcServiceName, InetSocketAddress inetSocketAddress) &#123;</span><br><span class="line"> String servicePath = CuratorUtils.ZK_REGISTER_ROOT_PATH + &quot;/&quot; + rpcServiceName + inetSocketAddress.toString();</span><br><span class="line">CuratorFramework zkClient = CuratorUtils.getZkClient();</span><br><span class="line">CuratorUtils.createPersistentNode(zkClient, servicePath);//创建一个用永久节点</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当我们的服务被注册进 zookeeper 的时候，我们将完整的服务名称 <strong>rpcServiceName</strong> （class name+group+version）作为根节点 ，子节点是对应的服务地址（ip+端口号）。</p>
<p>class name : <strong>服务接口名</strong>也就是类名比如：github.javaguide.HelloService。<br>version :（服务版本）主要是为后续不兼容升级提供可能<br>group :主要用于处理一个接口有多个类实现的情况。</p>
<p>一个根节点（rpcServiceName）<strong>可能会对应多个服务地址</strong>（相同服务被部署多份的情况）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ZkServiceDiscoveryImpl implements ServiceDiscovery &#123;</span><br><span class="line">    private final LoadBalance loadBalance;</span><br><span class="line"></span><br><span class="line">public ZkServiceDiscoveryImpl() &#123;</span><br><span class="line">this.loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(&quot;loadBalance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public InetSocketAddress lookupService(RpcRequest rpcRequest) &#123;</span><br><span class="line">        String rpcServiceName = rpcRequest.getRpcServiceName();</span><br><span class="line">        CuratorFramework zkClient = CuratorUtils.getZkClient();</span><br><span class="line">        List&lt;String&gt; serviceUrlList = CuratorUtils.getChildrenNodes(zkClient, rpcServiceName);</span><br><span class="line">        if (serviceUrlList == null || serviceUrlList.size() == 0) &#123;</span><br><span class="line">            throw new RpcException(RpcErrorMessageEnum.SERVICE_CAN_NOT_BE_FOUND, rpcServiceName);</span><br><span class="line">        &#125;</span><br><span class="line">        // load balancing</span><br><span class="line">        String targetServiceUrl = loadBalance.selectServiceAddress(serviceUrlList, rpcRequest);</span><br><span class="line">        </span><br><span class="line">        String[] socketAddressArray = targetServiceUrl.split(&quot;:&quot;);</span><br><span class="line">        String host = socketAddressArray[0];</span><br><span class="line">        int port = Integer.parseInt(socketAddressArray[1]);</span><br><span class="line">        return new InetSocketAddress(host, port);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface LoadBalance &#123;</span><br><span class="line">    String selectServiceAddress(List&lt;String&gt; serviceAddresses, RpcRequest rpcRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h5><h5 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h5><h5 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h5><p>简单的路由算法可以使用余数哈希算法：<code>HashCode = key % number of server</code>。由于HashCode具有随机性，因此使用余数哈希路由算法可保证缓存数据在整个Memcached服务器集群中比较均衡地分布。</p>
<p>假设由于业务发展，网站需要将3台缓存服务器扩容至4台。更改服务器列表，仍旧使用余数Hash，很容易就可以计算出，3台服务器扩容至4台服务器，大约有75％（3&#x2F;4）被缓存了的数据不能正确命中，随着服务器集群规模的增大，这个比例线性上升。当100台服务器的集群中加入一台新服务器，不能命中的概率是99％(N&#x2F;(N＋1))。</p>
<blockquote>
<p>假设扩容前有N台服务器，扩容一台服务器<br>也就是说每(N+1)*N个数里面有N个key经过余数Hash映射后是一样的，所以命中率为1&#x2F;(N+1)，所以未命中率为(N&#x2F;(N＋1))</p>
</blockquote>
<p>当大部分被缓存了的数据因为服务器扩容而不能正确读取时，这些数据访问的压力就落到了数据库的身上，这将大大超过数据库的负载能力，严重的可能会导致数据库宕机。</p>
<p>一致性Hash算法通过一个叫作一致性Hash环的数据结构实现key到缓存服务器的Hash映射。</p>
<p>具体算法过程为：先构造一个长度为<code>0~2^32</code>的整数环（这个环被称作一致性Hash环），根据节点名称(通常是IP）的Hash值（其分布范围同样为<code>0~x^32</code>）将缓存服务器节点放置在这个Hash环上。然后根据需要缓存的数据的key值计算得到其Hash值（其分布范围也同样为<code>0~x^32</code>），然后在Hash环上顺时针查找距离这个key的Hash值最近的缓存服务器节点，完成key到服务器的Hash映射查找。</p>
<p>当缓存服务器集群需要扩容的时候，只需要将新加入的节点名称<code>(NODE3)</code>的Hash值放入一致性Hash环中，由于key是顺时针查找距离其最近的节点，因此新加入的节点只影响整个环中的一小段。</p>
<p>上图中，加入新节点<code>NODE3</code>后，原来的key大部分还能继续计算到原来的节点，只有<code>key3</code>、<code>key0</code>从原来的<code>NODE1</code>重新计算到<code>NODE3</code>。这样就能保证大部分被缓存的数据还可以继续命中。3台服务器扩容至4台服务器，可以继续命中原有缓存数据的概率是75％，远高于余数Hash的25％，而且随着集群规模越大，继续命中原有缓存数据的概率也逐渐增大，100台服务器扩容增加1台服务器，继续命中的概率是99％。虽然仍有小部分数据缓存在服务器中不能被读到，但是这个比例足够小，通过访问数据库获取也不会对数据库造成致命的负载压力。</p>
<h6 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h6><p>新加入的节点<code>NODE3</code>只影响了原来的节点<code>NODE1</code>，也就是说一部分一部分原来需要访问<code>NODE1</code>的缓存数据现在需要访问<code>NODE3</code>。但是原来的节点<code>NODE0</code>和<code>NODE2</code>不受影响，这就意味着<code>NODE0</code>和<code>NODE2</code>缓存数据量和负载压力是<code>NODE1</code>与<code>NODE3</code>的两倍。如果4台机器的性能是一样的，那么这种结果显然不是我们需要的。</p>
<p>怎么办？计算机领域有句话：计算机的任何问题都可以通过增加一个虚拟层来解决。计算机硬件、计算机网络、计算机软件都莫不如此。计算机网络的7层协议，每一层都可以看作是下一层的虚拟层；计算机操作系统可以看作是计算机硬件的虚拟层；Java虚拟机可以看作是操作系统的虚拟层；分层的计算机软件架构事实上也是利用虚拟层的概念。</p>
<p>解决上述一致性Hash算法带来的负载不均衡问题，也可以通过使用虚拟层的手段：将每台物理缓存服务器虚拟为一组虚拟缓存服务器，将虚拟服务器的Hash值放置在Hash环上，key在环上先找到虚拟服务器节点，再得到物理服务器的信息。</p>
<p>这样新加入物理服务器节点时，<strong>是将一组虚拟节点加入环中，如果虚拟节点的数目足够多，这组虚拟节点将会影响同样多数目的目的已经在环上存在的虚拟节点，</strong>这些已经存在的虚拟节点又对应不同的物理节点。</p>
<p>最终的结果是：新加入一台缓存服务器，<strong>将会较为均匀地影响原来集群中已经存在的所有服务器，也就是说分摊原有缓存服务器集群中所有服务器的一小部分负载，其总的影响范围和上面讨论过的相同</strong>。</p>
<p>新加入节点<code>NODE3</code>对应的一组虚拟节点为<code>V30</code>，<code>V31</code>，<code>V32</code>，加入到一致性Hash环上后，影响<code>V01</code>，<code>V12</code>，<code>V22</code>三个虚拟节点，而这三个虚拟节点分别对应<code>NODE0</code>，<code>NODE1</code>，<code>NODE2</code>三个物理节点。最终Memcached集群中加入一个节点，但是同时影响到集群中已存在的三个物理节点，在理想情况下，每个物理节点受影响的数据量（还在缓存中，但是不能被访问到数据）为其节点缓存数据量的1&#x2F;4（X&#x2F;（N＋X），N为原有物理节点数，X为新加入物理节点数），也就是集群中已经被缓存的数据有75％可以被继续命中，和未使用虚拟节点的一致性Hash算法结果相同。显然每个物理节点对应的虚拟节点越多，各个物理节点之间的负载越均衡，新加入物理服务器对原有的物理服务器的影响越保持一致（这就是一致性Hash这个名称的由来）。</p>
<h4 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h4><p>考虑最简单的RPC功能。<br>客户端调用服务端方法，服务端返回。</p>
<p>1，有一个User对象，是客户端与服务端都已知的<br>2，定义客户端需要调用，服务端需要提供的服务接口UserService<br>3，服务端需要实现UserService接口的功能UserServiceImpl<br>4，客户端建立Socket连接，传输Id给服务端，得到返回的User对象<br>5，服务端以BIO的方式监听Socket，如有数据，调用对应服务的实现类执行任务，将结果返回给客户端</p>
<p>问题<br>只能调用服务端唯一的方法<br>返回值也只只支持一种</p>
<h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p>定义了一个通用的Request的对象（消息格式）<br>（在上个版本中，Request仅仅只发送了一个id参数过去，这显然是不合理的，<br>因为服务端不会只有一个服务一个方法，因此只传递参数不会知道调用那个方法。<br>因此一个RPC请求中，client发送应该是需要调用的Service接口名，方法名，参数，参数类型<br>这样服务端就能根据这些信息根据反射调用相应的方法。<br>还是使用java自带的序列化方式。）</p>
<p> 定义了一个通用的Response的对象（消息格式）</p>
<p>（上个版本中response传输的是User对象，显然在一个应用中我们不可能只传输一种类型的数据<br>由此我们将传输对象抽象成为Object<br>。Rpc需要经过网络传输，有可能失败，引入状态码和状态信息表示服务调用成功还是失败）</p>
<p>通过jdk 动态代理封装传输细节， 每一次代理对象调用方法，会经过invoke方法增强（反射获取request对象，socket发送至客户端，得到返回的rpcresponce）</p>
<p>客户端反射得到结果<br> &#x2F;&#x2F; 读取客户端传过来的request<br> RPCRequest request &#x3D; (RPCRequest) ois.readObject();<br>&#x2F;&#x2F; 反射调用对应方法<br>Method method &#x3D; userService.getClass().getMethod(request.getMethodName(), request.getParamsTypes());<br> Object invoke &#x3D; method.invoke(userService, request.getParams());<br>&#x2F;&#x2F; 封装，写入response对象<br> oos.writeObject(RPCResponse.success(invoke));<br>问题<br>服务端直接绑定的是UserService服务，如果还有其它服务接口暴露呢（多个服务的注册）<br>服务端以BIO的方式性能太低<br>解决<br>用一个Map来保存，&lt;interfaceName, xxxServiceImpl&gt;<br>此时来了一个request，就能从map中取出对应的服务<br>Object service &#x3D; map.get(request.getInterfaceName())<br>服务端用线程池<br> threadPool &#x3D; new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),<br>                1000, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(100));</p>
<h4 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h4><p>netty改善<br>客户端<br>&#x2F;&#x2F;超时设定：5秒没连接就断开<br> .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)<br> .handler(new ChannelInitializer<SocketChannel>() {<br>     @Override<br>     protected void initChannel(SocketChannel ch) {<br>         ChannelPipeline p &#x3D; ch.pipeline();<br>         &#x2F;&#x2F;5秒没有数据发送，就发送心跳包。<br>         p.addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS));<br>         p.addLast(new RpcMessageEncoder());&#x2F;&#x2F;编码<br>         p.addLast(new RpcMessageDecoder());&#x2F;&#x2F;解码<br>         p.addLast(new NettyRpcClientHandler());<br>     }<br> });<br>4B  magic code（魔法数）   1B version（版本）   4B full length（消息长度）    1B messageType（消息类型-request，reaponse，心跳）<br>1B compress（压缩类型） 1B codec（序列化类型）    4B  requestId（请求的Id） </p>
<p>服务端<br>&#x2F;&#x2F; TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。<br>.childOption(ChannelOption.TCP_NODELAY, true)<br>&#x2F;&#x2F; 是否开启 TCP 底层心跳机制<br>.childOption(ChannelOption.SO_KEEPALIVE, true)<br>&#x2F;&#x2F;表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数<br>.option(ChannelOption.SO_BACKLOG, 128)<br>.handler(new LoggingHandler(LogLevel.INFO))<br>&#x2F;&#x2F; 当客户端第一次进行请求的时候才会进行初始化<br>.childHandler(new ChannelInitializer<SocketChannel>() {<br>    @Override<br>    protected void initChannel(SocketChannel ch) {<br>        &#x2F;&#x2F; 30 秒之内没有收到客户端请求的话就关闭连接<br>        ChannelPipeline p &#x3D; ch.pipeline();<br>        p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));<br>        p.addLast(new RpcMessageEncoder());<br>        p.addLast(new RpcMessageDecoder());<br>        p.addLast(serviceHandlerGroup, new NettyRpcServerHandler());</p>
<p>问题：服务端与客户端通信的host与port预先就必须知道的，每一个客户端都必须知道对应服务的ip与端口号， 并且如果服务挂了或者换地址了，就很麻烦。扩展性也不强。</p>
<h4 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h4><p>zookeeper注册中心<br>public void registerService(String rpcServiceName, InetSocketAddress inetSocketAddress) {<br>    String servicePath &#x3D; CuratorUtils.ZK_REGISTER_ROOT_PATH + “&#x2F;“ + rpcServiceName + inetSocketAddress.toString();<br>    CuratorFramework zkClient &#x3D; CuratorUtils.getZkClient();<br>    CuratorUtils.createPersistentNode(zkClient, servicePath);<br>}</p>
<p>public InetSocketAddress lookupService(RpcRequest rpcRequest) {<br>    String rpcServiceName &#x3D; rpcRequest.getRpcServiceName();<br>    CuratorFramework zkClient &#x3D; CuratorUtils.getZkClient();<br>    List<String> serviceUrlList &#x3D; CuratorUtils.getChildrenNodes(zkClient, rpcServiceName);<br>    if (serviceUrlList &#x3D;&#x3D; null || serviceUrlList.size() &#x3D;&#x3D; 0) {<br>        throw new RpcException(RpcErrorMessageEnum.SERVICE_CAN_NOT_BE_FOUND, rpcServiceName);<br>    }<br>    &#x2F;&#x2F; load balancing<br>    String targetServiceUrl &#x3D; loadBalance.selectServiceAddress(serviceUrlList, rpcRequest);</p>
<pre><code>String[] socketAddressArray = targetServiceUrl.split(&quot;:&quot;);
String host = socketAddressArray[0];
int port = Integer.parseInt(socketAddressArray[1]);
return new InetSocketAddress(host, port);
</code></pre>
<p>}<br>简单的负载均衡<br>随机<br>轮询<br>一致性哈希</p>
<p>容错</p>
<p>在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议。</p>
<p>基于 TCP 协议的 RPC 调用</p>
<p>由服务的调用方与服务的提供方建立 Socket 连接，并由服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法。</p>
<p>将结果返回给服务的调用方，整个基于 TCP 协议的 RPC 调用大致如此。</p>
<p>但是在实例应用中则会进行一系列的封装，如 RMI 便是在 TCP 协议上传递可序列化的 Java 对象。</p>
<p>基于 HTTP 协议的 RPC 调用</p>
<p>该方法更像是访问网页一样，只是它的返回结果更加单一简单。</p>
<p>其大致流程为：由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 GET、POST、PUT、DELETE 等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。</p>
<p>而调用的具体方法则是根据 URL 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 XML 数据或者 JSON 数据解析后的结果，返回 JOSN 或者 XML 的数据结果。</p>
<p>由于目前有很多开源的 Web 服务器，如 Tomcat，所以其实现起来更加容易，就像做 Web 项目一样。</p>
<p>两种方式对比</p>
<p>基于 TCP 的协议实现的 RPC 调用，由于 TCP 协议处于协议栈的下层，能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。</p>
<p>但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。</p>
<p>基于 HTTP 协议实现的 RPC 则可以使用 JSON 和 XML 格式的请求或响应数据。</p>
<p>而 JSON 和 XML 作为通用的格式标准(使用 HTTP 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 Web 程序已经做好了序列化内容)，开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。</p>
<p>但是由于 HTTP 协议是上层协议，发送包含同等内容的信息，使用 HTTP 协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。</p>
<p>因此在同等网络下，通过 HTTP 协议传输相同内容，效率会比基于 TCP 协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距。</p>
<p>简单对比 RPC 和 Restful API</p>
<p>RESTful API 架构</p>
<p>REST 的几个特点为：资源、统一接口、URI 和无状态。</p>
<p>①资源</p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，就是一个具体的实在。</p>
<p>②统一接口</p>
<p>RESTful 架构风格规定，数据的元操作，即 CRUD(Create，Read，Update 和 Delete，即数据的增删查改)操作，分别对应于 HTTP 方法：GET 用来获取资源，POST 用来新建资源(也可以用于更新资源)，PUT 用来更新资源，DELETE 用来删除资源，这样就统一了数据操作的接口，仅通过 HTTP 方法，就可以完成对数据的所有增删查改工作。</p>
<p>③URL</p>
<p>可以用一个 URI(统一资源定位符)指向资源，即每个 URI 都对应一个特定的资源。</p>
<p>要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或识别符。</p>
<p>④无状态</p>
<p>所谓无状态的，即所有的资源，都可以通过 URI 定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。有状态和无状态的区别，举个简单的例子说明一下。</p>
<p>如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的。</p>
<p>因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行。</p>
<p>如果输入一个 URI 即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态。</p>
<p>且这种情况下，员工工资是一个资源，由一个 URI 与之对应，可以通过 HTTP 中的 GET 方法得到资源，这是典型的 RESTful 风格。</p>
<p>RPC 和 Restful API 对比</p>
<p>面对对象不同：</p>
<p>RPC 更侧重于动作。<br>REST 的主体是资源。<br>RESTful 是面向资源的设计架构，但在系统中有很多对象不能抽象成资源，比如登录，修改密码等而 RPC 可以通过动作去操作资源。所以在操作的全面性上 RPC 大于 RESTful。</p>
<p>传输效率：</p>
<p>RPC 效率更高。RPC，使用自定义的 TCP 协议，可以让请求报文体积更小，或者使用 HTTP2 协议，也可以很好的减少报文的体积，提高传输效率。</p>
<p>复杂度：</p>
<p>RPC 实现复杂，流程繁琐。<br>REST 调用及测试都很方便。<br>RPC 实现需要实现编码，序列化，网络传输等。而 RESTful 不要关注这些，RESTful 实现更简单。</p>
<p>灵活性：</p>
<p>HTTP 相对更规范，更标准，更通用，无论哪种语言都支持 HTTP 协议。<br>RPC 可以实现跨语言调用，但整体灵活性不如 RESTful。</p>
<p>总结</p>
<p>RPC 主要用于公司内部的服务调用，性能消耗低，传输效率高，实现复杂。</p>
<p>HTTP 主要用于对外的异构环境，浏览器接口调用，App 接口调用，第三方接口调用等。</p>
<p>RPC 使用场景(大型的网站，内部子系统较多、接口非常多的情况下适合使用 RPC)：</p>
<p>长链接。不必每次通信都要像 HTTP 一样去 3 次握手，减少了网络开销。<br>注册发布机制。RPC 框架一般都有注册中心，有丰富的监控管理;发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。<br>安全性，没有暴露资源操作。<br>微服务支持。就是最近流行的服务化架构、服务化治理，RPC 框架是一个强力的支撑。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XieYi</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">263k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:59</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
