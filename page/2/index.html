<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"xieyi123456.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":true,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="think and do">
<meta property="og:type" content="website">
<meta property="og:title" content="XieYi&#39;s Blog">
<meta property="og:url" content="https://xieyi123456.github.io/page/2/index.html">
<meta property="og:site_name" content="XieYi&#39;s Blog">
<meta property="og:description" content="think and do">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XieYi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xieyi123456.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>XieYi's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="XieYi's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">XieYi's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">log something</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XieYi"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">XieYi</p>
  <div class="site-description" itemprop="description">think and do</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:2643100268@qq.com" title="E-Mail → mailto:2643100268@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/04/Redis-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/04/Redis-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">Redis-缓存一致性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-04 17:22:25" itemprop="dateCreated datePublished" datetime="2021-08-04T17:22:25+08:00">2021-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="如何保证数据库和缓存的数据一致性"><a href="#如何保证数据库和缓存的数据一致性" class="headerlink" title="如何保证数据库和缓存的数据一致性"></a>如何保证数据库和缓存的数据一致性</h2><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化，串到一个内存队列里去</strong>。</p>
<p><strong>串行化</strong>可以保证<strong>一定不会出现不一致的情况</strong>，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h2 id="Cache-Aside-Pattern旁路缓存模式"><a href="#Cache-Aside-Pattern旁路缓存模式" class="headerlink" title="Cache Aside Pattern旁路缓存模式"></a><strong>Cache Aside Pattern旁路缓存模式</strong></h2><p>最经典的缓存+数据库读写的模式，就是 <strong>Cache Aside Pattern。</strong></p>
<blockquote>
<p><strong>读的时候，先读缓存</strong>，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。<br><strong>更新的时候，先更新数据库，成功后，然后再删除缓存。</strong></p>
<p>如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</p>
</blockquote>
<h3 id="在写数据的过程中，可以先删除-cache-，后更新-DB-？"><a href="#在写数据的过程中，可以先删除-cache-，后更新-DB-？" class="headerlink" title="在写数据的过程中，可以先删除 cache ，后更新 DB ？"></a>在写数据的过程中，可以先删除 cache ，后更新 DB ？</h3><p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。</p>
<h3 id="在写数据的过程中，先更新DB，后删除cache就没有问题了？"><a href="#在写数据的过程中，先更新DB，后删除cache就没有问题了？" class="headerlink" title="在写数据的过程中，先更新DB，后删除cache就没有问题了？"></a>在写数据的过程中，先更新DB，后删除cache就没有问题了？</h3><p>理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为<strong>缓存的写入速度是比数据库的写入速度快很多</strong></p>
<p>比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>
<p>请求1从DB读数据A-&gt;请求2写更新数据 A 到数据库并把删除cache中的A数据-&gt;请求1将数据A写入cache。</p>
<h3 id="为什么是删除缓存，而不是更新缓存？"><a href="#为什么是删除缓存，而不是更新缓存？" class="headerlink" title="为什么是删除缓存，而不是更新缓存？"></a>为什么是删除缓存，而不是更新缓存？</h3><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p>
<p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p>
<p>另外<strong>更新缓存的代价有时候是很高的</strong>。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。<strong>如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。</strong>但是问题在于，这个缓存到底会不会被频繁访问到？</p>
<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；<strong>但是这个缓存在 1 分钟内只被读取了 1 次</strong>，有大量的冷数据。实际上，<strong>如果你只是删除缓存的话</strong>，那么在 1 分钟内，这个缓存不过就重新计算一次而已，<strong>开销大幅度降低</strong>。用到缓存才去算缓存。</p>
<p><strong>其实删除缓存，而不是更新缓存</strong>，就是一个 <strong>lazy 计算</strong>的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>但实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的<strong>写操作会比读操作慢得多，而且还要锁表</strong>，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p>所以，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，<strong>最好还是为缓存设置上过期时间。</strong></p>
<h2 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h2><p>Read&#x2F;Write Through套路是把更新数据库（Repository）的操作由<strong>缓存自己代理</strong>，可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</p>
<p><strong>Read Through</strong><br>Read Through 套路就是在<strong>查询操作中更新缓存</strong>，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<p><strong>Write Through</strong><br>Write Through 套路和Read Through相仿，不过是在更新数据时发生。<strong>当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回</strong>。<strong>如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</strong></p>
<p><img src="https://i.loli.net/2021/08/04/UgD7uS9WeIimzxR.png" alt="image-20210804192802967"></p>
<h2 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h2><p>Write Behind 又叫 Write Back。</p>
<p>Write Back套路，<strong>在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。</strong>这个设计的好处就是让数据的I&#x2F;O操作飞快无比，因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，<strong>数据不是强一致性的</strong>，而且可能会丢失。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/03/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/03/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java并发-线程安全的机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-03 15:20:24" itemprop="dateCreated datePublished" datetime="2021-08-03T15:20:24+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>解决多个线程访问资源的同步性。可以保证被他修饰的方法或者代码块在任意时刻只有一个线程执行。</strong></p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>synchronized 同步语句块的实现使⽤的是 <strong>monitorenter 和 monitorexit</strong> 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。</p>
<p>当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。<br>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了⼀个 ObjectMonitor 对象。</p>
<p>另外， <strong>wait&#x2F;notify 等⽅法也依赖于 monitor 对象</strong>，这就是为什么只有在同步的块或者⽅法中才能调⽤ wait&#x2F;notify 等⽅法，否则会抛出 java.lang.IllegalMonitorStateException 的异常的原因。</p>
<p>在执⾏ monitorenter 时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。<br>在执⾏ monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p>
<p>sc<strong>ACC_SYNCHRONIZED 标识，</strong>该标识指明了该⽅法是⼀个同步⽅法。JVM 通过该访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。</p>
<p> <strong>两者的本质都是对对象监视器 monitor 的获取 。</strong></p>
<h4 id="sychronized改进"><a href="#sychronized改进" class="headerlink" title="sychronized改进"></a>sychronized改进</h4><p>java1.6以后，引入了偏向锁和轻量级锁。</p>
<p>锁有四种状态：无锁，偏向锁，轻量级锁，重量级锁，可以升级，不能降级。</p>
<p><img src="https://i.loli.net/2021/08/13/UcrKuk24wXRVOT8.png" alt="image-20210813150959660"></p>
<h4 id="可重入性："><a href="#可重入性：" class="headerlink" title="可重入性："></a>可重入性：</h4><p>通过记录锁的持有线程和持有数量实现。</p>
<h4 id="内存可见性："><a href="#内存可见性：" class="headerlink" title="内存可见性："></a>内存可见性：</h4><p>释放锁时所有的写入操作都会写回内存。获得锁后，都会从内存里读取数据。</p>
<p>如果只是保证内存可见性，volatile即可（加上后java会在操作对应变量时插入特殊指令）</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>避免在持有一个锁时申请另一个锁。</p>
<p>jstack报告死锁</p>
<p>使用方法：</p>
<ul>
<li><p>修饰实例方法。锁的是实例对象（this）。</p>
</li>
<li><p>修饰静态方法。锁的是Class类对象。</p>
</li>
<li><p>修饰代码块。指定加锁对象。</p>
</li>
</ul>
<p>如果⼀个线程 A 调⽤⼀个实例对象的<strong>⾮静态 synchronized ⽅法</strong>，⽽线程 B 需要调⽤<strong>这个实例对象所属类的静态 synchronized ⽅法</strong>，是允许的，不会发⽣互斥现象，因为访问<strong>静态 synchronized ⽅法</strong>占⽤的锁是当前类的锁，⽽访问<strong>⾮静态 synchronized ⽅法占⽤的锁</strong>是当前实例对象锁 。</p>
<p><img src="https://i.loli.net/2021/08/03/13xPdpflDO6yBaC.png" alt="image-20210803220907606"></p>
<h2 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h2><p>接口：lock，实现类：reentrantlock</p>
<p>接口：readwritelock，实现类：reentrantreadwritelock</p>
<p><img src="https://i.loli.net/2021/08/03/k9nquVjWSlchbTF.png" alt="image-20210803191609899"></p>
<p>显示锁支持非阻塞的方式获取锁，可以响应中断，限时，因此更加灵活。</p>
<p>使用trylock可以避免死锁</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理:"></a>实现原理:</h4><p>依赖于cas，juc下的locksupport</p>
<p>主要方法：park，unpark</p>
<h4 id="对比sychronized和reentrantlock"><a href="#对比sychronized和reentrantlock" class="headerlink" title="对比sychronized和reentrantlock"></a>对比sychronized和reentrantlock</h4><p><img src="https://i.loli.net/2021/08/03/bsiRn2areV5ltPx.png" alt="image-20210803192404150"></p>
<p><img src="https://i.loli.net/2021/08/03/K7TxSYfRDXjFEqi.png" alt="image-20210803220931642"></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p>
<p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>
<p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
<p><strong>为什么无锁效率高</strong></p>
<p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候<strong>，发生上下文切换，进入阻塞。</strong></p>
<p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。（多核）</p>
<p><img src="https://i.loli.net/2021/08/03/Pts1kLSAliZpzXR.png" alt="image-20210803220954272"></p>
<h2 id="原子变量以及CAS"><a href="#原子变量以及CAS" class="headerlink" title="原子变量以及CAS"></a>原子变量以及CAS</h2><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于线程数少、多核 CPU 的场景下。</p>
<p><strong>cas+volatile可以实现原子变量</strong></p>
<p>CAS 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，再重试。</p>
<p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
<p>CAS 体现的是无锁并发、无阻塞并发</p>
<p>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一<br>但如果<strong>竞争激烈</strong>，可以想到重试必然频繁发生，反而效率会受影响</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS更新：a-b-a，当前线程的CAS操作无法分辨。</p>
<p>解决：时间戳</p>
<p><img src="https://i.loli.net/2021/08/03/Wbrt63ATpcDCyR8.png" alt="image-20210803221011726"></p>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p><img src="https://i.loli.net/2021/08/03/TGsg6aUoNSQCP1V.png" alt="image-20210803221023698"></p>
<h2 id="threadlocal"><a href="#threadlocal" class="headerlink" title="threadlocal"></a>threadlocal</h2><p>threadlocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据。</p>
<p>ThreadLocal的作⽤主要是做<strong>数据隔离</strong>，填充的数据只属于当前线程，变量的数据对别的线程⽽⾔是相对隔离的，在多线程环境下，如何防⽌⾃⼰的变量被其它线程篡改。</p>
<p>对于某一ThreadLocal来讲，他的索引值i是确定的，在不同线程之间访问时访问的是不同的table数组的同一位置即都为table[i]，只不过这个不同线程之间的table是独立的。</p>
<p>对于<strong>同一线程的不同ThreadLocal</strong>来讲，这些ThreadLocal实例<strong>共享一个table数组</strong>，然后每个ThreadLocal实例在table中的索引i是不同的。</p>
<p>ThreadLocal和Synchronized都是为了解决多线程中相同变量的访问冲突问题，不同的点是：</p>
<p>Synchronized是通过线程等待，牺牲时间来解决访问冲突<br>ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</p>
<h3 id="ThreadLocalMap底层结构？"><a href="#ThreadLocalMap底层结构？" class="headerlink" title="ThreadLocalMap底层结构？"></a>ThreadLocalMap底层结构？</h3><p><img src="https://i.loli.net/2021/08/03/a6N28GoWUrV3A1Q.png" alt="计算机生成了可选文字: ThreadLocals ThreadLocalMap  Entry "></p>
<p>未实现Map接⼝，⽽且他的Entry是继承WeakReference（弱引⽤）的，也没有HashMap中的next（无链表）</p>
<p><strong>为什么是数组结构？</strong></p>
<p><strong>⼀个线程可以有多个TreadLocal</strong>来存放不同类型的对象的，但是他们都将放到你当前线程的ThreadLocalMap⾥，所以肯定要数组。</p>
<p><strong>解决hash冲突？</strong></p>
<p><img src="https://i.loli.net/2021/08/03/QCvWehaPHJwrOt6.png" alt="计算机生成了可选文字: Entry  ThreadLocals  Thread  Entry  新 增  如 不 为 空 ， üThreadLocal  不 相 ， 下 一 个 为 空 的 位  不 为 空 判 斷 仆 readLocal  本 身 矍 否 相 等 相 等 翩 新  3 "></p>
<p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key⼀致，如果不⼀致，就判断下⼀个位置，set和get如果冲突严重的话，效率还是很低的。</p>
<p><strong>对象存放在哪⾥么？</strong></p>
<p>在Java中，栈内存归属于单个线程，每个线程都会有⼀个栈内存，其存储的变量只能在其所属线程中可<br>⻅，即栈内存可以理解成线程的私有内存，⽽堆内存中的对象对所有线程可⻅，堆内存中的对象可以被<br>所有线程访问。</p>
<p><strong>ThreadLocal的实例以及其值存放在栈上呢？</strong></p>
<p>其实不是的，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有），⽽<br>ThreadLocal的值其实也是被线程实例持有，<strong>它们都是位于堆上，只是通过⼀些技巧将可⻅性修改成了</strong><br><strong>线程可⻅。</strong></p>
<p><strong>共享线程的ThreadLocal数据怎么办？</strong></p>
<p>使⽤ <strong>InheritableThreadLocal</strong> 可以实现多个线程访问ThreadLocal的值，我们在主线程中创建⼀个 InheritableThreadLocal 的实例，然后在⼦线程中得到这个 InheritableThreadLocal 实例设置的值。</p>
<p>如果线程的 inheritThreadLocals 变量不为空，⽽且⽗线程的 inheritThreadLocals 也存在，那么就把⽗线程的 inheritThreadLocals 给当前线程的inheritThreadLocals 。</p>
<p><strong>问题？</strong></p>
<p>只具有弱引⽤的对象拥有更短暂的⽣命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，⼀旦发现了只具有弱引⽤的对象，不管当前内存空间⾜够与否，都会回收它的内存。不过，由于垃圾回收器是⼀个优先级很低的线程，因此不⼀定会很快发现那些只具有弱引⽤的对象。</p>
<p>这就导致了⼀个问题，ThreadLocal在没有外部强引⽤时，发⽣GC时会被回收，如果创建ThreadLocal的线程⼀直持续运⾏，那么这个Entry对象中的value就有可能⼀直得不到回收，发⽣内存泄露。<br>就⽐如线程池⾥⾯的线程，线程都是复⽤的，那么之前的线程实例处理完之后，出于复⽤的⽬的线程依然存活，所以，ThreadLocal设定的value值被持有，导致内存泄露。</p>
<p><strong>解决：</strong>⼀个线程使⽤完，ThreadLocalMap是应该要被清空的，手动调用remove（）方法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-String-table/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-String-table/" class="post-title-link" itemprop="url">Java虚拟机-String-table</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-02 13:53:10" itemprop="dateCreated datePublished" datetime="2021-08-02T13:53:10+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h3><p>String：字符串，使用一对 “” 引起来表示<br>String s1 &#x3D; “qweq” ;               &#x2F;&#x2F; 字面量的定义方式<br>String s2 &#x3D;  new String(“hello”);     &#x2F;&#x2F; new 对象的方式</p>
<p>String被声明为final的，不可被继承</p>
<p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p>
<p><strong>String在jdk8及以前内部定义了final char value[]用于存储字符串数据。JDK9时改为byte[]</strong></p>
<h4 id="为什么-JDK9-改变了-String-的结构"><a href="#为什么-JDK9-改变了-String-的结构" class="headerlink" title="为什么 JDK9 改变了 String 的结构"></a>为什么 JDK9 改变了 String 的结构</h4><p>为什么改为 byte[] 存储？<br>String类的当前实现将字符存储在char数组中，<strong>每个字符使用两个字节(16位)。</strong><br>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</p>
<p>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组，<strong>外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存。</strong><br>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，<strong>节约了一些空间</strong><br>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改。</p>
<p>String：代表不可变的字符序列。简称：<strong>不可变性。</strong></p>
<p>当对字符串重新赋值时，<strong>需要重写指定内存区域赋值</strong>，不能使用原有的value进行赋值。</p>
<p>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
<p>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
<p>通过<strong>字面量的方式（区别于new）给一个字符串赋值</strong>，此时的字符串值声明在<strong>字符串常量池</strong>中。<br>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</p>
<h3 id="String-的底层结构"><a href="#String-的底层结构" class="headerlink" title="String 的底层结构"></a>String 的底层结构</h3><p>字符串常量池是<strong>不会存储相同内容的字符串的</strong></p>
<p>String的String Pool（字符串常量池）是一个<strong>固定大小的Hashtable，默认值大小长度是60013</strong>。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</p>
<p>使用-XX:StringTablesize可设置StringTable的长度<br>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求<br>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求<br>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</p>
<h3 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h3><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种<strong>常量池</strong>的概念。</p>
<p>常量池就类似一个<strong>Java系统级别提供的缓存</strong>。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。</p>
<p>它的主要使用方法有两种。<br>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：String info&#x3D;”xy.com”;<br>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</p>
<p>Java 6及以前，字符串常量池存放在<strong>永久代</strong><br>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置<strong>调整到Java堆内</strong><br><strong>所有的字符串都保存在堆（Heap）中</strong>，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。<br>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。<br>Java8<strong>元空间，字符串常量在堆</strong></p>
<h3 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h3><p>为什么要调整位置？</p>
<p>1，永久代的默认空间大小比较小<br>2，永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space<br><strong>堆中空间足够大，字符串可被及时回收</strong></p>
<h3 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h3><p><strong>常量与常量的拼接结果在常量池，原理是编译期优化</strong></p>
<p>常量池中不会存在相同内容的变量<br>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder<br>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：</p>
<p>如果存在，则返回字符串在常量池中的地址。<br>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址。</p>
<p>1、常量与常量的拼接结果在常量池，原理是编译期优化。</p>
<p>2、拼接前后，只要其中有一个是变量，结果就在堆中<br>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</p>
<p><strong>通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</strong></p>
<p>原因：</p>
<p><strong>StringBuilder的append()的方式：</strong><br>自始至终中只创建过一个StringBuilder的对象<br><strong>使用String的字符串拼接方式：</strong><br>创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</p>
<p>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</p>
<p>改进的空间：</p>
<p>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：<br>StringBuilder s &#x3D; new StringBuilder(highLevel); &#x2F;&#x2F;new char[highLevel]<br>这样可以避免频繁扩容</p>
<h3 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h3><p>intern() 方法的说明<br>public native String intern();</p>
<p>intern是一个native方法，调用的是底层C的方法</p>
<p>字符串常量池池最初是空的，由String类私有地维护。<strong>在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。</strong>（这是源码里的大概翻译）</p>
<p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：<br> String myInfo &#x3D; new string(“I love atguigu”).intern();<br>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true<br> (“a”+”b”+”c”).intern()&#x3D; &#x3D;”abc”<br>通俗点讲，<strong>Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。</strong>注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
<h3 id="new-String-“a”-new-String-“b”-？"><a href="#new-String-“a”-new-String-“b”-？" class="headerlink" title="new String(“a”) + new String(“b”)？"></a>new String(“a”) + new String(“b”)？</h3><p>对象1：new StringBuilder()<br>对象2： new String(“a”)<br>对象3： 常量池中的”a”<br>对象4： new String(“b”)<br>对象5： 常量池中的”b”<br>    深入剖析： StringBuilder的toString():<br>对象6 ：new String(“ab”)<br>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</p>
<p>可能是4，5，6个。</p>
<p><strong>如何保证变量s指向的是字符串常量池中的数据呢？</strong></p>
<p>有两种方式：</p>
<ul>
<li>方式一： String s &#x3D; “shkstart”;&#x2F;&#x2F;字面量定义的方式</li>
<li>方式二： 调用intern()</li>
<li><pre><code>    String s = new String(&quot;shkstart&quot;).intern();
</code></pre>
</li>
<li><pre><code>    String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();
</code></pre>
</li>
</ul>
<p>对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</p>
<p>1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高<br>2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p>
<p>&#x2F;&#x2F;<strong>调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉</strong>，这也是intern省内存的关键原因</p>
<p>对于程序中大量使用存在的字符串时，尤其存在很多<strong>已经重复的字符</strong>串时，使用intern()方法能够节省很大的内存空间。<br>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p>
<h3 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h3><h4 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h4><p>String去重操作的背景</p>
<p>注意不是字符串常量池的去重操作，<strong>字符串常量池本身就没有重复的</strong><br>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<br>堆存活数据集合里面String对象占了25%<br>堆存活数据集合里面重复的String对象有13.5%<br>String对象的平均长度是45</p>
<p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的</strong>，重复的意思是说：str1.equals(str2)&#x3D; true。堆上存在重复的String对象必然是一种内存的浪费。</p>
<p>这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</p>
<h4 id="String-去重的的实现"><a href="#String-去重的的实现" class="headerlink" title="String 去重的的实现"></a>String 去重的的实现</h4><p>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。<br>如果是，把<strong>这个对象的一个引用插入到队列中等待后续的处理。</strong>一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</p>
<p>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</p>
<p>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。<br>如果查找失败，<strong>char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Java虚拟机-对象相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-02 11:57:24" itemprop="dateCreated datePublished" datetime="2021-08-02T11:57:24+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><h4 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h4><p>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</p>
<p>Class的newInstance()方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</p>
<p>Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</p>
<p>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</p>
<p>使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p>
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在<strong>Metaspace的常量池中定位到一个类的符号引用</strong>，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</p>
<p>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p>
<p><strong>2、为对象分配内存</strong></p>
<p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>
<p><strong>如果内存是规整的，那么虚拟机将采用的是指针碰撞法</strong>（Bump The Point）来为对象分配内存。<strong>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</strong><br>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。<strong>一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</strong></p>
<p>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</p>
<p><strong>如果内存不是规整的</strong>，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是<strong>空闲列表</strong>来为对象分配内存。<br><strong>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</strong></p>
<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</p>
<p><strong>3、处理并发问题</strong><br>采用CAS+失败重试，区域加锁保证更新的原子性<br>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<br>在Eden区给每个线程分配一块区域</p>
<p><strong>4、初始化分配到的空间</strong><br>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用<br>给对象属性赋值的顺序：<br>属性的默认值初始化<br>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）<br>构造器初始化</p>
<p><strong>5、设置对象的对象头</strong><br>将对象的<strong>所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息</strong>等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<p><strong>6、执行init方法进行初始化</strong><br>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量<br>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<p><strong>① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</strong></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>1，运行时元数据：<strong>哈希值，gc分代年龄，锁状态标志，偏向线程id</strong><br>2，<strong>类型指针：指向类元数据，确定对象的所属的类型</strong></p>
<p>如果是数组。<strong>还要记录数组长度。</strong><br>实例数据：<strong>对象真正存储的有效信息。先加载父类。</strong><br>对齐填充<strong>：不是必须的，占位符。</strong></p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p><strong>1、句柄访问</strong></p>
<p>缺点：在堆空间中开辟了一块空间作为<strong>句柄池</strong>，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低<br>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p>
<p><img src="https://i.loli.net/2021/08/04/EyzuL51SHXlnjsa.png" alt="image-20210804214040761"></p>
<p><strong>2、直接指针（HotSpot采用）</strong></p>
<p>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据<br>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</p>
<p><img src="https://i.loli.net/2021/08/04/zPn2hVUtgM4miOo.png" alt="image-20210804214056219"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">操作系统-简单概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-01 21:13:55" itemprop="dateCreated datePublished" datetime="2021-08-01T21:13:55+08:00">2021-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="软中断硬中断"><a href="#软中断硬中断" class="headerlink" title="软中断硬中断"></a>软中断硬中断</h3><p>Linux 系统为了解决<strong>中断处理程序执⾏过⻓和中断丢失</strong>的问题，将中断过程分成了两个阶段，分别是</p>
<ul>
<li>上半部⽤来<strong>快速处理中断</strong>，⼀般会暂时关闭中断请求，主要负责处理跟<strong>硬件紧密相关或者时间敏感</strong>的事情。</li>
<li>下半部⽤来延迟处理上半部未完成的⼯作，⼀般以<strong>「内核线程」</strong>的⽅式运⾏。</li>
</ul>
<p><strong>⽹卡收到⽹络包后</strong>，会通过硬件中断通知内核有新的数据到了，于是内核就会调⽤对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部和下半部。</p>
<ul>
<li>上部分要做到快速处理，所以只要把<strong>⽹卡的数据读到内存中，然后更新⼀下硬件寄存器的状态</strong>，⽐如把状态更新为表示数据已经读到内存中的状态值。</li>
<li>接着，内核会触发⼀个软中断，把⼀些处理⽐较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其<strong>主要是需要从内存中找到⽹络数据，再按照⽹络协议栈，对⽹络数据进⾏逐层解析和处理，最后把数据送给应⽤程序</strong>。</li>
</ul>
<p>所以，中断处理程序的上部分和下半部可以理解为：</p>
<p>上半部直接处理硬件请求，也就是硬中断，主要是负责<strong>耗时短</strong>的⼯作，特点是<strong>快速执⾏</strong>；</p>
<p>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的⼯作，通常都是<strong>耗时⽐较⻓</strong>的事情，特点是<strong>延迟执⾏</strong>；</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>计算机是由各种外部硬件设备组成的，⽐如<strong>内存、cpu、硬盘</strong>等，如果每个应⽤都要和这些硬件设备对接通信协议，那这样太累了，所以由内核来负责，让<strong>内核作为应⽤连接硬件设备的桥梁</strong>，应⽤程序只需关⼼与内核交互，不⽤关⼼硬件的细节。<br>现代操作系统，内核⼀般会提供 4 个基本能⼒：</p>
<ul>
<li><strong>管理进程、线程</strong>，决定哪个进程、线程使⽤ CPU，也就是进程调度的能⼒；</li>
<li><strong>管理内存</strong>，决定内存的分配和回收，也就是内存管理的能⼒；</li>
<li><strong>管理硬件设备</strong>，为进程与硬件设备之间提供通信能⼒，也就是硬件通信能⼒；</li>
<li><strong>提供系统调⽤</strong>，如果应⽤程序要运⾏<strong>更⾼权限</strong>运⾏的服务，那么就需要有系统调⽤，它是⽤户程序与操作系统之间的接⼝。</li>
</ul>
<p><img src="https://i.loli.net/2021/08/04/qb4CBd1XiT2AHrv.png" alt="image-20210804214134653"></p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>由编译器自动释放，存放函数的<strong>参数值，局部变量</strong>等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈中。然后这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。<strong>每调用一个函数一个新的栈就会被使用</strong>。栈区是从高地址位向低地址位增长的，<strong>是一块连续的内在区域</strong>，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是是<strong>不连续的内存区域</strong>，这是由于系统使用<strong>链表存储空闲内存地址的</strong>，自然是不连续的。而链表的遍历方式是由低地址向高地址，堆的大小受限于计算机系统中有效的内存，由此可见，堆获得的空间比较灵活，也比较大。<br>操作系统有一个<strong>记录空闲内存地址的链表</strong>，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，</p>
<h3 id="32位64位"><a href="#32位64位" class="headerlink" title="32位64位"></a>32位64位</h3><p>从程序上说：32位与64位程序，是指经过语言编译后的可执行文件，比如 C 语言编写的程序就需要区分是32位的还是64位</p>
<p>从系统和硬件上讲：<strong>CPU一次处理数据的能力是32位还是64位</strong>，关系着系统需要安装32位还是64位的系统</p>
<p>32 位和 64 位中的“位”，也叫字长，是 CPU 通用寄存器的数据宽度，是数据传递和处理的基本单位。字长是 CPU 的主要技术指标之一，指的是 CPU 一次能并行处理的二进制位数，字长总是8的整数倍</p>
<p><img src="https://i.loli.net/2021/08/05/5TA1EkOFcBIMp8Q.png" alt="image-20210805161650063"></p>
<h3 id="用户态内核态"><a href="#用户态内核态" class="headerlink" title="用户态内核态"></a>用户态内核态</h3><p><img src="https://i.loli.net/2021/08/06/G6DNz3QckpS4dMO.png" alt="image-20210806101858699"></p>
<p>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。</p>
<p>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</p>
<p>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。</p>
<p>在CPU的所有指令中，<strong>有一些指令是非常危险的</strong>，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。如果所有的程序都能使用这些指令，那么十分危险。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/31/%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%931/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/31/%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%931/" class="post-title-link" itemprop="url">笔试总结1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-31 21:28:34" itemprop="dateCreated datePublished" datetime="2021-07-31T21:28:34+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">笔试</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>970</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="有序数组，交换两数，找出这两个数的下标"><a href="#有序数组，交换两数，找出这两个数的下标" class="headerlink" title="有序数组，交换两数，找出这两个数的下标"></a>有序数组，交换两数，找出这两个数的下标</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>用两个标志位去找乱序的那两个数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int[] change(int[] nums) &#123;</span><br><span class="line">        int first = -1;</span><br><span class="line">        int second = -1;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (first == -1 &amp;&amp; nums[i - 1] &gt; nums[i]) first = i - 1;</span><br><span class="line">            if (first != -1 &amp;&amp; nums[i - 1] &gt; nums[i]) second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res[0] = first + 1;</span><br><span class="line">        res[1] = second + 1;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="括号的个数"><a href="#括号的个数" class="headerlink" title="括号的个数"></a>括号的个数</h3><p>【】【】【【】3】2</p>
<p>表示1+1+2（3）&#x3D;8个括号</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBox</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">               stack.push(<span class="number">1</span>);<span class="comment">//保底一个</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">               <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s.charAt(i + <span class="number">1</span>) &gt; <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">//后面为数字，要结算</span></span><br><span class="line">                   temp *= (s.charAt(i + <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                   i++;<span class="comment">//结算完跳过这个数字</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (stack.isEmpty()) &#123;<span class="comment">//空的，表示一个分段算完了</span></span><br><span class="line">                   res += temp;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop() + temp;</span><br><span class="line">                   stack.push(top);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Spring-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Spring-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">Spring-常见概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:15:42" itemprop="dateCreated datePublished" datetime="2021-07-30T15:15:42+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p>
<p>比如说 Spring 自带 **IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)**、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p>
<h3 id="列举一些重要的-Spring-模块？"><a href="#列举一些重要的-Spring-模块？" class="headerlink" title="列举一些重要的 Spring 模块？"></a>列举一些重要的 Spring 模块？</h3><p>Spring Core</p>
<p>核心模块， Spring 其他所有的功能基本都需要依赖于该类库，主要提供 <strong>IoC 依赖注入</strong>功能的支持。</p>
<p>Spring Aspects</p>
<p>该模块为与 AspectJ 的集成提供支持。</p>
<p>Spring AOP</p>
<p>提供了<strong>面向切面的编程</strong>实现。</p>
<p>Spring Data Access&#x2F;Integration ：</p>
<p>Spring Data Access&#x2F;Integration 由 5 个模块组成：</p>
<p>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。<br>spring-tx : 提供对事务的支持。<br>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。<br>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。<br>spring-jms : Java 消息服务。<br>Spring Web</p>
<p><strong>Spring Web 由 4 个模块组成：</strong></p>
<p>spring-web ：对 Web 功能的实现提供一些最基础的支持。<br>spring-webmvc ： 提供对 Spring MVC 的实现。<br>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。<br>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.<br>Spring Test</p>
<p><strong>Spring 团队提倡测试驱动开发（TDD）</strong>。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<h3 id="Spring-IOC-amp-AOP"><a href="#Spring-IOC-amp-AOP" class="headerlink" title="Spring IOC &amp; AOP"></a>Spring IOC &amp; AOP</h3><p>IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将<strong>原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</strong>。</p>
<h4 id="为什么叫控制反转？"><a href="#为什么叫控制反转？" class="headerlink" title="为什么叫控制反转？"></a>为什么叫控制反转？</h4><p>控制 ：指的是<strong>对象创建（实例化、管理）的权力</strong><br>反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<h4 id="谈谈自己对于-AOP-的了解"><a href="#谈谈自己对于-AOP-的了解" class="headerlink" title="谈谈自己对于 AOP 的了解"></a>谈谈自己对于 AOP 的了解</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如<strong>事务处理、日志管理、权限控制</strong>等）封装起来，便于减少系统的重复代码<strong>，</strong>降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是<strong>基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib ，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理。</p>
<h3 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h3><p>简单来说，bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据的定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<p>bean 的作用域有哪些?</p>
<p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。<br>prototype : 每次请求都会创建一个新的 bean 实例。<br>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。<br>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。<br>global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<p><bean id="..." class="..." scope="singleton"></bean><br>注解方式：</p>
<p>@Bean<br>@Scope(value &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public Person personPrototype() {<br>    return new Person();<br>}</p>
<p><strong>单例 bean 的线程安全问题？</strong></p>
<p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<p>在 bean 中尽量避免定义可变的成员变量。<br>在类中定义一个 <strong>ThreadLocal 成员变量</strong>，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。<br>不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。</p>
<p><strong>@Component 和 @Bean 的区别是什么？</strong><br>@Component 注解作用于类，而@Bean注解作用于方法。<br>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的示例，当我需要用它的时候还给我。<br>@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</p>
<p><strong>将一个类声明为 bean 的注解有哪些?</strong><br>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<p>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。<br>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。<br>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p>
<h4 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期?"></a>bean 的生命周期?</h4><p>Bean 容器找到配置文件中 Spring Bean 的定义。<br>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。<br>如果涉及到一些属性值 利用 set()方法设置一些属性值。<br>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。<br>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。<br>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r 对象的实例。<br>与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。<br>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法<br>如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。<br>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。<br>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法<br>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。<br>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p>
<p><img src="https://i.loli.net/2021/08/11/W41nvyI2YuNFclL.png" alt="image-20210811145215723"></p>
<h3 id="Spring-MVC-原理"><a href="#Spring-MVC-原理" class="headerlink" title="Spring MVC 原理"></a>Spring MVC 原理</h3><p><img src="https://i.loli.net/2021/08/11/vCYGHg4qM1sbp5J.png" alt="image-20210811145259316"></p>
<p>客户端（浏览器）发送请求，直接请求到 DispatcherServlet。<br>DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。<br>解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。<br>HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。<br>处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。<br>ViewResolver 会根据逻辑 View 查找实际的 View。<br>DispaterServlet 把返回的 Model 传给 View（视图渲染）。<br>把 View 返回给请求者（浏览器）</p>
<h4 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h4><p><strong>工厂设计模式 :</strong> Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。<br><strong>代理设计模式</strong> : Spring AOP 功能的实现。<br><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。<br><strong>模板方法模式</strong> : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。<br>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。<br>适配器模式 : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Netty-%E9%9B%B6%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">Netty-零拷贝</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:15:17" itemprop="dateCreated datePublished" datetime="2021-07-30T15:15:17+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>648</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>零拷⻉技术是指计算机执⾏操作时，CPU 不需要先将数 据从某处内存复制到另⼀个特定区域。这种技术通常⽤于通过⽹络传输⽂件时节省CPU周期和内存带宽。 </p>
<p>在 OS 层⾯上的 Zero-copy 通常指避免在用户态和内核态之间来回 拷⻉数据。</p>
<p>⽽在 Netty 层⾯ ，零拷⻉主要体现在对于数据操作的优化。 </p>
<ol>
<li>使⽤ Netty 提供的 CompositeByteBuf 类, 可以将多个 ByteBuf 合并为⼀个逻辑上的 ByteBuf , 避免了各个 ByteBuf 之间的拷⻉。 </li>
<li>ByteBuf ⽀持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同⼀个存储区域的 ByteBuf , 避免了内存的拷⻉。 </li>
<li>通过 FileRegion 包装的 FileChannel.tranferTo 实现⽂件传输（底层是sendfile方法）, 可以直接将⽂件缓冲区的数据发送到⽬标 Channel , 避免了传统通过循环 write ⽅式导致的内存拷⻉问题 。</li>
<li>duplicate。逻辑上的复制。</li>
</ol>
<h3 id="slice（si-lai-si）"><a href="#slice（si-lai-si）" class="headerlink" title="slice（si lai si）"></a>slice（si lai si）</h3><p>对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<p><img src="https://i.loli.net/2021/08/04/XkAyOUa6xiMPqV8.png" alt="image-20210804201821413"></p>
<h3 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h3><p>就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的。</p>
<p><img src="https://i.loli.net/2021/08/04/2sbl13NIuMo5jwZ.png" alt="image-20210804201834603"></p>
<h3 id="CompositeByteBuf（composite）"><a href="#CompositeByteBuf（composite）" class="headerlink" title="CompositeByteBuf（composite）"></a>CompositeByteBuf（composite）</h3><p>可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Netty-%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Netty-%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Netty-长连接，心跳机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:15:05" itemprop="dateCreated datePublished" datetime="2021-07-30T15:15:05+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="tcp粘包？netty解决办法？"><a href="#tcp粘包？netty解决办法？" class="headerlink" title="tcp粘包？netty解决办法？"></a>tcp粘包？netty解决办法？</h3><ul>
<li>使⽤ Netty ⾃带的解码器</li>
</ul>
<ol>
<li>LineBasedFrameDecoder : 发送端发送数据包的时候，每个数据包之间以换⾏符作为分隔， LineBasedFrameDecoder 的⼯作原理是它依次遍历 ByteBuf 中的可读字节，判断是否有换⾏符，然后进⾏相应的截取。</li>
<li>DelimiterBasedFrameDecoder : 可以⾃定义分隔符解码器， LineBasedFrameDecoder 实际上是⼀种特殊的 DelimiterBasedFrameDecoder 解码器。</li>
<li>FixedLengthFrameDecoder : 固定⻓度解码器，它能够按照指定的⻓度对消息进⾏相应的拆包。</li>
<li>LengthFieldBasedFrameDecoder ：</li>
</ol>
<ul>
<li><strong>⾃定义序列化编解码器</strong><br><strong>头部有长度。</strong></li>
</ul>
<h3 id="netty长连接，心跳机制？"><a href="#netty长连接，心跳机制？" class="headerlink" title="netty长连接，心跳机制？"></a>netty长连接，心跳机制？</h3><p><strong>tcp长连接短连接</strong></p>
<p>TCP 在进⾏读写之前，server 与 client 之间必须提前建⽴⼀个连接。建⽴连接的过程，需要我们常说的三次握⼿，释放&#x2F;关闭连接的话需要四次挥⼿。这个过程是比较消耗⽹络资源并且有时间延迟的。<br>短连接说的就是 server 端 与 client 端建⽴连接之后，读写完成之后就关闭掉连接，如果下⼀次再要互相发送消息，就要重新连接。</p>
<ol>
<li><p>短连接的有点很明显，就是管理和实现都⽐较简单，</p>
</li>
<li><p>缺点也很明显，每⼀次的读写都要建⽴连接必然会带来⼤量⽹络资源的消耗，并且连接的建⽴也需要耗费时间。</p>
</li>
</ol>
<p>⻓连接说的就是 client 向 server 双⽅建⽴连接之后，即使 client 与 server 完成⼀次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使⽤这个连接。⻓连接的可以省去较多的TCP 建⽴和关闭的操作，降低对⽹络资源的依赖，节约时间。</p>
<p>对于频繁请求资源的客户来说，⾮常适⽤⻓连接</p>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>在 TCP 保持⻓连接的过程中，可能会出现断⽹等⽹络异常出现，异常发⽣的时候， client 与server 之间如果没有交互的话，它们是⽆法发现对⽅已经掉线的。为了解决这个问题, 我们就需要引⼊⼼跳机制 。</p>
<p>⼼跳机制的⼯作原理是: 在 client 与 server 之间在⼀定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送⼀个特殊的数据包给对⽅, 当接收⽅收到这个数据报⽂后, 也⽴即发送⼀个特殊的数据报⽂, 回应发送⽅, 此即⼀个 PING-PONG 交互。</p>
<ol>
<li>所以, 当某⼀端收到⼼跳消息后, 就知道了对⽅仍然在线, 这就确保 TCP 连接的有效性。</li>
<li>TCP 实际上⾃带的就有⻓连接选项，本身是也有⼼跳包机制，也就是 TCP 的选项：SO_KEEPALIVE 。 </li>
<li>但是，TCP 协议层⾯的⻓连接灵活性不够。所以，⼀般情况下我们都是在应⽤层协议上实现⾃定义⼼跳机制的，也就是在 Netty 层⾯通过编码实现。通过 Netty 实现⼼跳机制的话，核⼼类是 IdleStateHandler 。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Netty-线程模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:14:46" itemprop="dateCreated datePublished" datetime="2021-07-30T15:14:46+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>484</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>⼤部分⽹络框架都是基于 Reactor 模式设计开发的。</strong></p>
<p>Reactor 模式基于事件驱动，采⽤多路复⽤将事件分发给相应的 Handler 处理，⾮常适合处理海量 IO 的场景。</p>
<p>在 Netty 主要靠 NioEventLoopGroup 线程池来实现具体的线程模型的 。</p>
<p>我们实现服务端的时候，⼀般会初始化两个线程组：</p>
<ol>
<li>bossGroup :接收连接。</li>
<li>workerGroup ：负责具体的处理，交由对应的 Handler 处理。</li>
</ol>
<p>拥有一个Acceptor 专门用来监听请求的I&#x2F;O 类型<br>使用专门线程池可以提高acceptor的并发量，并且可以将同一个SocketChannel 放于同一个I&#x2F;O 线程处理，同一个I&#x2F;O线程可以处理多个SocketChannel的READ&#x2F;WRITE事件</p>
<p><strong>线程模型：</strong></p>
<p>⼀个 Acceptor 线程只负责监听客户端的连接，⼀个 NIO 线程池负责具体处理：</p>
<p><img src="https://i.loli.net/2021/08/04/cRva4kPzHwBpjOW.png" alt="image-20210804202010279"></p>
<p>从⼀个 <strong>主线程 NIO 线程池</strong>中选择⼀个线程作为 Acceptor 线程，绑定监听端⼝，接收客户端连接<br>的连接，<strong>其他线程负责后续的接⼊认证等⼯作</strong>。连接建⽴完成后，Sub NIO 线程池负责具体处理<br>I&#x2F;O 读写。</p>
<p><img src="https://i.loli.net/2021/08/04/TXCUqymgReK3oNW.png" alt="image-20210804202045874"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XieYi</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">263k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:59</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
