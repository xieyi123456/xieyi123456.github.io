<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"xieyi123456.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":true,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="think and do">
<meta property="og:type" content="website">
<meta property="og:title" content="XieYi&#39;s Blog">
<meta property="og:url" content="https://xieyi123456.github.io/page/4/index.html">
<meta property="og:site_name" content="XieYi&#39;s Blog">
<meta property="og:description" content="think and do">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XieYi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xieyi123456.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>XieYi's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="XieYi's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">XieYi's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">log something</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XieYi"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">XieYi</p>
  <div class="site-description" itemprop="description">think and do</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:2643100268@qq.com" title="E-Mail → mailto:2643100268@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Mysql-%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Mysql-%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">Mysql-架构与存储引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:11:06" itemprop="dateCreated datePublished" datetime="2021-07-30T15:11:06+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://i.loli.net/2021/08/04/AotCLWx597J4FnN.png" alt="image-20210804135513993"></p>
<h3 id="Mysql逻辑架构图主要分三层："><a href="#Mysql逻辑架构图主要分三层：" class="headerlink" title="Mysql逻辑架构图主要分三层："></a><strong>Mysql逻辑架构图主要分三层：</strong></h3><p>（1）第一层负责连接处理，授权认证，安全等等<br>（2）第二层负责编译并优化SQL<br>（3）第三层是存储引擎。</p>
<h3 id="sql语句执行流程"><a href="#sql语句执行流程" class="headerlink" title="sql语句执行流程"></a>sql语句执行流程</h3><ul>
<li><p>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p>
</li>
<li><p>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</p>
</li>
<li><p>MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_student A set A.age=&#x27;19&#x27; where A.name=&#x27; 张三 &#x27;;</span><br></pre></td></tr></table></figure>

<p>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，<strong>此时 redo log 进入 prepare 状态</strong>，然后告诉执行器，执行完成了，随时可以提交。<br><strong>执行器收到通知后记录 binlog，然后调用引擎接口</strong>，提交 redo log 为提交状态。<br>更新完成。</p>
</li>
</ul>
<p>为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<p><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p>
<p><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p>
<p>那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<p><strong>判断 redo log 是否完整，如果判断是完整的，就立即提交。</strong><br>如果 redo log 只是预提交但不是 commit 状态，<strong>这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</strong><br>这样就解决了数据一致性的问题。</p>
<p><strong>Server 层</strong>：主要包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。<br><strong>存储引擎</strong>： 主要<strong>负责数据的存储和读取</strong>，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</p>
<h2 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h2><h3 id="innodb-vs-myisam"><a href="#innodb-vs-myisam" class="headerlink" title="innodb vs myisam"></a>innodb vs myisam</h3><h4 id="是否支持行级锁"><a href="#是否支持行级锁" class="headerlink" title="是否支持行级锁"></a>是否支持行级锁</h4><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<h4 id="是否支持事务"><a href="#是否支持事务" class="headerlink" title="是否支持事务"></a>是否支持事务</h4><p>MyISAM 不提供事务支持。<br>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
<h4 id="是否支持外键"><a href="#是否支持外键" class="headerlink" title="是否支持外键"></a>是否支持外键</h4><p>MyISAM 不支持，而 InnoDB 支持。</p>
<h4 id="是否支持数据库异常崩溃后的安全恢复"><a href="#是否支持数据库异常崩溃后的安全恢复" class="headerlink" title="是否支持数据库异常崩溃后的安全恢复"></a>是否支持数据库异常崩溃后的安全恢复</h4><p>MyISAM 不支持，而 InnoDB 支持。<br>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <strong>redo log</strong> 。<br>MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。</p>
<p>MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。<br>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
<h4 id="是否支持-MVCC"><a href="#是否支持-MVCC" class="headerlink" title="是否支持 MVCC"></a>是否支持 MVCC</h4><p>MyISAM 不支持，而 InnoDB 支持。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Mysql-sql%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Mysql-sql%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Mysql-sql常见语法与优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:10:46" itemprop="dateCreated datePublished" datetime="2021-07-30T15:10:46+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="sql语法举例"><a href="#sql语法举例" class="headerlink" title="sql语法举例"></a>sql语法举例</h2><p>有一张表，三列：name,course(课程)，score，查询出每个学生的总成绩并按从高到低排序。</p>
<p>SELECT NAME,SUM(score) FROM chengji</p>
<p>GROUP BY NAME</p>
<p>ORDER BY SUM(score) DESC;</p>
<h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Select </span><br><span class="line">From</span><br><span class="line">Join on</span><br><span class="line">Where</span><br><span class="line">Group by</span><br><span class="line">Having</span><br><span class="line">Order by</span><br><span class="line">Limit</span><br></pre></td></tr></table></figure>



<h3 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h3><p><img src="https://i.loli.net/2021/08/04/1WtTkRxDCL96fSI.png" alt="image-20210804132616343">1,</p>
<p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,</span><br><span class="line">    population,</span><br><span class="line">    area</span><br><span class="line">FROM</span><br><span class="line">    World</span><br><span class="line">WHERE</span><br><span class="line">    area &gt; 3000000</span><br><span class="line">    OR population &gt; 25000000;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/04/V7tN63gewq8cWoz.png" alt="image-20210804132827111"></p>
<p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    *</span><br><span class="line">FROM</span><br><span class="line">    cinema</span><br><span class="line">WHERE</span><br><span class="line">    id % 2 = 1</span><br><span class="line">    AND description != &#x27;boring&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">    rating DESC;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/04/hAqr8muJgKMHdXl.png" alt="image-20210804132946054"></p>
<p>查找有五名及以上 student 的 class。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    class</span><br><span class="line">FROM</span><br><span class="line">    courses</span><br><span class="line">GROUP BY</span><br><span class="line">    class</span><br><span class="line">HAVING</span><br><span class="line">    count( DISTINCT student ) &gt;= 5;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/04/n2l8UXRjZWYgEVb.png" alt="image-20210804133126602"></p>
<p>重复的email。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    Email</span><br><span class="line">FROM</span><br><span class="line">    Person</span><br><span class="line">GROUP BY</span><br><span class="line">    Email</span><br><span class="line">HAVING</span><br><span class="line">    COUNT( * ) &gt;= 2;</span><br></pre></td></tr></table></figure>



<h3 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h3><p><img src="https://i.loli.net/2021/08/04/uiLUs7CpH4Bn1mq.png" alt="image-20210804133312954"></p>
<p>查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。</p>
<p>涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，<strong>因为要保留 Person 表中的信息</strong>，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，<strong>将 Person 表放在 LEFT JOIN 的左边。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    FirstName,</span><br><span class="line">    LastName,</span><br><span class="line">    City,</span><br><span class="line">    State</span><br><span class="line">FROM</span><br><span class="line">    Person P</span><br><span class="line">    LEFT JOIN Address A</span><br><span class="line">    ON P.PersonId = A.PersonId;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/04/VB8OXqrEd5FAUlb.png" alt="image-20210804133630796"></p>
<p>没有订单的客户信息？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    C.Name AS Customers</span><br><span class="line">FROM</span><br><span class="line">    Customers C</span><br><span class="line">    LEFT JOIN Orders O</span><br><span class="line">    ON C.Id = O.CustomerId</span><br><span class="line">WHERE</span><br><span class="line">    O.CustomerId IS NULL;</span><br><span class="line"> ----------------------------------------------------------------------------   </span><br><span class="line">SELECT</span><br><span class="line">    Name AS Customers</span><br><span class="line">FROM</span><br><span class="line">    Customers</span><br><span class="line">WHERE</span><br><span class="line">    Id NOT IN ( </span><br><span class="line">        SELECT CustomerId </span><br><span class="line">        FROM Orders </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/04/Jai1wMqE6ZLFjzu.png" alt="image-20210804133923061"></p>
<p>查找一个 Department 中收入最高者的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    D.NAME Department,</span><br><span class="line">    E.NAME Employee,</span><br><span class="line">    E.Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee E,</span><br><span class="line">    Department D,</span><br><span class="line">    ( SELECT DepartmentId, MAX( Salary ) Salary </span><br><span class="line">     FROM Employee </span><br><span class="line">     GROUP BY DepartmentId ) M</span><br><span class="line">WHERE</span><br><span class="line">    E.DepartmentId = D.Id</span><br><span class="line">    AND E.DepartmentId = M.DepartmentId</span><br><span class="line">    AND E.Salary = M.Salary;</span><br></pre></td></tr></table></figure>



<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>sql优化？</strong></p>
<p><strong>索引合理？</strong></p>
<p><strong>读写分离？</strong></p>
<p><strong>垂直分区？按照列</strong></p>
<p><strong>水平分区？</strong></p>
<p>1、*<em>查询SQL尽量不要使用select <em>，而是select具体字段</em></em></p>
<p>只取需要的字段，节省资源、减少网络开销。<br>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</p>
<p>2、<strong>如果知道查询结果只有一条或者只要最大&#x2F;最小一条记录，建议用limit 1</strong><br>Select  id，name  from employee wherename&#x3D;’jay’limit1;<br>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。<br>当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</p>
<p>3、<strong>应尽量避免在where子句中使用or来连接条件</strong><br>select * from userwhere userid&#x3D;1or age &#x3D;18<br>假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程：全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。</p>
<p>4、<strong>优化limit分页</strong><br>当<strong>偏移量特别大的时候，查询效率就变得低下</strong>。<br>当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。<br>&#x2F;&#x2F;方案一 ：返回上次查询的最大记录(偏移量)<br>Select id，name from employee where id&gt;10000 limit 10.<br>&#x2F;&#x2F;方案二：order by + 索引<br>Select id，name from employee order by id limit 10000，10</p>
<p>如果使用优化方案一，返回上次最大查询记录（偏移量），这样可以跳过偏移量，效率提升不少。<br>方案二使用order by+索引，也是可以提高查询效率的。</p>
<p>5、优化你的like语句<br>把%放前面，并不走索引。</p>
<p>6、<strong>使用where条件限定要查询的数据，避免返回多余的行</strong><br>查询某个用户是否是会员<br>select user Id from user where userId&#x3D;’userId’ and isVip&#x3D;’1’</p>
<p>7、<strong>尽量避免在索引列上使用mysql的内置函数</strong><br>索引列上使用mysql的内置函数，索引失效</p>
<p>8<strong>、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫描</strong><br>select * from user where age-1 &#x3D;10</p>
<p>9、Inner join 、left join、right join，<strong>优先使用Inner join，如果是left join，左边表结果尽量小</strong></p>
<p>10、应尽量<strong>避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</strong><br><strong>!&#x3D;和&lt;&gt;很可能会让索引失效</strong></p>
<p>11、<strong>使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则</strong><br>KEY idx_userid_age (userId,age&#96;) USING BTREE</p>
<p>&#x2F;&#x2F;符合最左匹配原则<br>select * from user where userid&#x3D;10 and age &#x3D;10；<br>&#x2F;&#x2F;符合最左匹配原则<br>select * from user where userid &#x3D;10;<br>当我们创建一个联合索引的时候，<strong>如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</strong><br>联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。</p>
<p>12、对查询进行优化，<strong>应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描</strong><br>select * from user where address &#x3D;’深圳’ order by age ;<br>alter table user add index idx_address_age (address,age)</p>
<p>13<strong>、在适当的时候，使用覆盖索引</strong><br>&#x2F;&#x2F;id为主键，name为普通索引，即覆盖索引登场了。<br>select id,name from user where userid like ‘%123%’;</p>
<p>14、<strong>慎用distinct关键字</strong><br>字段很多的时候使用，却会大大降低查询效率。<br>使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，过滤的过程会占用系统资源，cpu时间。</p>
<p>15、<strong>删除冗余和重复索引</strong></p>
<p>16、<strong>where子句中考虑使用默认值代替null</strong><br>如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件！&#x3D;，&gt;is null，is not null经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃的。</p>
<p>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</p>
<p>17、<strong>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</strong><br>连表越多，编译的时间和开销也就越大。<br>把连接表拆开成较小的几个执行，可读性更高。<br>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</p>
<p>18、<strong>索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段</strong><br>SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p>
<p>19、尽量避免向客户端返回过多数据量，为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉</p>
<p>20、<strong>使用explain 分析你SQL的计划</strong></p>
<h3 id="explain各个字段代表的意思"><a href="#explain各个字段代表的意思" class="headerlink" title="explain各个字段代表的意思"></a>explain各个字段代表的意思</h3><p>id ：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<p>select_type ：查询类型 或者是 其他操作类型</p>
<p>table ：正在访问哪个表</p>
<p>type ：访问的类型</p>
<p>possible_keys ：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到</p>
<p>key ：实际使用到的索引，如果为NULL，则没有使用索引</p>
<p>key_len ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</p>
<p>ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</p>
<p>rows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数</p>
<p>Extra ：包含不适合在其它列中显示但十分重要的额外信息</p>
<p><strong>id与table字段</strong><br>通过这两个字段可以完全判断出你的每一条SQL语句的执行顺序和表的查询顺序。<br>id相同，从上到下<br>id越大，优先级越高</p>
<p><strong>select_type字段</strong></p>
<p>主要是用于区别普通查询、联合查询、子查询等的复杂查询</p>
<p><strong>Type</strong></p>
<p>显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：<br><strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong></p>
<p>system &#x3D;表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。</p>
<p><strong>const</strong> &#x3D;表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</p>
<p><strong>eq_ref</strong> &#x3D;<strong>唯一性索引扫描</strong>，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。<br>SELECT * FROM student AS S JOIN stu_course AS SC ON  S.id&#x3D; SC.cid</p>
<p><strong>ref</strong> &#x3D;非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，<strong>它可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体。</p>
<p><strong>range(尽量保证)</strong>&#x3D; 只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。<strong>这种范围扫描索引扫描比全表扫描要好</strong>，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p>
<p><strong>index&#x3D;</strong> Full Index Scan，index与ALL区别为<strong>index类型只遍历索引树</strong>。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）。</p>
<p><strong>ALL</strong>&#x3D; Full Table Scan，将遍历全表以找到匹配的行。<br>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p><strong>extra</strong></p>
<p><img src="https://i.loli.net/2021/08/04/twSDImsCXHxWE2a.png" alt="image-20210804135035776"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">Java并发-并发容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:10:16" itemprop="dateCreated datePublished" datetime="2021-07-30T15:10:16+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:58" itemprop="dateModified" datetime="2023-07-11T23:32:58+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><h3 id="collections中有一些方法："><a href="#collections中有一些方法：" class="headerlink" title="collections中有一些方法："></a>collections中有一些方法：</h3><p>synchronizedlist：</p>
<p>synchronizedmap：</p>
<p>synchronizedcollection：</p>
<p>在遍历时容器发生了结构性变化，会报错。</p>
<h2 id="写时复制的的List和Set"><a href="#写时复制的的List和Set" class="headerlink" title="写时复制的的List和Set"></a>写时复制的的List和Set</h2><p>copyonwritearraylist</p>
<p>copyonwritearrayset</p>
<p>线程安全</p>
<p>迭代器不支持修改</p>
<p>每次修改时都会新建一个数组，复制进去。读都会访问原来的数组。</p>
<p>基于reentrantlock实现</p>
<p>不适合大数组</p>
<p><strong>适合大部分访问都是读的情况</strong></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>jdk以前concurrenthashmap是分段的数组+链表实现。<br>实现线程安全的方式：</p>
<p>1，在 JDK1.7 的时候， ConcurrentHashMap （分段锁）对整个桶数组进⾏了分割分段，每⼀把锁只锁容器其中⼀部分数据，<strong>多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率</strong>。<br>一个concurrenthashmap里面包含一个segment数组。一个segment包含一个hashentry数组。</p>
<p>核心：</p>
<p><strong>分段锁</strong></p>
<p><strong>读不需要锁</strong></p>
<p><img src="https://i.loli.net/2021/08/03/BJEfHT8bwkLeaMh.png" alt="image-20210803181948397"></p>
<p> 2，JDK1.8 的时候已经摒弃了 Segment 的概念，⽽是直接⽤ <strong>Node 数组+链表&#x2F;红⿊树</strong>的数据结构来实现，并发控制使⽤ synchronized 和 CAS 来操作。<br>synchronized只会锁定当前链表或者红黑树的首节点。效率大大提高。</p>
<h3 id="迭代器弱一致性？"><a href="#迭代器弱一致性？" class="headerlink" title="迭代器弱一致性？"></a>迭代器弱一致性？</h3><p>遍历时，内部元素变化发生在已经遍历过的部分，不会体现出来。</p>
<p><img src="https://i.loli.net/2021/08/03/zgxDwuEOSZrRkPV.png" alt="image-20210803182140097"></p>
<p>3，hashtable是同一把锁，全表锁。</p>
<h2 id="基于跳表的Map和Set"><a href="#基于跳表的Map和Set" class="headerlink" title="基于跳表的Map和Set"></a>基于跳表的Map和Set</h2><p>concurrentskiplistmap&#x3D;&#x3D;treemap</p>
<p>concurrentskiplistset&#x3D;&#x3D;treeset</p>
<p>跳表更加容易实现高效并发</p>
<p>没有使用锁，所有的操作都可以并发</p>
<p>他们的size（）方法复杂度为o（n），并且结果也不一定准确</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>基于链表+多层索引</p>
<p>类似二分查找</p>
<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p><strong>无锁非阻塞：不用锁，所有操作都可以立即执行，主要通过循环CAS实现并发安全。</strong></p>
<p><strong>阻塞队列：使用锁和条件。很多操作都要获得锁或者满足条件再返回。不满足或者未获得锁就会阻塞。</strong></p>
<p>都是弱一致性的。遍历时遍历过的内容改变了不会显示。</p>
<h4 id="无锁非阻塞并发队列："><a href="#无锁非阻塞并发队列：" class="headerlink" title="无锁非阻塞并发队列："></a>无锁非阻塞并发队列：</h4><p>concurrentlinkedqueue</p>
<p>cocurrentlinkeddeque</p>
<p>基于链表，没有大小限制</p>
<p>基于循环cas</p>
<h4 id="普通阻塞队列："><a href="#普通阻塞队列：" class="headerlink" title="普通阻塞队列："></a>普通阻塞队列：</h4><p>都实现了接口blockingqueue，在入队出队时可能会等待。</p>
<p><img src="https://i.loli.net/2021/08/03/T1prKxLjmhqob5s.png" alt="image-20210803184553784"></p>
<p>arrayblockingqueue循环数组</p>
<p>linkedblockingqueue单向链表</p>
<p>都是使用显示锁reentrantlock和显示条件condition实现的</p>
<h4 id="优先级阻塞队列："><a href="#优先级阻塞队列：" class="headerlink" title="优先级阻塞队列："></a>优先级阻塞队列：</h4><p>按照优先级出队。</p>
<h4 id="延时阻塞队列："><a href="#延时阻塞队列：" class="headerlink" title="延时阻塞队列："></a>延时阻塞队列：</h4><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB/" class="post-title-link" itemprop="url">Java并发-线程协作机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:09:54" itemprop="dateCreated datePublished" datetime="2021-07-30T15:09:54+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:58" itemprop="dateModified" datetime="2023-07-11T23:32:58+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h2><p>属于Object类中。</p>
<p>当条件不成立时，线程调用wait进入条件等待队列。</p>
<p>另一个线程修改了条件变量后调用notify，调用wait的线程唤醒后需要重新检查条件变量。</p>
<h2 id="显示条件"><a href="#显示条件" class="headerlink" title="显示条件"></a>显示条件</h2><p>sychronized：wait，notify</p>
<p>reentranlock：显式条件-condition接口：await，signal</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><h2 id="协作工具类"><a href="#协作工具类" class="headerlink" title="协作工具类"></a>协作工具类</h2><h3 id="读写锁reentrantreadwritelock"><a href="#读写锁reentrantreadwritelock" class="headerlink" title="读写锁reentrantreadwritelock"></a>读写锁reentrantreadwritelock</h3><p>读读是并行的。</p>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p><img src="https://i.loli.net/2021/08/03/Qdk7pGoAtMq1NmJ.png" alt="image-20210803205028306"></p>
<h3 id="信号量semaphore"><a href="#信号量semaphore" class="headerlink" title="信号量semaphore"></a>信号量semaphore</h3><p>信号量，用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源，可以用做流量控制，譬如数据库连接场景控制等；</p>
<p>Semaphore 的构造方法 Semaphore(int permits) 接收一个整型参数，表示可用的许可证数量，即<strong>最大并发数量</strong>，使用方法就是在线程里面首先调用 acquire 方法获取一个许可，使用完后接着调用 <strong>release 归还一个许可，</strong>还可以使用 <strong>tryAcquire 尝试获取许可</strong>。</p>
<h3 id="倒计时门栓countdownlatch"><a href="#倒计时门栓countdownlatch" class="headerlink" title="倒计时门栓countdownlatch"></a>倒计时门栓countdownlatch</h3><p>CountDownLatch <strong>允许 count 个线程阻塞在一个地方</strong>，直至所有线程的任务都执行完毕。</p>
<p>CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。</p>
<p>线程使用 <strong>countDown()</strong> 方法时,使用了tryReleaseShared方法以 CAS 的操作来<strong>减少 state</strong>,直至 state 为 0 。</p>
<p>当调用 <strong>await() 方法</strong>的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 <strong>await() 方法之后的语句不会被执行</strong>。然后，CountDownLatch 会自旋 CAS 判断 state &#x3D;&#x3D; 0，如果 state &#x3D;&#x3D; 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。</p>
<h4 id="CountDownLatch-的两种典型用法"><a href="#CountDownLatch-的两种典型用法" class="headerlink" title="CountDownLatch 的两种典型用法"></a>CountDownLatch 的两种典型用法</h4><p>1、某一线程在开始运行前等待 n 个线程执行完毕。</p>
<p>将 CountDownLatch 的计数器初始化为 n （new CountDownLatch(n)），每当一个任务线程执行完毕，就将计数器减 1 （countdownlatch.countDown()），当计数器的值变为 0 时，在 CountDownLatch 上 await() 的线程就会被唤醒。一个典型应用场景就是<strong>启动一个服务时，主线程需要等待多个组件加载完毕</strong>，之后再继续执行。</p>
<p>2、实现多个线程开始执行任务的<strong>最大并行性。</strong></p>
<p>注意是并行性，不是并发，强调的是<strong>多个线程在某一时刻同时开始执行</strong>。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 （new CountDownLatch(1)），多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。</p>
<h4 id="CountDownLatch-的不足"><a href="#CountDownLatch-的不足" class="headerlink" title="CountDownLatch 的不足"></a>CountDownLatch 的不足</h4><p>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p>
<h3 id="循环栅栏cyclicbarrier"><a href="#循环栅栏cyclicbarrier" class="headerlink" title="循环栅栏cyclicbarrier"></a>循环栅栏cyclicbarrier</h3><p>CountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的。</p>
<p>CyclicBarrier 的字面意思是<strong>可循环使用（Cyclic）的屏障（Barrier）</strong>。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p>CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 <strong>await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</strong></p>
<p>CyclicBarrier 内部通过一个 <strong>count 变量作为计数器</strong>，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<h4 id="CyclicBarrier-的应用场景"><a href="#CyclicBarrier-的应用场景" class="headerlink" title="CyclicBarrier 的应用场景"></a>CyclicBarrier 的应用场景</h4><p>CyclicBarrier 可以用于<strong>多线程计算数据，最后合并计算结果的应用场景</strong>。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>
<p>CyclicBarrier 还提供一个更高级的构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://i.loli.net/2021/08/03/OP6kMEHuTK14R89.png" alt="image-20210803210950957"></p>
<p>CountDownLatch 是计数器，<strong>只能使用一次</strong>，而 CyclicBarrier 的计数器提供 reset 功能，<strong>可以多次使用</strong>。</p>
<p>CountDownLatch: <strong>一个或者多个线程</strong>，等待<strong>其他多个线程完成某件事情之后</strong>才能执行；</p>
<p>CyclicBarrier : <strong>多个线程互相等待，直到到达同一个同步点，再继续一起执行。</strong></p>
<p>对于 CountDownLatch 来说，重点是“<strong>一个线程（多个线程）等待</strong>”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。</p>
<p>而对于 CyclicBarrier，重点是<strong>多个线程，在任意一个线程没有完成，所有的线程都必须等待。</strong></p>
<p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="https://i.loli.net/2021/08/05/vjqPYt4JX1xfGlk.png" alt="image-20210805141923139"></p>
<p>线程 1 往阻塞队列中添加元素，而线程 2 从阻塞队列中移除元素</p>
<p><strong>当阻塞队列是空时</strong>，从队列中获取元素的操作将会被阻塞。</p>
<p><strong>当阻塞队列是满时</strong>，从队列中添加元素的操作将会被阻塞。</p>
<p>试图从空的阻塞队列中获取元素的线程将会阻塞，直到其他的线程往空的队列插入新的元素，同样，试图往已满的阻塞队列添加新元素的线程同样也会阻塞，直到其他的线程从列中移除一个或多个元素或者完全清空队列后继续新增。</p>
<h3 id="为什么要用阻塞队列，有什么好处吗"><a href="#为什么要用阻塞队列，有什么好处吗" class="headerlink" title="为什么要用阻塞队列，有什么好处吗"></a>为什么要用阻塞队列，有什么好处吗</h3><p>在多线程领域：所谓阻塞，是指在某些情况下会<strong>挂起线程（即阻塞）</strong>，一旦条件满足，<strong>被挂起的线程又会自动被唤醒。</strong></p>
<p>好处是我们<strong>不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这些 BlockingQueue 都包办了。</strong></p>
<p>在 concurrent 包发布以前，多线程环境下，我们每个程序员都必须自己去实现这些细节，尤其还要兼顾效率和线程安全，这会给我们的程序带来不小的复杂性。</p>
<p>JDK 提供了 7 个阻塞队列。分别是</p>
<p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列<br>SynchronousQueue：一个不存储元素的阻塞队列<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列（实现了继承于 BlockingQueue的 TransferQueue）<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><img src="https://i.loli.net/2021/08/05/dv943bwnZLAeIKt.png" alt="image-20210805142222849"></p>
<h2 id="future-x2F-futuretask"><a href="#future-x2F-futuretask" class="headerlink" title="future&#x2F;futuretask"></a>future&#x2F;futuretask</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">Java并发-线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:08:57" itemprop="dateCreated datePublished" datetime="2021-07-30T15:08:57+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。 </li>
<li>提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。 </li>
<li>提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控</li>
</ul>
<h2 id="创建的两种方式"><a href="#创建的两种方式" class="headerlink" title="创建的两种方式"></a>创建的两种方式</h2><h3 id="实现-Runnable-接⼝和-Callable-接⼝的区别"><a href="#实现-Runnable-接⼝和-Callable-接⼝的区别" class="headerlink" title="实现 Runnable 接⼝和 Callable 接⼝的区别"></a>实现 Runnable 接⼝和 Callable 接⼝的区别</h3><p>Runnable ⾃ Java 1.0 以来⼀直存在，但 Callable 仅在 Java 1.5 中引⼊,⽬的就是为了来处理 Runnable 不⽀持的⽤例。</p>
<p>Runnable 接⼝<strong>不会返回结果或抛出检查异常</strong>，但是 Callable 接⼝可以。所以，如果任务不需要返回结果或抛出异常推荐使⽤ Runnable 接⼝，这样代码看起来会更加简洁。</p>
<p>⼯具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。<br>（ Executors.callable（Runnable task ）或 Executors.callable（Runnable task，Object resule）。</p>
<h3 id="执⾏-execute-⽅法和-submit-⽅法的区别是什么呢？"><a href="#执⾏-execute-⽅法和-submit-⽅法的区别是什么呢？" class="headerlink" title="执⾏ execute()⽅法和 submit()⽅法的区别是什么呢？"></a>执⾏ execute()⽅法和 submit()⽅法的区别是什么呢？</h3><ol>
<li>execute() ⽅法⽤于<strong>提交不需要返回值的任务</strong>，所以⽆法判断任务是否被线程池执⾏成功与否；</li>
<li>submit() ⽅法⽤于<strong>提交需要返回值的任务</strong>。线程池会<strong>返回⼀个 Future 类型的对象</strong>，通过这个 Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 <strong>get() ⽅法来获取返回值</strong>， <strong>get() ⽅法会阻塞当前线程直到任务完成</strong>，⽽使⽤ get（long timeout，TimeUnitunit）⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏完。</li>
</ol>
<p>《阿⾥巴巴 Java 开发⼿册》中强制线程池<strong>不允许使⽤ Executors 去创建，⽽是通ThreadPoolExecutor 的⽅式，</strong>这样的处理⽅式让写的同学更加明确线程池的运⾏规则，规避资源耗尽的⻛险。</p>
<p><strong>Executors 返回线程池对象的弊端如下：</strong></p>
<p>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的<strong>队列⻓度为Integer.MAX_VALUE</strong> ，可能堆积⼤量的请求，从⽽导致 OOM。<br>CachedThreadPool 和 ScheduledThreadPool ： 允许<strong>创建的线程数量为Integer.MAX_VALUE</strong> ，可能会创建⼤量线程，从⽽导致 OOM。</p>
<h3 id="创建线程池的方式："><a href="#创建线程池的方式：" class="headerlink" title="创建线程池的方式："></a>创建线程池的方式：</h3><ol>
<li>构造方法：new Threadpoolexecutor(七大参数)。</li>
<li>工具类：executors.new ….</li>
</ol>
<ul>
<li><strong>FixedThreadPool</strong> ： 该⽅法返回⼀个<strong>固定线程数量</strong>的线程池。该线程池中的线程数量始终不变。当有⼀个新的任务提交时，线程池中若有空闲线程，则⽴即执⾏。若没有，则新的任务会被暂存在⼀个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor</strong>： ⽅法返回⼀个<strong>只有⼀个线程的线程池</strong>。若多余⼀个任务被提交到该线程池，任务会被保存在⼀个任务队列中，待线程空闲，按先⼊先出的顺序执⾏队列中的任务。</li>
<li><strong>CachedThreadPool</strong>： (适合于<strong>负载不高，每个线程时间较短</strong>)该⽅法返回⼀个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在⼯作，⼜有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执⾏完毕后，将返回线程池进⾏复⽤。</li>
<li><strong>newScheduledThreadPool</strong>：创建一个以延迟或定时的方式来执行任务的线程池，工作队列为 DelayedWorkQueue。适用于<strong>需要多个后台线程执行周期任务</strong>。</li>
</ul>
<h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><p><img src="https://i.loli.net/2021/08/03/uW46RI2PSrstC8M.png" alt="image-20210803222327559"></p>
<p><strong>3 个最重要的参数：</strong></p>
<ul>
<li><strong>corePoolSize</strong> : 当线程池运行的线程少于 corePoolSize 时，将创建一个新线程来处理请求，即使其<br>他工作线程处于空闲状态，核⼼线程数线程数定义了最⼩可以同时运⾏的线程数量。</li>
<li><strong>maximumPoolSize</strong> : 当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数量变为最⼤线程数。</li>
<li><strong>workQueue</strong> : 当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到的话，新任务就会被存放在队列中。<br>其他常⻅参数:</li>
<li><strong>keepAliveTime</strong> :当线程池中的线程数量⼤于 corePoolSize 的时候，如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了keepAliveTime 才会被回收销毁；</li>
<li><strong>unit</strong> : keepAliveTime 参数的时间单位。</li>
<li><strong>threadFactory</strong> :executor 创建新线程的时候会⽤到。</li>
<li><strong>handler</strong> :饱和策略。</li>
</ul>
<h3 id="ThreadPoolExecutor-饱和策略定义"><a href="#ThreadPoolExecutor-饱和策略定义" class="headerlink" title="ThreadPoolExecutor 饱和策略定义:"></a>ThreadPoolExecutor 饱和策略定义:</h3><p> 如果当前<strong>同时运⾏的线程数量达到最⼤线程数量并且队列也已经被放满了任务时</strong>，   ThreadPoolTaskExecutor 定义⼀些策略:</p>
<ul>
<li><p>ThreadPoolExecutor.AbortPolicy ：抛出 RejectedExecutionException 来拒绝新任务的处理。</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy ：<strong>调⽤执⾏⾃⼰的线程运⾏任务</strong>。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应⽤程序可以承受此延迟并且你不能任务丢弃任何⼀个任务请求的话，你可以选择这个策略。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy ： 不处理新任务，直接丢弃掉。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy ： 此策略将<strong>丢弃最早的未处理的任务请求</strong>。</p>
</li>
</ul>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://i.loli.net/2021/08/03/md8cqo3w9B1KaLM.png" alt="image-20210803222534163"></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p><img src="https://i.loli.net/2021/08/03/3zusmt1HMqZ24D5.png" alt="image-20210803223448446"></p>
<h3 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h3><p>ctl 是一个<strong>打包两个概念字段的原子整数。</strong><br>1）workerCount：指示<strong>线程的有效数量</strong>；<br>2）runState：指示<strong>线程池的运行状态</strong>，有 RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED 等状态。<br>int 类型有 32 位，其中 ctl 的低 29 为用于表示 workerCount，高 3 位用于表示 runState，如下图所示。</p>
<p>这么设计的主要好处是将对 runState 和 workerCount 的操作<strong>封装成了一个原子操作</strong>。</p>
<p>runState 和 workerCount 是线程池正常运转中的 2 个最重要属性，线程池在某一时刻该做什么操作，取决于这 2个属性的值。</p>
<p>因此无论是查询还是修改，我们必须保证对这 2 个属性的操作是属于“同一时刻”的，也就是原子操作，否则就会出现错乱的情况。如果我们使用 2 个变量来分别存储，要保证原子性则需要额外进行加锁操作，这显然会带来额外的开销，而将这 2 个变量封装成 1 个 AtomicInteger 则不会带来额外的加锁开销，而且<strong>只需使用简单的位操作</strong>就能分别得到 runState 和 workerCount。</p>
<p>由于这个设计，workerCount 的上限 CAPACITY &#x3D; (1 &lt;&lt; 29) - 1，对应的二进制原码为：0001 1111 1111 1111 1111 1111 1111 1111（不用数了，29 个 1）。<br>通过 ctl 得到 runState，只需通过位操作：ctl &amp; <del>CAPACITY。<br>~（按位取反），于是“</del>CAPACITY”的值为：1110 0000 0000 0000 0000 0000 0000 0000，只有高 3 位为 1，与 ctl 进行 &amp; 操作，结果为 ctl 高 3 位的值，也就是 runState。</p>
<p>通过 ctl 得到 workerCount 则更简单了，只需通过位操作：c &amp; CAPACITY</p>
<h3 id="在我们实际使用中，线程池的大小配置多少合适？"><a href="#在我们实际使用中，线程池的大小配置多少合适？" class="headerlink" title="在我们实际使用中，线程池的大小配置多少合适？"></a>在我们实际使用中，线程池的大小配置多少合适？</h3><p>要想合理的配置线程池大小，首先我们需要区分任务是<strong>计算密集型还是 I&#x2F;O 密集型</strong>。</p>
<p>对于计算密集型，设置 线程数 &#x3D; <strong>CPU 数 + 1</strong>，通常能实现最优的利用率。</p>
<p>对于 I&#x2F;O 密集型，网上常见的说法是设置 线程数 &#x3D; <strong>CPU 数 * 2</strong> ，这个做法是可以的，但个人觉得不是最优的。</p>
<p>在我们日常的开发中，我们的任务几乎是离不开 I&#x2F;O 的，常见的网络 I&#x2F;O（RPC 调用）、磁盘 I&#x2F;O（数据库操作），并且 I&#x2F;O 的等待时间通常会占整个任务处理时间的很大一部分，在这种情况下，开启更多的线程可以让 CPU 得到更充分的使用，一个较合理的计算公式如下：<br>线程数 &#x3D; <strong>CPU 数 * CPU 利用率 * (任务等待时间 &#x2F; 任务计算时间 + 1)</strong></p>
<p>例如我们有个定时任务，部署在 4 核的服务器上，该任务有 100ms 在计算，900ms 在 I&#x2F;O 等待，则线程数约为：4 * 1 * (1 + 900 &#x2F; 100) &#x3D; 40 个。</p>
<p>当然，具体我们还要结合实际的使用场景来考虑。如果要求比较精确，可以通过压测来获取一个合理的值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">Java并发-常见关键字</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:08:44" itemprop="dateCreated datePublished" datetime="2021-07-30T15:08:44+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:58" itemprop="dateModified" datetime="2023-07-11T23:32:58+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>见《线程安全的机制》</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p>
<p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p>
<p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>
<p><strong>循环时间长开销很大。</strong><br><strong>只能保证一个共享变量的原子操作。</strong><br><strong>ABA问题。</strong></p>
<p><strong>如果CAS失败，会一直进行尝试</strong>。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
<p>如果值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。</p>
<p>Java并发包为了解决这个问题，提供了一个<strong>带有标记的原子引用类“AtomicStampedReference”，</strong>它可以通过<strong>控制变量值的版本</strong>来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="AQS-抽象队列同步器"><a href="#AQS-抽象队列同步器" class="headerlink" title="AQS-抽象队列同步器"></a>AQS-抽象队列同步器</h3><p><img src="https://i.loli.net/2021/08/03/ovkD8F5rExbgpBq.png" alt="image-20210803192200462"></p>
<p><strong>AQS 核心思想是，</strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<strong>如果被请求的共享资源被占用</strong>，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH(Craig,Landin,and Hagersten)队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将<strong>每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点</strong>（Node）来实现锁的分配。</p>
<p><img src="https://i.loli.net/2021/08/05/FMUxJCKm7Gkn8Hv.png" alt="image-20210805140155989"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><p>nt waitStatus：</p>
<p>1、<strong>CANCELLED</strong>，值为1 。场景：当该线程<strong>等待超时或者被中断，需要从同步队列中取消等待</strong>，则该线程被置1，即被取消（这里该线程在取消之前是等待状态）。节点进入了取消状态则不再变化；</p>
<p>2、<strong>SIGNAL</strong>，值为-1。场景：<strong>后继的节点处于等待状态</strong>，当前节点的线程如果释放了同步状态或者被取消（当前节点状态置为-1），将会通知后继节点，使后继节点的线程得以运行；</p>
<p>3、<strong>CONDITION</strong>，值为-2。场景：<strong>节点处于等待队列中，节点线程等待在Condition上，</strong>当其他线程对Condition调用了signal()方法后，该节点从等待队列中转移到同步队列中，加入到对同步状态的获取中；</p>
<p>4、<strong>PROPAGATE</strong>，值为-3。场景：表示<strong>下一次的共享状态会被无条件的传播下去</strong>；</p>
<p>5、<strong>INITIAL</strong>，值为0，初始状态。</p>
<h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><p><strong>AQS 定义两种资源共享方式</strong></p>
<h5 id="Exclusive（独占）"><a href="#Exclusive（独占）" class="headerlink" title="Exclusive（独占）"></a>Exclusive（独占）</h5><p><strong>只有一个线程能执行</strong>，如 ReentrantLock。又可分为公平锁和非公平锁，ReentrantLock 同时支持两种锁，下面以 ReentrantLock 对这两种锁的定义做介绍：</p>
<p>公平锁 ：<strong>按照线程在队列中的排队顺序，先到者先拿到锁</strong><br>非公平锁 ：当线程要获取锁时，先通过<strong>两次 CAS 操作去抢锁</strong>，如果没抢到，当前线程再加入到队列中等待唤醒。</p>
<p>ReentrantLock 默认采用<strong>非公平锁</strong>，<strong>因为考虑获得更好的性能</strong>，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p>
<p>非公平锁在<strong>调用 lock</strong> 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。<br>非公平锁<strong>在 CAS 失败后</strong>，和公平锁一样都会进入到 <strong>tryAcquire 方法</strong>，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），<strong>非公平锁会直接 CAS 抢锁</strong>，<strong>但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</strong></p>
<p>公平锁和非公平锁就这两点区别，<strong>如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</strong></p>
<p>相对来说，<strong>非公平锁会有更好的性能，因为它的吞吐量比较大</strong>。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h5 id="Share（共享）"><a href="#Share（共享）" class="headerlink" title="Share（共享）"></a>Share（共享）</h5><p>多个线程可同时执行，如Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 。</p>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的<strong>自定义同步器</strong>争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>Java实现锁有两种语法<strong>，一种是synchronized语句，另外一种是reentrantlock关键字</strong>。</p>
<h4 id="公平锁-x2F-非公平锁"><a href="#公平锁-x2F-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><p>公平锁指<strong>多个线程按照申请锁的顺序获得锁。</strong></p>
<p>非公平锁指多个线程获得锁的顺序不按照申请顺序。</p>
<p>Java reentranthlock通过构造函数来指定锁是公平还是非公平，默认是非公平锁，对于synchronized而言，也是一种非公平锁。</p>
<p><strong>非公平锁优点在于吞吐量比公平锁大。</strong></p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁又叫递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p>
<p>Synchronized也是一个可重入锁。</p>
<p>可重入锁的优点是可以一定程度避免死锁。</p>
<h4 id="独享锁-x2F-共享锁"><a href="#独享锁-x2F-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h4><p>独享锁是指该锁一次只能被一个线程所持有，共享锁可以被多个线程所持有。</p>
<p>Java reentrantlock是一个独享锁，但是对于lock的另一个实现readwritelock，其读锁是一个共享锁，写锁是一个独享锁。</p>
<p>对于synchronized是一个独享锁。</p>
<h4 id="互斥锁-x2F-读写锁"><a href="#互斥锁-x2F-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h4><p>互斥锁在Java中具体实现就是reentrantlock。</p>
<p>读写锁在Java中的具体实现就是readwritelock。</p>
<h4 id="乐观锁-x2F-悲观锁"><a href="#乐观锁-x2F-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h4><p>乐观锁和悲观锁不是指具体的锁类型，而是对于看待并发编程中加锁问题的角度。</p>
<p>悲观锁认为，对于一个数据的并发操作，一定会改变数据，即使实际上数据没被改变，但是也悲观的认为被改变的可能性比较大，一定要加锁，不加锁早晚要出问题。</p>
<p>乐观锁认为，对于一个数据的并发操作，是不会改变数据的，不加锁也不会出问题。</p>
<p>乐观锁指java中的无所编程，适合读操作非常多的场景。</p>
<p>悲观锁就是指java中，适合并发下写非常多的场景。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在java中，自旋锁是指尝试获取锁的线程不会立即阻塞，<strong>而是采用循环的方式去尝试获取锁</strong>，当循环条件被其他线程改变时，才能进入临界区。这样的好处是减少线程上下文切换的消耗，<strong>缺点是会消耗CPU。</strong></p>
<p>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。<strong>如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</strong></p>
<h4 id="偏向锁-x2F-轻量级锁-x2F-重量级锁"><a href="#偏向锁-x2F-轻量级锁-x2F-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><p>这三种锁，就是指锁的状态，针对synchronized。</p>
<p>偏向锁是<strong>指一段代码一直被一个线程所访问</strong>，那么理论上，这个线程会自动获取这个锁，并一直拥有这个锁，这样就降低了获取锁的代价。</p>
<p>轻量级锁是指当偏向锁的状态下，<strong>被另一个线程访问</strong>，偏向锁就会升级为<strong>轻量级锁</strong>，其他线程会通过自旋形式尝试获取锁，不会阻塞，提高效率。</p>
<p>重量级锁是指在轻量级锁的状态下，<strong>另一个线程虽然自旋</strong>，但不会一直持续下去，当自旋一定次数的时候还没有获取到锁的话，<strong>就会进入阻塞</strong>，该锁就会膨胀为重量级锁，重量级锁会让其他申请的线程陷入阻塞，降低性能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java并发-常见基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:08:27" itemprop="dateCreated datePublished" datetime="2021-07-30T15:08:27+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="线程与进程与协程"><a href="#线程与进程与协程" class="headerlink" title="线程与进程与协程"></a>线程与进程与协程</h3><p><strong>进程是程序的一次执行过程，是系统资源分配的基本单位</strong>。进程间基本上是独立的。</p>
<p>线程是更小的运行单位。线程是调度执行的基本单位。线程间极有可能相互影响。</p>
<p>多个线程可以共享同一块内存空间与系统资源（<strong>堆，方法区（元空间）</strong>），也有自己独立的<strong>程序计数器与虚拟机栈，本地方法栈</strong>。</p>
<p>线程的切换负担要小很多。也被称为轻量级的进程。</p>
<p>程序计数器：为了线程切换后可以恢复到正确的执行位置。<br>虚拟机栈：方法调用对应着栈帧，存储着局部变量表，操作数栈，常量池。方法调用执行完成对应着栈帧的入栈与出栈。–<strong>保证局部变量私有</strong>。<br>堆：最大的一块，存放对象。<br>方法区：已被<strong>加载的类信息，常量，静态变量</strong>等等。<br>上下文切换：cpu时间片切换。</p>
<p>一个java应用程序实际上至少有三个线程，<strong>main主线程，gc()垃圾回收机制的运行线程，异常处理线程。</strong></p>
<p><strong>线程分为两类：用户线程和守护线程</strong>。守护线程适用于服务用户线程的。<strong>用户线程结束，守护线程也就结束</strong>，所以守护线程是依赖于用户线程的。举个例子：java程序中，main是用户线程，垃圾回收就是守护线程。可以利用thread.setDaemon(true)将用户线程变成守护线程。</p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</strong></p>
<p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，<strong>只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>
<p>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？</p>
<p>实际上操作系统并不知道协程的存在，它只知道线程，因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</p>
<p><strong>在有大量IO操作业务的情况下，</strong>我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。</p>
<p>在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为<strong>异步调用</strong>的方式，并且协程只有在IO密集型的任务中才会发挥作用。</p>
<p>协程只有和异步IO结合起来才能发挥出最大的威力。</p>
<p><strong>线程的相关方法：</strong></p>
<p>sleep-</p>
<p>yield-让出cpu，当然实际情况得看调度器</p>
<p>join-调用join的线程会让其他线程等待他结束后再结束。</p>
<h4 id="sleep-与wait-方法的区别"><a href="#sleep-与wait-方法的区别" class="headerlink" title="sleep()与wait()方法的区别"></a>sleep()与wait()方法的区别</h4><ol>
<li>sleep方法不会释放锁，wait方法会释放。</li>
<li>都可以暂停线程。</li>
<li>wait用于线程交互，sleep用于暂停。</li>
<li>wait被调用后，线程不会自动苏醒（无超时等待），需要notify()。</li>
</ol>
<h4 id="java线程的状态"><a href="#java线程的状态" class="headerlink" title="java线程的状态"></a><strong>java线程的状态</strong></h4><ul>
<li><strong>new</strong>：线程创建，还没调用start方法。</li>
<li><strong>runnable</strong>：（操作系统中的就绪，运行）new–调用start–ready-<strong>-获得cpu时间片</strong>–running</li>
<li><strong>blocked</strong>：阻塞。调用同步方法，在没获取到锁的情况下会阻塞。</li>
<li><strong>waitting</strong>：等待其他线程做一些操作。wait</li>
<li><strong>time_waiting</strong>：超时等待。-wait，sleep，超时时间到后，进入runnable。</li>
<li><strong>terminated</strong>：线程执行完毕。</li>
</ul>
<p><strong>wait&#x2F;notify属于Object类。</strong></p>
<p><img src="https://i.loli.net/2021/08/03/BhDXCyWdjGSMvuR.png" alt="image-20210803151242958"></p>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p><strong>继承thread类</strong>，重写run（）方法，调用子类的start（）。</p>
<p>为什么调用的是start，执行的确是run?</p>
<p>start表示启动该线程，进入就绪状态，成为单独的执行流。操作系统会分配相关资源。</p>
<p>直接执行run就相当于执行main中的普通方法了，就不是多线程了。</p>
<p><strong>实现runnable接口</strong>，重写run，启动start。</p>
<p>java只支持单继承，因此引入runnable接口。</p>
<p><strong>通过 Callable 和 Future 创建线程。</strong>覆盖call（）方法。</p>
<p>可以获得任务执行返回值；</p>
<ol>
<li><strong>创建 Callable 接口的实现类</strong>，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 <strong>Callable 实现类的实例</strong>，使用 <strong>FutureTask 类来包装 Callable 对象</strong>，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 <strong>FutureTask 对象作为 Thread 对象的 target</strong> 创建并启动新线程。</li>
<li>调用 <strong>FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值</strong>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CallableThreadTest implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        CallableThreadTest ctt = new CallableThreadTest();  </span><br><span class="line">        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);  </span><br><span class="line">        for(int i = 0;i &lt; 100;i++)&#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  </span><br><span class="line">            if(i==20)&#123;  </span><br><span class="line">                new Thread(ft,&quot;有返回值的线程&quot;).start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;try&#123;  </span><br><span class="line">            System.out.println(&quot;子线程的返回值：&quot;+ft.get());  </span><br><span class="line">        &#125; catch (InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (ExecutionException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    @Override  </span><br><span class="line">    public Integer call() throws Exception&#123;  </span><br><span class="line">        int i = 0;  </span><br><span class="line">        for(;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过与Future的结合，可以实现利用Future来跟踪异步计算的结果。</p>
<p>JDK5.0新特性。需要借助Future接口的唯一实现类<strong>FutureTask</strong>辅助线程的对象创建和返回值获取（FutureTask还实现了Runnable接口），再创建Thread对象，将FutureTask类的对象作为构造器参数传入，完成线程的创建，最后调用start()方法完成线程启动。</p>
<p><strong>Runnable和Callable的区别：</strong></p>
<p>1、Callable规定的方法是call(),  Runnable规定的方法是run()<br>2、Callable的任务执行后可返回值，而Runnable的任务是不能返回值<br>3、call方法可以抛出异常，run方法不可以<br>4、运行Callable任务可以拿到一个Future对象，<strong>表示异步计算的结果。</strong>它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果</p>
<p><strong>使用线程池。</strong></p>
<p>使用线程池，提前创建好多个线程放入线程池中，使用时直接获取，使用完放回线程池中。可以做到提高响应速度（减少线程创建的时间）和降低资源消耗（可重复利用线程）。利用Executors工具类创建线程池，然后提供Runnable(excute())或Callable(submit())接口的实现类的对象，执行指定线程的操作。最后，关闭线程池shutdown()。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><h4 id="为什么会有内存屏障"><a href="#为什么会有内存屏障" class="headerlink" title="为什么会有内存屏障"></a>为什么会有内存屏障</h4><p>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显<strong>：不能实时的和内存发生信息交换</strong>，分在不同CPU执行的不同线程对同一个变量的缓存值不同。</p>
<p>用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是<strong>内存屏障</strong>，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。</p>
<h4 id="内存屏障是什么"><a href="#内存屏障是什么" class="headerlink" title="内存屏障是什么"></a>内存屏障是什么</h4><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即<strong>读屏障和写屏障。</strong></p>
<p><strong>内存屏障有两个作用：</strong></p>
<p>阻止屏障两侧的指令重排序；<br>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</p>
<p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；<br>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
<h4 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h4><p>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<p><strong>volatile语义中的内存屏障</strong></p>
<p>volatile的内存屏障策略非常严格保守，<strong>非常悲观</strong>：<br>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
<p><strong>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性</strong>。</p>
<h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><p>对于final域，编译器和CPU会遵循两个排序规则：</p>
<p>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；</p>
<p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</p>
<p>​	必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p>
<p>​	写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程&#x2F;CPU可见，并阻止重排序。</p>
<p>​	读final域：读final域前插入了LoadLoad屏障。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" class="post-title-link" itemprop="url">Java虚拟机-垃圾回收器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:07:42" itemprop="dateCreated datePublished" datetime="2021-07-30T15:07:42+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h4><p><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）<br>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。<br><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。<br>收集频率：相对于应用程序的执行，收集操作发生的频率。<br>内存占用：Java堆区所占的内存大小。<br>快速：一个对象从诞生到被回收所经历的时间。</p>
<p><strong>吞吐量、暂停时间、内存占用</strong>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，<strong>暂停时间的重要性日益凸显</strong>。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
<p>简单来说，主要抓住两点：<br><strong>吞吐量</strong><br><strong>暂停时间</strong></p>
<h4 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h4><p><strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p><strong>低暂停时间（低延迟）较好</strong>，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个<strong>交互式应用程序</strong>（就是和用户交互比较多的场景）。</p>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<p>因为如果选择以<strong>吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</strong><br>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。<br>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。</p>
<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间。</strong></p>
<p>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本<br>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布Parallel GC在JDK6之后成为HotSpot默认GC。<br>2012年，在JDK1.7u4版本中，G1可用。<br>2017年，<strong>JDK9中G1变成默认的垃圾收集器，以替代CMS。</strong><br>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。<br>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）<br>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。<br>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。<br><strong>2020年3月，JDK14发布。删除CMS垃圾回收器</strong>。扩展ZGC在macOS和Windows上的应用</p>
<p>7款经典的垃圾收集器<br><strong>串行回收器：Serial、Serial old</strong><br><strong>并行回收器：ParNew、Parallel Scavenge、Parallel old</strong><br><strong>并发回收器：CMS、G1</strong></p>
<p><img src="https://i.loli.net/2021/08/05/DeJERlKAhL34BoQ.png" alt="image-20210802151315089"></p>
<p><img src="https://i.loli.net/2021/08/05/9rHwzoCX1SKYuag.png" alt="image-20210802151245677"></p>
<p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合。</p>
<h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>串行的。</p>
<h3 id="Parnew"><a href="#Parnew" class="headerlink" title="Parnew"></a>Parnew</h3><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么<strong>ParNew收集器则是Serial收集器的多线程版本。</strong><br>Par是Parallel的缩写，New：只能处理新生代<br>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。<br>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p>对于新生代，回收次数频繁，<strong>使用并行方式高效</strong>。<br>对于老年代，回收次数少，<strong>使用串行方式节省资源</strong>。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
<p><strong>ParNew 回收器与 Serial 回收器比较</strong></p>
<p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p>
<p>A：不能<br>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。<br>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。<br><strong>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</strong></p>
<h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p>
<p><strong>那么Parallel收集器的出现是否多此一举？</strong></p>
<p>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量（Throughput）</strong>，它也被称为<strong>吞吐量优先的垃圾收集器。</strong></p>
<p><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别。（<strong>动态调整内存分配情况，以达到一个最优的吞吐量或低延迟</strong>）</p>
<p>高吞吐量则可以高效率地利用CPU时间，<strong>尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。</strong>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p>
<p>Parallel Old收集器采用了<strong>标记-压缩算</strong>法，但同样也是基于并行回收和”Stop-the-World”机制。</p>
<p>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。</p>
<p><strong>在Java8中，默认是此垃圾收集器。</strong></p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>在JDK1.5时期，Hotspot推出了一款在<strong>强交互应用</strong>中（就是和用户打交道的引用）几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></p>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
<p>CMS的垃圾收集算法采用<strong>标记-清除算法</strong>，并且也会”Stop-the-World”，不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），<strong>所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</strong><br>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
<p><img src="https://i.loli.net/2021/08/05/u6cqdol4AvgW8eK.png" alt="image-20210802151828157"></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p>
<p><strong>初始标记（Initial-Mark）阶段</strong>：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现<strong>短暂的暂停</strong>，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
<p><strong>并发标记（Concurrent-Mark）阶段</strong>：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
<p><strong>重新标记（Remark）阶段</strong>：由于在并发标记阶段中，<strong>程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间</strong>，因用户程序继续运作而<strong>导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。</p>
<p><strong>并发清除（Concurrent-Sweep）阶段</strong>：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
<p>CMS分析</p>
<p>尽管CMS收集器采用的是并发回收（非独占式），<strong>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长</strong>，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</p>
<p>由于<strong>最耗费时间的并发标记与并发清除阶段</strong>都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择<strong>空闲列表（Free List）执行内存分配。</strong></p>
<p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p>
<p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响。Mark Compact更适合“stop the world”这种场景下使用。</p>
<h4 id="CMS-的优点与弊端"><a href="#CMS-的优点与弊端" class="headerlink" title="CMS 的优点与弊端"></a>CMS 的优点与弊端</h4><p>优点</p>
<p><strong>并发收集</strong><br><strong>低延迟</strong></p>
<p>弊端</p>
<p><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</p>
<p>CMS收集器对<strong>CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。<br>CMS收集器<strong>无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1 回收器：<strong>区域化分代式</strong></p>
<p>应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。<br>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。<br>与此同时，<strong>为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</strong><br>官方给G1设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“全功能收集器”的重任与期望。</p>
<p>为什么名字叫**Garbage First(G1)**呢？</p>
<p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。<br>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。<strong>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</strong><br>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p>
<p>G1（Garbage-First）是一款<strong>面向服务端应用</strong>的垃圾收集器，主要针对配备<strong>多核CPU及大容量内存的机器</strong>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在JDK1.7版本正式启用，移除了Experimental的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。<br>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。G1在JDK8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。</p>
<h4 id="G1-回收器的优势"><a href="#G1-回收器的优势" class="headerlink" title="G1 回收器的优势"></a>G1 回收器的优势</h4><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<p><strong>1，并行与并发兼备</strong></p>
<p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW<br>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况<br><strong>2，分代收集</strong></p>
<p>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。<br>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。<br><strong>和之前的各类回收器不同，它同时兼顾年轻代和老年代。</strong>对比其他回收器，或者工作在年轻代，或者工作在老年代；</p>
<p><img src="https://i.loli.net/2021/08/05/KFNiqT1SUnylwGc.png" alt="image-20210802152854640"></p>
<p><strong>3，空间整合</strong><br>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</p>
<p>G1将内存划分为一个个的region。<strong>内存的回收是以region作为基本单位的</strong>。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<strong>尤其是当Java堆非常大的时候，G1的优势更加明显。</strong></p>
<p><strong>4，可预测的停顿时间模型（软实时soft real-time）</strong></p>
<p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，<strong>还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</strong></p>
<p>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p>
<p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
<h4 id="G1-回收器的缺点"><a href="#G1-回收器的缺点" class="headerlink" title="G1 回收器的缺点"></a>G1 回收器的缺点</h4><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是<strong>为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高</strong>。</p>
<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>
<h4 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h4><p>面向服务端应用，针对具有<strong>大内存、多处理器</strong>的机器。<br>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>
<p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</p>
<p>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：</p>
<p>超过50%的Java堆被活动数据占用；<br>对象分配频率或年代提升频率变化很大；<br>GC停顿时间过长（长于0.5至1秒）</p>
<p>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<p><strong>分区 Region：化整为零</strong></p>
<p>使用G1收集器时，它将整个Java堆划分成<strong>约2048个大小相同的独立Region块</strong>，每个Region块大小根据堆空间的实际大小而定，<strong>整体被控制在1MB到32MB之间</strong>，<strong>且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。</strong>可以通过XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
<p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色。</p>
<p>G1垃圾收集器还增加了一种新的内存区域，<strong>叫做Humongous内存区域</strong>，如图中的H块。主要用于存储大对象，<strong>如果超过0.5个Region，就放到H。</strong></p>
<p><img src="https://i.loli.net/2021/08/05/Drv4WB8nqwNjigm.png" alt="image-20210802153249024"></p>
<h4 id="设置-H-的原因"><a href="#设置-H-的原因" class="headerlink" title="设置 H 的原因"></a>设置 H 的原因</h4><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。</p>
<p>为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。<strong>G1的大多数行为都把H区作为老年代的一部分来看待。</strong></p>
<p><strong>每个Region都是通过指针碰撞来分配空间</strong></p>
<p>G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</p>
<h4 id="G1-GC的垃圾回收过程"><a href="#G1-GC的垃圾回收过程" class="headerlink" title="G1 GC的垃圾回收过程"></a>G1 GC的垃圾回收过程</h4><p>年轻代GC（Young GC）</p>
<p>老年代并发标记过程（Concurrent Marking）</p>
<p>混合回收（Mixed GC）<br>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；<strong>G1的年轻代收集阶段是一个并行的独占式收集器。</strong>在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p><strong>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</strong></p>
<p>标记完成马上开始<strong>混合回收过程</strong>。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
<h4 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h4><p>无论G1还是其他分代收集器，JVM都是使用<strong>Remembered Set来避免全堆扫描；</strong><br>每个Region都有一个对应的<strong>Remembered Set</strong><br>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；<br>然后检查<strong>将要写入的引用指向的对象是否和该Reference类型数据在不同的Region</strong>（其他收集器：检查老年代对象是否引用了新生代对象）；<br>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<br>当进行垃圾收集时，<strong>在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</strong></p>
<h4 id="G1回收过程一：年轻代-GC"><a href="#G1回收过程一：年轻代-GC" class="headerlink" title="G1回收过程一：年轻代 GC"></a>G1回收过程一：年轻代 GC</h4><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。<br>年轻代回收<strong>只回收Eden区和Survivor区</strong><br>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含<strong>年轻代Eden区和Survivor区所有的内存分段。</strong></p>
<p>第一阶段，<strong>扫描根</strong><br>根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p>第二阶段，<strong>更新RSet</strong></p>
<p>第三阶段，<strong>处理RSet</strong><br><strong>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</strong></p>
<p>第四阶段，<strong>复制对象。</strong><br>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象，如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<p>第五阶段，<strong>处理引用</strong><br>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。<strong>最终Eden空间的数据为空，GC停止工作</strong>，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h4 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h4><p><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</p>
<p><strong>根区域扫描（Root Region Scanning）</strong>：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</p>
<p><strong>并发标记（Concurrent Marking）</strong>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，<strong>会计算每个区域的对象活性（区域中存活对象的比例）。</strong></p>
<p><strong>再次标记（Remark）：</strong>由于应用程序持续进行，<strong>需要修正上一次的标记结果</strong>。是STW的。G1中采用了比CMS更快的原始快照算法：<strong>Snapshot-At-The-Beginning（SATB）。</strong></p>
<p><strong>独占清理（cleanup，STW）</strong>：<strong>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域</strong>。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</p>
<p><strong>并发清理阶段：</strong>识别并清理完全空闲的区域。</p>
<h4 id="G1回收过程三：混合回收过程"><a href="#G1回收过程三：混合回收过程" class="headerlink" title="G1回收过程三：混合回收过程"></a>G1回收过程三：混合回收过程</h4><p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，<strong>除了回收整个Young Region，还会回收一部分的Old Region。</strong>这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><strong>混合回收的细节</strong></p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】</p>
<p>混合回收的回收集（Collection Set）包括<strong>八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段</strong>。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收。</strong></p>
<p>并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%<strong>，意思是垃圾占内存分段比例要达到65%才会被回收</strong>。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，<strong>意思是允许整个堆内存中有10%的空间被浪费</strong>，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>
<h4 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h4><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p>
<p>导致G1 Full GC的原因可能有两个：<br><strong>EVacuation的时候没有足够的to-space来存放晋升的对象；</strong><br><strong>并发处理过程完成之前空间耗尽。</strong></p>
<p><strong>G1 回收器的优化建议</strong></p>
<p>年轻代大小<br>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。<strong>我们让G1自己去调整</strong></p>
<p><strong>暂停时间目标不要太过严苛</strong></p>
<p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间<br>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p>
<p><strong>第一步：开启G1垃圾收集器</strong><br><strong>第二步：设置堆的最大内存</strong><br><strong>第三步：设置最大的停顿时间</strong></p>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC?"></a>ZGC?</h3><p>ZGC收集器是一款<strong>基于Region内存布局</strong>的，（暂时）不设分代的，使用了<strong>读屏障、染色指针和内存多重映射</strong>等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p>
<p>ZGC几乎在所有地方并发执行的，<strong>除了初始标记的是STW的</strong>。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://i.loli.net/2021/08/05/haoOkViNCXmSW6Z.png" alt="image-20210802154953900"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Java虚拟机-垃圾回收算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:07:34" itemprop="dateCreated datePublished" datetime="2021-07-30T15:07:34+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="垃圾？"><a href="#垃圾？" class="headerlink" title="垃圾？"></a>垃圾？</h4><p>Java 和 C++语言的区别，就在于<strong>垃圾收集技术和内存动态分配</strong>上，C++语言没有垃圾收集技术，需要程序员手动的收集。</p>
<p><strong>什么是垃圾？</strong></p>
<p>垃圾是指在运行程序中<strong>没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p>
<h4 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h4><p>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而System.gc()调用附带一个免责声明，<strong>无法保证对垃圾收集器的调用(不能确保立即生效)</strong></p>
<p>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p><strong>内存溢出（OOM）原因分析</strong></p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：<br><strong>Java虚拟机的堆内存设置不够。</strong><br>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p>
<p><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</strong><br>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p>
<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。<br>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的<br>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p>
<h4 id="内存泄漏（leak）"><a href="#内存泄漏（leak）" class="headerlink" title="内存泄漏（leak）"></a>内存泄漏（leak）</h4><p>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，</strong>才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，<strong>但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食</strong>，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</p>
<p><strong>单例模式</strong><br>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<p><strong>一些提供close()的资源未关闭导致内存泄漏</strong><br>数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</p>
<h4 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h4><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？</p>
<p>分析工作必须在一个能确保一致性的快照中进行<br>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上<br>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</p>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
<p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
<p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</p>
<h4 id="安全点（Safepoint）"><a href="#安全点（Safepoint）" class="headerlink" title="安全点（Safepoint）"></a>安全点（Safepoint）</h4><p>程序执行时并非在所有地方都能停顿下来开始GC，<strong>只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</strong></p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：<strong>选择一些执行时间较长的指令作为Safe Point</strong>，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<p>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
<p>主动式中断：<strong>设置一个中断标志</strong>，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
<h4 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h4><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</p>
<p>例如<strong>线程处于Sleep状态或Blocked 状态</strong>，这时候线程无法响应JVM的中断请求，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。<br>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
<p>安全区域的执行流程</p>
<p>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程（开始GC）<br>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行用户线程，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>
<p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>
<p>强引用（Strong Reference）<br>软引用（Soft Reference）<br>弱引用（Weak Reference）<br>虚引用（Phantom Reference）<br>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用。</p>
<p><strong>强引用（StrongReference）</strong>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj&#x3D;new Object()”这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p><strong>软引用（SoftReference）</strong>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p>
<p><strong>弱引用（WeakReference）</strong>：被弱引用关联的对象<strong>只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</strong></p>
<p><strong>虚引用（PhantomReference）</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为<strong>一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p><strong>再谈引用：强引用</strong></p>
<p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>
<p>强引用具备以下特点：</p>
<p>强引用可以直接访问目标对象。<br>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。<br>强引用可能导致内存泄漏。</p>
<p><strong>再谈引用：软引用</strong><br>软引用（Soft Reference）：<strong>内存不足即回收</strong></p>
<p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</p>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p>
<p><strong>再谈引用：弱引用</strong><br>弱引用（Weak Reference）<strong>发现即回收</strong></p>
<p>弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>
<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>
<p>WeakHashMap？弱引用！</p>
<p><strong>再谈引用：虚引用</strong><br>虚引用（Phantom Reference）：<strong>对象回收跟踪</strong></p>
<p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。即通过虚引用无法获取到我们的数据</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>
<h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p><strong>标记阶段的目的</strong><br>垃圾标记阶段：主要是为了判断对象是否存活</p>
<p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。<br>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性</strong>。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。<br>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p><strong>缺点：</strong><br>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。<br>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。<br>引用计数器有一个严重的问题，即<strong>无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</strong></p>
<p><img src="https://i.loli.net/2021/08/05/gWaOJqmfQGdnPV6.png" alt="image-20210802142919765"></p>
<p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成<strong>内存泄漏。</strong></p>
<p><strong>小结：</strong></p>
<p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。<br>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。<br>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
<p>Python如何解决循环引用？<br>手动解除：很好理解，就是在合适的时机，解除引用关系。<br>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p>
<h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>可达性分析算法：也可以称为<strong>根搜索算法、追踪性垃圾收集</strong></p>
<p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。<br>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>
<p><strong>其基本思路如下：</strong></p>
<p>可达性分析算法是以<strong>根对象集合（GCRoots）</strong>为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。<br>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）<br>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。<br>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
<p>堆空间的周边，比如：<strong>虚拟机栈、本地方法栈、方法区、字符串常量池</strong>等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析。</p>
<h5 id="GCroots可以是什么？"><a href="#GCroots可以是什么？" class="headerlink" title="GCroots可以是什么？"></a>GCroots可以是什么？</h5><p>1，虚拟机栈中引用的对象：各个线程被调用方法中使用的参数局部变量。<br>2，本地方法中引用的对象。<br>3，静态属性的对象<br>4，常量池里的引用<br>5，被sychronized持有的对象<br>6，系统内部的引用，异常的类等等。</p>
<p>除了这些固定的GC Roots集合以外，根据<strong>用户所选用的垃圾收集器以及当前回收的内存区域不同</strong>，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集和局部回收（PartialGC）</strong>。</p>
<p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，<strong>这个区域的对象完全有可能被其他区域的对象所引用</strong>，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</p>
<p>如果要使用可达性分析算法来判断内存是否可回收，那么<strong>分析工作必须在一个能保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</p>
<p>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<h5 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h5><p>finalize() 方法机制<br>对象销毁前的回调函数：finalize()</p>
<p>Java语言提供了<strong>对象终止（finalization）机制</strong>来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>
<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<p>Object 类中 finalize() 源码<br>&#x2F;&#x2F; 等待被重写<br>protected void finalize() throws Throwable { }</p>
<p>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<br>在finalize()时可能会导致对象复活。<br>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。<br>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</p>
<p>从功能上来说，finalize()方法与C++中的<strong>析构函数</strong>比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。<br>finalize()方法对应了一个finalize线程，<strong>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</strong></p>
<p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“<strong>缓刑</strong>”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<br><strong>可触及的：</strong>从根节点开始，可以到达这个对象。<br><strong>可复活的：</strong>对象的所有引用都被释放，但是对象有可能在finalize()中复活。<br><strong>不可触及的：</strong>对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</p>
<p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h5 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a><strong>具体过程</strong></h5><p>判定一个对象objA是否可回收，至少要经历<strong>两次标记</strong>过程：</p>
<p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p>
<p>进行筛选，<strong>判断此对象是否有必要执行finalize()方法</strong><br>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</p>
<p>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到<strong>F-Queue队列</strong>中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</p>
<p>finalize()方法是<strong>对象逃脱死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</p>
<h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p><strong>执行过程</strong><br>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<br>标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</p>
<p>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p>
<h5 id="标记-清除算法的缺点"><a href="#标记-清除算法的缺点" class="headerlink" title="标记-清除算法的缺点"></a>标记-清除算法的缺点</h5><p>标记清除算法的效率不算高<br>在进行GC的时候，需要停止整个应用程序，用户体验较差（stw）<br>这种方式清理出来的空闲内存是不连续的，<strong>产生内碎片</strong>，需要维护一个空闲列表</p>
<h5 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h5><p>这里所谓的清除并不是真的置空，<strong>而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）</strong>。</p>
<p>关于空闲列表是在为对象分配内存的时候：<br><strong>如果内存规整，采用指针碰撞的方式进行内存分配</strong><br><strong>如果内存不规整，虚拟机需要维护一个空闲列表采用空闲列表分配内存</strong></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将活着的内存空间分为两块，<strong>每次只使用其中一块</strong>，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><strong>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区。</strong></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>没有标记和清除过程，实现简单，运行高效<br>复制过去以后保证空间的连续性，不会出现“碎片”问题。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>此算法的缺点也是很明显的，<strong>就是需要两倍的内存空间。</strong><br>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</p>
<p><strong>特别：</strong><br>如果系统中的垃圾对象很多，<strong>复制算法需要复制的存活对象数量太大，效率变低。</strong></p>
<p>在新生代，对象，朝生夕死，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<h4 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h4><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p>
<p>复制算法的高效性是建立在<strong>存活对象少、垃圾对象多</strong>的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。</p>
<p>标记-清除算法的确可以<strong>应用在老年代</strong>中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
<p>执行过程<br>第一阶段和标记清除算法一样，<strong>从根节点开始标记所有被引用对象</strong><br>第二阶段将<strong>所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</strong></p>
<h5 id="标记-压缩算法与标记-清除算法的比较"><a href="#标记-压缩算法与标记-清除算法的比较" class="headerlink" title="标记-压缩算法与标记-清除算法的比较"></a>标记-压缩算法与标记-清除算法的比较</h5><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩</strong>（Mark-Sweep-Compact）算法。</p>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p>
<p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，<strong>JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</strong></p>
<p><strong>优点</strong></p>
<p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。<br>消除了复制算法当中，内存减半的高额代价。</p>
<p><strong>缺点</strong></p>
<p>从效率上来说，<strong>标记-整理算法要低于复制算法。</strong><br><strong>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</strong>（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）<br>移动过程中，需要全程暂停用户应用程序。即：STW</p>
<p><img src="https://i.loli.net/2021/08/05/M7nHWifTIFvLU8o.png" alt="image-20210802144424767"></p>
<h3 id="分带收集算法"><a href="#分带收集算法" class="headerlink" title="分带收集算法"></a>分带收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，<strong>它们都具有自己独特的优势和特点。</strong>分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:<br>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</p>
<p>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。<br>目前几乎所有的GC都采用分代收集算法 执行垃圾回收的</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<p><strong>年轻代（Young Gen）</strong><br>年轻代特点：区域相对老年代较小，<strong>对象生命周期短、存活率低，回收频繁。</strong><br>这种情况<strong>复制算法的回收整理，速度是最快的。</strong>复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。<strong>而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</strong>。</p>
<p><strong>老年代（Tenured Gen）</strong><br>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。<br>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除或者是标记-清除与标记-整理的混合实现。</strong></p>
<p>Mark阶段的开销与<strong>存活对象的数量成正比。</strong>（遍历所有对象）<br>Sweep阶段的开销与所<strong>管理区域的大小成正相关</strong>。<br>Compact阶段的开销与<strong>存活对象的数量成正比。</strong></p>
<p>以HotSpot中的<strong>CMS回收器为例，CMS是基于Mark-Sweep实现的</strong>，对于对象的回收效率很高。对于碎片问题，CMS采用基于<strong>Mark-Compact算法的Serial Old回收器作为补偿措施</strong>：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></p>
<p>总的来说，增量收集算法的基础仍是<strong>传统的标记-清除和复制算法</strong>。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>
<p><strong>增量收集算法的缺点</strong><br>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。<strong>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</strong></p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p><strong>主要针对G1收集器来说的</strong></p>
<p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://i.loli.net/2021/08/05/iIkWjETN43rCoFX.png" alt="image-20210802144806782"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%8C%E5%A0%86%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%8C%E5%A0%86%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA/" class="post-title-link" itemprop="url">Java虚拟机-虚拟机栈，堆，方法区</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 15:07:16" itemprop="dateCreated datePublished" datetime="2021-07-30T15:07:16+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:57" itemprop="dateModified" datetime="2023-07-11T23:32:57+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="PC寄存器（程序计数器）"><a href="#PC寄存器（程序计数器）" class="headerlink" title="PC寄存器（程序计数器）"></a>PC寄存器（程序计数器）</h3><p>它是一块<strong>很小的内存空间</strong>，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</p>
<p>在JVM规范中，<strong>每个线程都有它自己的程序计数器</strong>，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>字节码解释器工作时就是<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令。</strong><br>它是唯一一个在Java虚拟机规范中<strong>没有规定任何OutofMemoryError情况的区域。没有垃圾回收。</strong></p>
<h4 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a><strong>PC寄存器的作用</strong></h4><p>PC寄存器用来<strong>存储指向下一条指令的地址</strong>，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p>
<p><strong>使用PC寄存器存储字节码指令地址有什么用呢？或者问为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。<br>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><strong>PC寄存器为什么被设定为私有的？</strong></p>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，<strong>最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</strong></p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>由于<strong>跨平台性</strong>的设计，Java的指令都是根据<strong>栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为<strong>基于寄存器</strong>的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。<br>优点是跨平台，指令集小，编译器容易实现，缺点是<strong>性能下降，实现同样的功能需要更多的指令。</strong></p>
<p><strong>内存中的栈与堆</strong><br>首先栈是运行时的单位，而堆是存储的单位。<br>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</p>
<p><strong>Java虚拟机栈是什么？</strong><br>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存<strong>一个个的栈帧（</strong>Stack Frame），<strong>对应着一次次的Java方法调用，栈是线程私有的</strong></p>
<p><strong>虚拟机栈的生命周期</strong></p>
<p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p>
<p><strong>虚拟机栈的作用</strong></p>
<p>主管Java程序的运行，它<strong>保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</strong><br>局部变量，它是相比于成员变量来说的（或属性）<br>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p>
<p><strong>虚拟机栈的特点</strong></p>
<p>栈是一种快速有效的分配存储方式，<strong>访问速度仅次于程序计数器。</strong><br>JVM直接对Java栈的操作只有两个：<br>每个方法执行，伴随着进栈（入栈、压栈）<br>执行结束后的出栈工作<br>对于栈来说不存在垃圾回收问题<br><strong>栈不需要GC，但是可能存在OOM</strong></p>
<h4 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h4><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<br>1，如果采用<strong>固定大小的Java虚拟机栈</strong>，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowErro</strong>r 异常。<br>2，如果Java虚拟机栈可以<strong>动态扩展，</strong>并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。<br>我们可以使用参数 -Xss 选项来设置<strong>线程的最大栈空间</strong>，栈的大小直接决定了<strong>函数调用的最大可达深度。</strong></p>
<h4 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h4><p>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在<br>在这个线程上正在执行的<strong>每个方法都各自对应一个栈帧</strong>（Stack Frame）。<br>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出（后进先出）原则。<br>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。<strong>即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。</strong>这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）<br>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。<br><strong>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</strong>。</p>
<p><img src="https://i.loli.net/2021/08/06/j8AtPN7dDumSIwV.png" alt="image-20210801231432286">1，不同线程中所包含的栈帧是<strong>不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。<br>2，如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，<strong>使得前一个栈帧重新成为当前栈帧。</strong><br>3，Java方法有两种返回函数的方式。<br>一种是正常的函数返回，使用return指令。<br>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。<br>但不管使用哪种方式，都会导致栈帧被弹出。</p>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p><img src="C:\Users\26431\AppData\Roaming\Typora\typora-user-images\image-20210806105335465.png" alt="image-20210806105335465"></p>
<p>每个栈帧中存储着：<br><strong>局部变量表</strong>（Local Variables）LV</p>
<p>1，局部变量表也被称之为<strong>局部变量数组或本地变量表</strong><br>2，定义为一个数字数组，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。<br>3，由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题<br>4，局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。<br>5，方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<br>对一个函数而言，<strong>它的参数和局部变量越多，使得局部变量表膨胀，</strong>它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。<br>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。<br>6，局部变量表中的变量<strong>只在当前方法调用中有效。</strong><br>在方法执行时，虚拟机通过使用局部变量表<strong>完成参数值到参数变量列表的传递过程。</strong><br>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<p><strong>关于Slot的理解</strong><br>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。<br><strong>局部变量表，最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。<br>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型占用两个slot（<strong>long和double 8字节</strong>）。<br>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true<br>long和double则占据两个slot</p>
<p>JVM会为局部变量表中的<strong>每一个Slot都分配一个访问索引</strong>，通过这个索引即可成功访问到局部变量表中指定的局部变量值<br>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上<br><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问long或double类型变量）<br>如果当前帧是由<strong>构造方法或者实例方法</strong>创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）<br><strong>静态方法中不可使用this，因为this方法变量不存在与当前方法的局部变量表中。</strong></p>
<p><strong>变量的分类：</strong></p>
<p>1、按照数据类型分：① 基本数据类型  ② 引用数据类型<br>2、按照在类中声明的位置分：<br>  2-1、成员变量：在使用前，都经历过默认初始化赋值<br>       2-1-1、类变量: linking的prepare阶段：给类变量默认赋值<br>              —&gt; initial阶段：给类变量显式赋值即静态代码块赋值<br>       2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值<br>  2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</p>
<p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。<br>我们知道成员变量有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。<br>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<p><strong>补充：</strong><br>在栈帧中，与性能调优关系最为密切的部分就是前面提到的<strong>局部变量表</strong>。在方法执行时，虚拟机使用局部变量表完成方法的传递。<br><strong>局部变量表中的变量也是重要的垃圾回收根节点</strong>，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<p><strong>Slot的重复利用</strong></p>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<p><strong>操作数栈</strong>（Operand Stack）（或表达式栈）</p>
<p><strong>操作数栈的特点</strong></p>
<p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）</p>
<p>操作数栈，<strong>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</strong><br>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，<br>比如：执行复制、交换、求和等操作</p>
<p><strong>操作数栈的作用</strong></p>
<p>操作数栈，主要用于<strong>保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong><br>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。<br>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。<br>栈中的任何一个元素都是可以任意的Java数据类型<br>32bit的类型占用一个栈单位深度<br>64bit的类型占用两个栈单位深度<br><strong>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。只不过操作数栈是用数组这个结构来实现的而已</strong><br>如果被调用的方法带有返回值的话，<strong>其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</strong><br>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。<br>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<p><strong>栈顶缓存技术</strong></p>
<p>Top Of Stack Cashing（tos）<br>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候<strong>必然需要使用更多的入栈和出栈指令</strong>，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了<strong>栈顶缓存（Tos，Top-of-Stack Cashing）技术</strong>，将<strong>栈顶元素全部缓存在物理CPU的寄存器中</strong>，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。<br>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p>
<p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p>
<p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用（</strong>Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是<strong>为了将这些符号引用转换为调用方法的直接引用</strong></p>
<p><strong>方法返回地址</strong>（Return Address）（或方法正常退出或者异常退出的定义）</p>
<p>存放<strong>调用该方法的pc寄存器的值。</strong></p>
<p>一个方法的结束，有两种方式：</p>
<p>正常执行完成<br>出现未处理的异常，非正常退出</p>
<p>无论通过哪种方式退出，在方法退出后<strong>都返回到该方法被调用的位置</strong>。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>本质上，方法的退出就是<strong>当前栈帧出栈的过程</strong>。此时，需要<strong>恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等</strong>，让调用者方法继续执行下去。<br>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<p><strong>一些附加信息</strong></p>
<p>并行每个线程下的<strong>栈都是私有的</strong>，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由<strong>局部变量表 和 操作数栈</strong>决定的</p>
<h4 id="OOM垃圾回收区域"><a href="#OOM垃圾回收区域" class="headerlink" title="OOM垃圾回收区域"></a>OOM垃圾回收区域</h4><p><img src="https://i.loli.net/2021/08/06/cFv9Y7izj52xyU4.png" alt="image-20210802104057341"></p>
<h4 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a>方法中定义的局部变量是否线程安全？</h4><p>如果只有一个线程才可以操作此数据，则必是线程安全的。<br>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。<br>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>一个运行时数据区只有一个堆和一个方法区。但是进程包含多个线程，他们是共享同一堆空间的。</strong></p>
<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。-Xms  -Xms </p>
<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。<br>所有的线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>（Thread Local Allocation Buffer，TLAB）。</p>
<p>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。<strong>因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</strong></p>
<p>数组和对象可能永远不会存储在栈上（不一定），因为栈帧中保存引用（局部变量表），这个引用指向对象或者数组在堆中的位置。</p>
<h4 id="堆详细组成"><a href="#堆详细组成" class="headerlink" title="堆详细组成"></a>堆详细组成</h4><p><img src="https://i.loli.net/2021/08/06/CUuzaty7VlhNKYx.png" alt="image-20210802104533244"></p>
<p>-Xms用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**<br>-Xmx则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</p>
<p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p>
<p><strong>通常会将-Xms和-Xmx两个参数配置相同的值</strong></p>
<p>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。<strong>频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</strong></p>
<p><strong>默认情况下:</strong><br>初始内存大小：物理电脑内存大小&#x2F;64<br>最大内存大小：物理电脑内存大小&#x2F;4</p>
<h4 id="堆的分区？"><a href="#堆的分区？" class="headerlink" title="堆的分区？"></a>堆的分区？</h4><p><strong>配置新生代与老年代在堆结构的占比</strong></p>
<p>默认**-XX:NewRatio**&#x3D;2，表示<strong>新生代占1，老年代占2</strong>，新生代占整个堆的1&#x2F;3</p>
<p>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是<strong>8 : 1 : 1</strong></p>
<p>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8</p>
<p><strong>几乎所有的Java对象都是在Eden区被new出来的。</strong></p>
<p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。<br>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p><strong>new的对象先放伊甸园区。</strong>此区有大小限制。</p>
<p>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（<strong>MinorGC</strong>），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</p>
<p>然后将伊甸园中的<strong>剩余对象移动到幸存者0区。</strong></p>
<p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。<br>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
<p>啥时候能去养老区呢？<strong>可以设置次数。默认是15次。</strong>可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**&#x3D;N 进行设置</p>
<p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：<strong>Major GC，进行养老区的内存清理</strong><br>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</p>
<p><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</strong><br><strong>幸存者s0，s1区，复制之后有交换，谁空谁是to</strong></p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>对象分配的特殊情况</p>
<p>1，如果来了一个新对象，先看看 Eden 是否放的下？<br>如果 Eden 放得下，则直接放到 Eden 区<br>如果 Eden 放不下，则<strong>触发 YGC</strong> ，执行垃圾回收，看看还能不能放下？</p>
<p>2，将对象放到老年区又有两种情况：<br>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，<strong>只能直接放到老年代</strong><br>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</p>
<p>3，如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，<strong>让他们直接晋升至老年区</strong></p>
<p><img src="https://i.loli.net/2021/08/06/J83YveI9lOK5HEU.png" alt="image-20210802105500931"></p>
<p>JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，而 <strong>Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong>。</p>
<p>JVM在进行GC时，并非每次都对上面三个内存区域（新生代，老年代：方法区（元空间））一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<br><strong>新生代收集（Minor GC&#x2F;Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</strong><br><strong>老年代收集（Major GC&#x2F;Old GC）：只是老年代的圾收集。</strong><br>目前，只有<strong>CMS GC会有单独收集老年代的行为</strong>。</p>
<p>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</p>
<p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为<br>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</p>
<h4 id="触发Full-GC执行的情况有如下五种："><a href="#触发Full-GC执行的情况有如下五种：" class="headerlink" title="触发Full GC执行的情况有如下五种："></a>触发Full GC执行的情况有如下五种：</h4><p>调用System.gc()时，系统建议执行FullGC，<strong>但是不必然执行</strong></p>
<p>老年代空间不足</p>
<p>方法区（元空间，永久代）空间不足</p>
<p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
<p>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<h4 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h4><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据<br>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的<br>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p><strong>TLAB（Thread Local Allocation Buffer）（buffer缓冲区）</strong></p>
<p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。<br>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，<strong>但JVM确实是将TLAB作为内存分配的首选。</strong><br>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</p>
<p>默认情况下，<strong>TLAB空间的内存非常小，仅占有整个Eden空间的1%，</strong>当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</p>
<h4 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h4><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：<br>随着JIT编译期的发展与逃逸分析技术逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果<strong>经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，<strong>将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</strong></p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。<br>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。<br>通过逃逸分析，Java Hotspot编译器能够<strong>分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</strong></p>
<p>逃逸分析的基本行为就是<strong>分析对象动态作用域：</strong></p>
<p>当一个对象在方法中被定义后，<strong>对象只在方法内部使用，则认为没有发生逃逸</strong>。<br>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p>
<p><strong>如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用</strong>。</p>
<h4 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h4><p>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗</strong>。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</p>
<p>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><img src="https://i.loli.net/2021/08/06/Vteg5IxdSWq3YzB.png" alt="image-20210802111019642"></p>
<p><strong>方法区可以看作是一块独立于Java堆的内存空间。</strong></p>
<p>方法区主要存放的是 <strong>Class</strong>，而堆中主要存放的是<strong>实例化的对象</strong></p>
<p>它用于存储已被虚拟机<strong>加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</strong></p>
<p><img src="https://i.loli.net/2021/08/06/pV7TD1gZ9F2G5Hf.png" alt="image-20210802111459872">方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</p>
<p>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。<br>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutofMemoryError:PermGen space或者java.lang.OutOfMemoryError:Metaspace</p>
<p>加载大量的第三方的jar包<br>Tomcat部署的工程过多（30~50个）<br>大量动态的生成反射类<br>关闭JVM就会释放这个区域的内存。</p>
<p><strong>类型信息</strong><br>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：<br>这个类型的完整有效名称（全名&#x3D;包名.类名）<br>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）<br>这个类型的修饰符（public，abstract，final的某个子集）<br>这个类型直接接口的一个有序列表</p>
<p><strong>域（Field）信息</strong><br>也就是我们常说的<strong>成员变量</strong>，域信息是比较官方的称呼<br>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。<br>域的相关信息包括：<strong>域名称，域类型，域修饰符</strong>（public，private，protected，static，final，volatile，transient的某个子集）</p>
<p><strong>方法（Method）信息</strong><br>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：<br>方法名称<br>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class<br>方法参数的数量和类型（按顺序）<br>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）<br>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）<br>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p>
<p><strong>non-final 类型的类变量</strong><br><strong>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</strong><br>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
<p><strong>全局常量：static final</strong><br>全局常量就是使用 static final 进行修饰<br>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。<br><strong>staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</strong></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池 VS 常量池</p>
<p>方法区，内部包含了运行时常量池<br><strong>字节码文件，内部包含了常量池。（</strong>之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）<br>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。<br>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</p>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a><strong>常量池</strong></h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p><strong>为什么需要常量池？</strong></p>
<p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。<strong>这个字节码包含了指向常量池的引用。</strong>在动态链接的时候会用到运行时常量池。<br> public class SimpleClass {<br>    public void sayHello() {<br>        System.out.println(“hello”);<br>    }<br>}<br>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。<br>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过引用的方式，来加载、调用所需的结构</p>
<p><strong>常量池总结</strong><br>常量池、可以看做是一张表，虚拟机指令<strong>根据这张常量表找到要执行的类名、方法名、参数类型、字面量</strong>等类型。</p>
<h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。<br>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。（运行时常量池就是常量池在程序运行时的称呼）</p>
<p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。<br>JVM为<strong>每个已加载的类型（类或接口）都维护一个常量池。</strong>池中的数据项像数组项一样，是通过索引访问的。<br>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<p>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性。</strong><br>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。<br>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</p>
<h4 id="演变"><a href="#演变" class="headerlink" title="演变"></a>演变</h4><p><img src="https://i.loli.net/2021/08/06/mRx7bBa6FAvY4VW.png"></p>
<p><img src="https://i.loli.net/2021/08/06/KRXj9QPzFIArn5V.png" alt="image-20210802112157518"></p>
<p><img src="https://i.loli.net/2021/08/06/sWImGdC3lBzveau.png" alt="image-20210802112217395"></p>
<h4 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h4><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被<strong>移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</strong></p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是<strong>系统可用内存空间</strong>。</p>
<p>这项改动是很有必要的，原因有：<br><strong>1，永久代设置空间大小是很难确定的。</strong>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。Exception in thread ‘dubbo client x.x connector’ java.lang.OutOfMemoryError:PermGen space而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<p><strong>2，对永久代进行调优是很困难的。</strong>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再用的类型</strong>，方法区的调优主要是为了降低Full GC</p>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>字符串常量池 StringTable 为什么要调整位置？<br>JDK7中将StringTable放到了堆空间中。因为<strong>永久代的回收效率很低</strong>，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。<br>这就导致StringTable回收效率不高，而我们<strong>开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</strong></p>
<h4 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h4><p><strong>对象实体在哪里放着？</strong><br>private static byte[] arr &#x3D; new byte[1024 * 1024 * 100];&#x2F;&#x2F;100MB<br>静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])<strong>始终都存在堆空间</strong>，</p>
<p>只是那个<strong>变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置</strong>中有所变化</p>
<p><strong>变量(名)存放在哪里？</strong></p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在<strong>方法区</strong>之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，存储于Java堆之中</p>
<h4 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h4><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型。</strong><br>先来说说方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong>。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而<strong>符号引用</strong>则属于编译原理方面的概念，包括下面三类常量：<br>类和接口的全限定名<br>字段的名称和描述符<br>方法的名称和描述符</p>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong><br>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
<p><strong>下面也称作类卸载</strong><br>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<p><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。<br><strong>加载该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。<br><strong>该类对应的java.lang.Class对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</p>
<p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，<strong>这里说的仅仅是“被允许”，</strong>而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</p>
<p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XieYi</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">263k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:59</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
