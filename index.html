<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"xieyi123456.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":true,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="think and do">
<meta property="og:type" content="website">
<meta property="og:title" content="XieYi&#39;s Blog">
<meta property="og:url" content="https://xieyi123456.github.io/index.html">
<meta property="og:site_name" content="XieYi&#39;s Blog">
<meta property="og:description" content="think and do">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XieYi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xieyi123456.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>XieYi's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="XieYi's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">XieYi's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">log something</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XieYi"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">XieYi</p>
  <div class="site-description" itemprop="description">think and do</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:2643100268@qq.com" title="E-Mail → mailto:2643100268@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2023/07/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">消息队列 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-11 01:50:24 / 修改时间：23:15:22" itemprop="dateCreated datePublished" datetime="2023-07-11T01:50:24+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2023/07/11/MySQL-%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/11/MySQL-%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">MySQL 进阶</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-11 01:50:08 / 修改时间：23:15:59" itemprop="dateCreated datePublished" datetime="2023-07-11T01:50:08+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2023/07/11/MySQL-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/11/MySQL-%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">MySQL 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-11 01:50:00 / 修改时间：23:15:49" itemprop="dateCreated datePublished" datetime="2023-07-11T01:50:00+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2023/07/11/golang-%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/11/golang-%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">golang 进阶</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-11 01:49:49 / 修改时间：23:15:40" itemprop="dateCreated datePublished" datetime="2023-07-11T01:49:49+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2023/07/11/golang-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/11/golang-%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">golang 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-11 01:49:43 / 修改时间：23:15:32" itemprop="dateCreated datePublished" datetime="2023-07-11T01:49:43+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2023/07/11/%E9%9A%8F%E4%BE%BF%E8%AE%B0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/11/%E9%9A%8F%E4%BE%BF%E8%AE%B0-1/" class="post-title-link" itemprop="url">随便记-1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-07-11 01:49:30 / 修改时间：23:15:07" itemprop="dateCreated datePublished" datetime="2023-07-11T01:49:30+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/09/%E4%B8%8B%E5%88%92%E7%BA%BF%E8%BD%AC%E9%A9%BC%E5%B3%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/%E4%B8%8B%E5%88%92%E7%BA%BF%E8%BD%AC%E9%A9%BC%E5%B3%B0/" class="post-title-link" itemprop="url">下划线转驼峰</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-09 13:21:33" itemprop="dateCreated datePublished" datetime="2021-08-09T13:21:33+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:56" itemprop="dateModified" datetime="2023-07-11T23:32:56+08:00">2023-07-11</time>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>759</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>举例：Hello_woRLD&#x3D;&#x3D;helloWorld</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static String camelName(String name) &#123;</span><br><span class="line">       StringBuilder result = new StringBuilder();</span><br><span class="line">       if (name == null || name.isEmpty()) &#123;</span><br><span class="line">           return &quot;&quot;;</span><br><span class="line">       &#125; else if (!name.contains(&quot;_&quot;)) &#123;</span><br><span class="line">           // 不含下划线，仅将首字母小写</span><br><span class="line">           return name.substring(0, 1).toLowerCase() + name.substring(1);</span><br><span class="line">       &#125;</span><br><span class="line">       // 用下划线将原始字符串分割</span><br><span class="line">       String camels[] = name.split(&quot;_&quot;);</span><br><span class="line">       for (String camel : camels) &#123;</span><br><span class="line">           // 跳过原始字符串中开头、结尾的下换线或双重下划线</span><br><span class="line">           if (camel.isEmpty()) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           // 处理真正的驼峰片段</span><br><span class="line">           if (result.length() == 0) &#123;</span><br><span class="line">               // 第一个驼峰片段，全部字母都小写</span><br><span class="line">               result.append(camel.toLowerCase());</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // 其他的驼峰片段，首字母大写</span><br><span class="line">               result.append(camel.substring(0, 1).toUpperCase());</span><br><span class="line">               result.append(camel.substring(1).toLowerCase());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/05/a-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/05/a-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">a-Linux常用命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-05 15:22:53" itemprop="dateCreated datePublished" datetime="2021-08-05T15:22:53+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:58" itemprop="dateModified" datetime="2023-07-11T23:32:58+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="使⽤两种命令创建⼀个⽂件？"><a href="#使⽤两种命令创建⼀个⽂件？" class="headerlink" title="使⽤两种命令创建⼀个⽂件？"></a>使⽤两种命令创建⼀个⽂件？</h3><p>a. touch a.txt</p>
<p>b. vi a.txt</p>
<p>c. mkdir abc</p>
<p>d. cat &gt; a.txt 建⽴⼀⽂件，然后把接下来的键盘输⼊写⼊⽂件，直到按Ctrl+D为⽌.</p>
<h3 id="linux常⽤命令有哪些？"><a href="#linux常⽤命令有哪些？" class="headerlink" title="linux常⽤命令有哪些？"></a>linux常⽤命令有哪些？</h3><p>查找关闭端⼝进程 netstat -nlp | grep :3306 kill pid</p>
<p>删除⽂件 rm -rf</p>
<p>查找⽇志 cat xx.log | grep ‘xxx’ | more</p>
<p>解压tar.gz tar -xzvf file.tar.gz</p>
<p>创建⽂件 touch filename cat &gt; filename</p>
<p>修改⽂件 vi</p>
<h3 id="怎么查看⼀个java线程的资源耗⽤？"><a href="#怎么查看⼀个java线程的资源耗⽤？" class="headerlink" title="怎么查看⼀个java线程的资源耗⽤？"></a>怎么查看⼀个java线程的资源耗⽤？</h3><p>linux下，所有的java内部线程，其实都对应了⼀个进程id，也就是说，linux上的jvm将java程序中的线程映射为操作系统进 程。</p>
<p>1、jps -lvm或者ps -ef | grep java查看当前机器上运⾏的Java应⽤进程</p>
<p>2、top -Hp pid可以查看Java所有线程的资源耗⽤</p>
<p>3、printf “%x\n”pid等到线程ID的16进制</p>
<p>4、jstack Java应⽤进程ID | grep 线程ID的16进制</p>
<h3 id="Load过⾼的可能性有哪些？"><a href="#Load过⾼的可能性有哪些？" class="headerlink" title="Load过⾼的可能性有哪些？"></a>Load过⾼的可能性有哪些？</h3><p>cpu load的飙升，⼀⽅⾯可能和full gc的次数增⼤有关，⼀⽅⾯可能和死循环有关系</p>
<h3 id="如何在log⽂件中搜索找出error的⽇志？"><a href="#如何在log⽂件中搜索找出error的⽇志？" class="headerlink" title="如何在log⽂件中搜索找出error的⽇志？"></a>如何在log⽂件中搜索找出error的⽇志？</h3><p>cat xx.log | grep ‘error’</p>
<h3 id="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件"><a href="#发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件" class="headerlink" title="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?"></a>发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?</h3><p>find . -type f -size +100M | xargs du -h | sort -nr</p>
<h3 id="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）？"><a href="#Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）？" class="headerlink" title="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）？"></a>Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）？</h3><p>a. 业务⽇志相关：</p>
<p>i. less或者moreii. grep</p>
<p>iii. tail -f filename</p>
<p>ps:切忌vim直接打开⼤⽇志⽂件，因为会直接加载到内存的</p>
<p>b. 数据库相关：</p>
<p>i. 登录线上库，show processlist查看数据库连接情况</p>
<p>c. jvm相关：</p>
<p>i. jps显示java进程</p>
<p>ii. jinfo实时查看和调整jvm参数</p>
<p>iii. jstat监控jvm各种运⾏状态信息；</p>
<p>iv. jstack(Stack Trace for Java)命令⽤于⽣成JVM进程当前时刻的线程的调⽤堆栈，可以⽤来定位线程间死锁、</p>
<p>锁等待、等待外部资源等</p>
<p>v. jmap(Memory Map for Java) 命令⽤于⽣成堆转储快照dump⽂件，除了这种⽅式还可以通过- XX:HeapDumpOnOutOfMemoryError参数，可以在虚拟机发⽣OOM的时候⾃动⽣成堆的dump⽂件，或者kill -3 命令发出进程退出信号”吓唬”⼀下虚拟机，也能拿到dump⽂件。</p>
<p>d. oom问题：</p>
<p>i. 配置了-XX:+HeapDumpOnOutOfMemoryError, 在发⽣OOM的时候会在-XX:HeapDumpPath⽣成堆的dump⽂件，结合MAT，可以对dump⽂件进⾏分析，查找出发⽣OOM的原因。</p>
<p>ii. 另外⼿动dump堆快照，可以使⽤命令jmap -dump:format&#x3D;b,file&#x3D;file_name pid 或者kill -3 pid</p>
<p>e. 死锁：</p>
<p>i. jps -v</p>
<p>ii. jstack -l pid</p>
<p>f. 线程block、线程数暴涨：</p>
<p>i. jstack -l pid |wc -l</p>
<p>ii. jstack -l pid |grep “BLOCKED”|wc -l</p>
<p>iii. jstack -l pid |grep “Waiting on condition”|wc -l</p>
<p>线程block问题⼀般是等待io、等待⽹络、等待监视器锁等造成，可能会导致请求超时、造成造成线程数暴涨导致系统502 等。</p>
<p>g. 服务器问题：</p>
<p>i. cpu：top</p>
<p>ii. 内存：</p>
<ol>
<li>free -m -c10 -s1：</li>
</ol>
<p>a. -m：以MB为单位显示，其他的有-k -g -b</p>
<p>b. -s: 间隔多少秒持续观察内存使⽤状况</p>
<p>c. -c:观察多少次</p>
<ol start="2">
<li>vmstat 1 10：1表示每隔1s输出⼀次,10 表示输出10次</li>
</ol>
<p>a. r: 运⾏队列中进程数量，这个值也可以判断是否需要增加CPU。（⻓期⼤于1）</p>
<p>b. b: 等待IO的进程数量。</p>
<p>h. io：</p>
<p>i. iostat -m 1 10：</p>
<ol>
<li>-m：某些使⽤block为单位的列强制使⽤MB为单位</li>
<li>1 10：数据显示每隔1秒刷新⼀次，共显示10次</li>
</ol>
<p>i. ⽹络：</p>
<p>i. netstat -antp：</p>
<ol>
<li><p>-a (all)显示所有选项，默认不显示LISTEN相关</p>
</li>
<li><p>-t (tcp)仅显示tcp相关选项</p>
</li>
<li><p>-u (udp)仅显示udp相关选项</p>
</li>
<li><p>-n 拒绝显示别名，能显示数字的全部转化成数字。</p>
</li>
<li><p>-l 仅列出有在 Listen (监听) 的服服务状态</p>
</li>
<li><p>-p 显示建⽴相关链接的程序名</p>
</li>
<li><p>Java常⽤问题排查⼯具及⽤法（top,iostat,vmstat,sar,tcpdump,jvisualvm,jmap,jconsole）</p>
</li>
<li><p>Thread dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）</p>
</li>
</ol>
<p>a. Thread Dump 能诊断的问题</p>
<p>i. 查找内存泄露，常⻅的是程序⾥load⼤量的数据到缓存；</p>
<p>ii. 发现死锁线程；</p>
<p>b. 如何抓取Thread Dump信息：</p>
<p>i. ⼀般当服务器挂起,崩溃或者性能底下时,就需要抓取服务器的线程堆栈(Thread Dump)⽤于后续的分析。 在实际 运⾏中，往往⼀次 dump的信息，还不⾜以确认问题。为了反映线程状态的动态变化，需要接连多次做 threaddump，每次间隔10-20s，建议⾄少产⽣三次 dump信息，如果每次 dump都指向同⼀个问题，我们才确 定问题的典型性。</p>
<p>ii. linux命令获取：</p>
<p>ps –ef | grep java</p>
<p>kill -&lt; pid &gt;</p>
<p>iii. jdk⾃带⼯具获取：</p>
<p>jps 或 ps –ef|grepjava (获取PID)</p>
<p>jstack [-l ]&lt; pid &gt;| tee -a jstack.log (获取ThreadDump)</p>
<h3 id="如何查看Java应⽤的线程信息？"><a href="#如何查看Java应⽤的线程信息？" class="headerlink" title="如何查看Java应⽤的线程信息？"></a>如何查看Java应⽤的线程信息？</h3><p>通过top命令拿到线程的pid后使⽤jstack命令</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/05/a%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/05/a%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">a设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-05 14:50:04" itemprop="dateCreated datePublished" datetime="2021-08-05T14:50:04+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:58" itemprop="dateModified" datetime="2023-07-11T23:32:58+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/top/" itemprop="url" rel="index"><span itemprop="name">top</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这些设计模式提供了一种在<strong>创建对象的同时隐藏创建逻辑的方式</strong>，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<p><strong>工厂模式（Factory Pattern）</strong><br><strong>抽象工厂模式（Abstract Factory Pattern）</strong><br><strong>单例模式（Singleton Pattern）</strong><br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这些设计模式关注<strong>类和对象的组合</strong>。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<p><strong>适配器模式（Adapter Pattern）</strong><br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br><strong>装饰器模式（Decorator Pattern）</strong><br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br><strong>代理模式（Proxy Pattern）</strong></p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这些设计模式特别关注<strong>对象之间的通信。</strong>	</p>
<p>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</p>
<h3 id="J2EE-模式"><a href="#J2EE-模式" class="headerlink" title="J2EE 模式"></a>J2EE 模式</h3><p>这些设计模式特别关注<strong>表示层</strong>。这些模式是由 Sun Java Center 鉴定的。	</p>
<p>MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br>服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</p>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>0、<strong>单一职责原则</strong>(Single Responsibility Principle)</p>
<p>单一职责原则表示一个模块的组成元素之间的功能相关性。从软件变化的角度来看，就一个类而言，应该仅有一个让它变化的原因；通俗地说，<strong>即一个类只负责一项职责。</strong></p>
<p>假设某个类 P 负责两个不同的职责，职责 P1 和 职责 P2，那么当职责 P1 需求发生改变而需要修改类 P，有可能会导致原来运行正常的职责 P2 功能发生故障。</p>
<p>1、<strong>开闭原则</strong>（Open Close Principle）</p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，<strong>是为了使程序的扩展性好，易于维护和升级</strong>。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p>2、<strong>里氏代换原则</strong>（Liskov Substitution Principle）</p>
<p>里氏代换原则是<strong>面向对象设计</strong>的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。</p>
<p>里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是<strong>抽象化</strong>，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>3、<strong>依赖倒转原则</strong>（Dependence Inversion Principle）</p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、<strong>接口隔离原则</strong>（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：<strong>降低类之间的耦合度。</strong></p>
<p>5、<strong>迪米特法则，又称最少知道原则</strong>（Demeter Principle）</p>
<p>最少知道原则是指：一个<strong>实体应当尽量少地与其他实体之间发生相互作用</strong>，使得系统功能模块相对独立。</p>
<p>6、<strong>合成复用原则（</strong>Composite Reuse Principle）</p>
<p>合成复用原则是指：<strong>尽量使用合成&#x2F;聚合的方式，而不是使用继承</strong>。</p>
<h2 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p>
<p>因为这个类只有一个实例，因此，自然不能让调用方使用new Xyz()来创建实例了。所以，单例的构造方法必须是private，这样就防止了调用方自己创建实例。</p>
<p>只有private构造方法，确保外部无法实例化；</p>
<p>通过private static变量持有唯一实例，<strong>保证全局唯一性；</strong></p>
<p>通过public static方法返回此唯一实例，<strong>使外部调用方能获取到实例。</strong></p>
<h4 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h4><p>是否 Lazy 初始化：是</p>
<p>是否多线程安全：否</p>
<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。</p>
<p>如果在多线程下，一个线程进入了if (singleton &#x3D;&#x3D; null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line"></span><br><span class="line">	public static Singleton getInstance() &#123;  </span><br><span class="line">	if (instance == null) &#123;  </span><br><span class="line">    instance = new Singleton();  </span><br><span class="line">	&#125;  </span><br><span class="line">	return instance;  </span><br><span class="line">	&#125;  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h4><p>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：<strong>第一次调用才初始化，避免内存浪费。</strong><br>缺点：<strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率</strong>。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>是否 Lazy 初始化：否</p>
<p>是否多线程安全：是</p>
<p>优点：这种写法比较简单，<strong>就是在类装载的时候就完成实例化</strong>。避免了线程同步问题。</p>
<p>缺点：在类装载的时候就完成实例化，<strong>没有达到Lazy Loading的效果</strong>。<strong>如果从始至终从未使用过这个实例，则会造成内存的浪费。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双检锁-x2F-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-x2F-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）"></a>双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）</h4><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>描述：</strong>我们进行了两次if (singleton &#x3D;&#x3D; null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton &#x3D;&#x3D; null)，直接return实例化对象。</p>
<p>优点：线程安全；延迟加载；效率较高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton uniqueInstance;</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getUniqueInstance()&#123;</span><br><span class="line">        if (uniqueInstance==null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if (uniqueInstance==null)&#123;</span><br><span class="line">                    uniqueInstance=new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>volatile修饰uniqueinstance的必要性：</p>
<p>uniqueinstance&#x3D;new singleton()；实际上分为3步。</p>
<ul>
<li>1，为uniqueinstance分配内存。</li>
<li>2，初始化uniqueinstance。</li>
<li>3，将uniqueinstance指向分配的内存地址。</li>
</ul>
<p>因此：</p>
<ul>
<li>代码读取到instance不为null时，instance引用的对象可能还没有完成初始化。</li>
<li><strong>防止指令重排。</strong></li>
</ul>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">private static class SingletonInstance &#123;</span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    return SingletonInstance.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了<strong>类装载的机制</strong>来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式<strong>在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</strong></p>
<p>复制代码<br>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p>
<p><strong>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性</strong>，在类进行初始化时，别的线程是无法进入的。</p>
<p>优点：避免了线程不安全，延迟加载，效率高。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。</p>
<p>优点<br>系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</p>
<p>缺点<br>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。</p>
<p>适用场合<br>需要频繁的进行创建和销毁的对象；<br>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；<br>工具类对象；<br>频繁访问数据库或文件的对象。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>工厂方法是指定义<strong>工厂接口和产品接口</strong>，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。</p>
<p>实际更常用的是更简单的<strong>静态工厂方法</strong>，它允许工厂内部对创建产品进行优化。</p>
<p>调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。</p>
<p><strong>Integer n &#x3D; Integer.valueOf(100);</strong></p>
<p>Integer既是产品又是静态工厂。它提供了静态方法valueOf()来创建Integer。那么这种方式和直接写new Integer(100)有何区别呢？我们观察valueOf()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Integer &#123;</span><br><span class="line">    public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>它的好处在于，valueOf()内部可能会使用new创建一个新的Integer实例，<strong>但也可能直接返回一个缓存的Integer实例。对于调用方来说，没必要知道Integer创建的细节。</strong></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，<strong>可以灵活的使用其中的一个算法。</strong></p>
<p>策略模式在Java标准库中应用非常广泛，Arrays.sort()：</p>
<p>我们观察Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)，这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们<strong>传入的Comparator对象</strong>，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。</p>
<p>因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，<strong>某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。</strong></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是String[]，但是需要List接口时，可以用一个Adapter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] exist = new String[] &#123;&quot;Good&quot;, &quot;morning&quot;, &quot;Bob&quot;, &quot;and&quot;, &quot;Alice&quot;&#125;;</span><br><span class="line">Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(exist));</span><br></pre></td></tr></table></figure>


<p>注意到List<T> Arrays.asList(T[])就相当于一个转换器，它可以把数组转换为List。</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</p>
<p><img src="https://i.loli.net/2021/08/05/MAzhEK9sGqicf3T.png" alt="image-20210805184859592"></p>
<p>最顶层的Component是接口，对应到IO的就是InputStream这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是FileInputStream、ServletInputStream这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是FilterInputStream。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是BufferedInputStream、GZIPInputStream等。</p>
<p>Decorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指FileInputStream这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如ByteInputStream。如果我们要增加附加功能，就增加Decorator的子类，例如CipherInputStream。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xieyi123456.github.io/2021/08/05/a-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XieYi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XieYi's Blog">
      <meta itemprop="description" content="think and do">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | XieYi's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/05/a-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">常见数据结构和算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-05 14:39:32" itemprop="dateCreated datePublished" datetime="2021-08-05T14:39:32+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 23:32:58" itemprop="dateModified" datetime="2023-07-11T23:32:58+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/top/" itemprop="url" rel="index"><span itemprop="name">top</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>42k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>39 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>根据数据访问的特点，可分为线性数据结构和非线性数据结构。</p>
<p>线性结构：数组、链表、栈、队列等。</p>
<p>非线性结构：散列表、树、堆、图等。</p>
<p><img src="https://i.loli.net/2021/08/20/sPgipbEXy4NtQZj.png" alt="image-20210820104323459"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。</p>
<p>数组中元素的存储是按照先后顺序进行的，<strong>同时在内存中也是按照这个顺序进行连续存放。</strong></p>
<p>数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。</p>
<p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比与线性数据表结构，操作复杂。</p>
<p>由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是<strong>查找一个节点或者访问特定编号的节点则需要O(n)的时间</strong>，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p>链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。</p>
<p>这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。</p>
<p>一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p>
<p><img src="https://i.loli.net/2021/08/20/MHYs3ytOh1wdNif.png" alt="image-20210820104600004"></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>跳表也叫跳跃表，是一种动态的数据结构。如果我们需要在有序链表中进行查找某个值，需要遍历整个链表，二分查找对链表不支持，二分查找的底层要求为数组，遍历整个链表的时间复杂度为O(n)。</p>
<p>我们可以<strong>把链表改造成B树、红黑树、AVL树等数据结构来提升查询效率</strong>，但是B树、红黑树、AVL树这些数据结构实现起来非常复杂，里面的细节也比较多。</p>
<p>跳表就是为了提升有序链表的查询速度产生的一种动态数据结构，跳表相对B树、红黑树、AVL树这些数据结构实现起来比较简单，但时间复杂度与B树、红黑树、AVL树这些数据结构不相上下，时间复杂度能够达到O(logn)。</p>
<p>跳表一般使用<strong>单链表来实现，这样比较节约空间</strong>。我使用双向链表来实现跳表，因为双向链表相对单向链表来说比较容易理解跳表的实现。</p>
<p>跳表的性质：</p>
<p>由很多层结构组成<br>每一层都是一个有序的链表<br>最底层(Level 1)的链表包含所有元素<br>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。<br>从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。</p>
<p><img src="https://i.loli.net/2021/08/20/3XwCZTpGfWFVg2d.png" alt="image-20210820104806454"></p>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>在二叉树的概念下又衍生出<strong>满二叉树和完全二叉树</strong>的概念</p>
<p><img src="https://i.loli.net/2021/08/20/WiLGwKbvPEm1StC.png" alt="image-20210820105029787"></p>
<p><strong>完全二叉树：</strong>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上（除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。</p>
<p><strong>满二叉树：</strong>若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边（除了最后一层，其它层的结点都有两个子结点）。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树又被称为AVL树，<strong>它是一棵二叉排序树</strong>，且具有以下性质：</p>
<p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</strong></p>
<p><strong>二叉排序树：</strong>是一棵空树，或者：</p>
<p><strong>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</strong></p>
<p><strong>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</strong></p>
<p>它的左、右子树也分别为二叉排序树。</p>
<p>树的高度：结点层次的最大值。</p>
<p><strong>二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。</strong></p>
<p> 平衡二叉树的产生是为了<strong>解决二叉排序树在插入时发生线性排列的现象</strong>。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p>
<h4 id="二叉树的遍历方式："><a href="#二叉树的遍历方式：" class="headerlink" title="二叉树的遍历方式："></a>二叉树的遍历方式：</h4><p>先序遍历：先根节点-&gt;遍历左子树-&gt;遍历右子树</p>
<p>中序遍历：遍历左子树-&gt;根节点-&gt;遍历右子树</p>
<p>后序遍历：遍历左子树-&gt;遍历右子树-&gt;根节点</p>
<h4 id="深度优先搜索（DFS）与广度优先搜索（BFS）"><a href="#深度优先搜索（DFS）与广度优先搜索（BFS）" class="headerlink" title="深度优先搜索（DFS）与广度优先搜索（BFS）"></a>深度优先搜索（DFS）与广度优先搜索（BFS）</h4><p>实现：</p>
<p><strong>bfs</strong>＝队列，入队列，出队列 一次访问一条路径；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue.add(root);</span><br><span class="line">   while (!queue.isEmpty())&#123;</span><br><span class="line">       int size=queue.size();</span><br><span class="line">       List&lt;Integer&gt; temp=new ArrayList&lt;&gt;();</span><br><span class="line">       for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">           TreeNode poll = queue.poll();</span><br><span class="line">           temp.add(poll.val);</span><br><span class="line">           if (poll.left!=null)queue.offer(poll.left);</span><br><span class="line">           if (poll.right!=null)queue.offer(poll.right);</span><br><span class="line">       &#125;</span><br><span class="line">       res.add(temp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>dfs</strong>&#x3D;栈，压栈，出栈 一次访问多条路径；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">public static void helper(TreeNode root,List&lt;Integer&gt;res) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    helper(root.left,res);</span><br><span class="line">    helper(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。这样出栈的时候才是中左右的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st.push(root);</span><br><span class="line">   while (!st.isEmpty()) &#123;</span><br><span class="line">       TreeNode node = st.pop();                       // 中 </span><br><span class="line">       result.add(node-&gt;val);</span><br><span class="line">       if (node.right) st.push(node.right);           // 右（空节点不入栈）</span><br><span class="line">       if (node.left) st.push(node.left);             // 左（空节点不入栈）</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>因为前序遍历的顺序是<strong>中左右</strong>，先访问的元素是中间节点，要处理的元素也是中间节点，所以才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p>
<p>那么再看看中序遍历，中序遍历是<strong>左中右</strong>，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p>
<p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode cur = root;</span><br><span class="line">     while (cur != NULL || !st.isEmpty()) &#123;</span><br><span class="line">         if (cur != NULL) &#123; // 指针来访问节点，访问到最底层</span><br><span class="line">             st.push(cur); // 将访问的节点放进栈</span><br><span class="line">             cur = cur.left;                // 左</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             cur = st.pop(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br><span class="line">             result.add(cur.val);     // 中</span><br><span class="line">             cur = cur.right;               // 右</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br></pre></td></tr></table></figure>

<p>​		1</p>
<p>​	2 	3</p>
<p>4	 5  6   7</p>
<p>1-2-4</p>
<p>再来看后序遍历，先序遍历是<strong>中左右</strong>，后续遍历是<strong>左右中</strong>，那么我们只需要调整一下先序遍历的代码顺序，就变成<strong>中右左</strong>的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了。</p>
<p>关系：</p>
<p>用DFS解决的问题都可以用BFS解决。<strong>DFS易于编写（递归）</strong>，时间消耗较少但是容易发生爆栈，而BFS可以控制队列的长度。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，<strong>其最坏的查找时间复杂度都是O(logN)<strong>。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，</strong>需要经过多次旋转实现复衡</strong>。这导致AVL的<strong>插入和删除</strong>效率并不高。</p>
<p>为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？红黑树可以解决。</p>
<p>红黑树具有五个特性：   </p>
<p>每个结点要么是红的要么是黑的。<br>根结点是黑的。<br>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。<br>如果一个结点是红的，那么它的两个儿子都是黑的。<br>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</p>
<p><img src="https://i.loli.net/2021/08/20/7TJMQVSFXtUiNBd.png" alt="image-20210820112252998"></p>
<p>红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。</p>
<p><img src="https://i.loli.net/2021/08/20/X5xm7lJnV92RusH.png" alt="image-20210820112333170"></p>
<h3 id="散列表（hash表）"><a href="#散列表（hash表）" class="headerlink" title="散列表（hash表）"></a>散列表（hash表）</h3><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。</p>
<p>散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，<strong>实现O(1)的数据访问效率</strong>。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。</p>
<p>确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。</p>
<p>冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p>
<p><strong>hash冲突：</strong></p>
<p><strong>开放地址法（也叫开放寻址法）</strong>：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的<strong>增列序量。</strong></p>
<p><strong>再哈希法：</strong>在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p>
<p><strong>链地址法：</strong>链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p>
<p><strong>公共溢出区：</strong>这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。目前比较<strong>常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。</strong></p>
<p>考虑到链表过长造成的问题，<strong>还可以使用红黑树替换链表进行冲突数据的处理操作</strong>，来提高散列表的查询稳定性。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树是一种多路搜索树，它的每个节点可以拥有多于两个孩子节点。M路的B树最多拥有M个孩子节点。</p>
<p><img src="https://i.loli.net/2021/08/20/k3M98f5eJFWzZjH.png" alt="image-20210820113238166"></p>
<p>文件系统和数据库的索引都是<strong>存在硬盘上的</strong>，并且如果数据量大的话，不一定能一次性加载到内存中</p>
<p>如果一棵树都无法一次性加载进内存，该怎么查找呢？</p>
<p>B树的多路存储的威力就在于此，<strong>可以每次加载B树的一个节点</strong>，然后，一步步往下找。</p>
<p>查找时候，每次载入一个节点进内存就行，<strong>如果在内存中，红黑树比B树效率更高，但是涉及到磁盘操作，B树就更优了。</strong></p>
<p>B+树是在B树基础上进行改造的，<strong>它的数据都在叶子节点</strong>，同时叶子节点之间还加了指针形成链表。</p>
<p>B+树在数据库的索引中用的比较多，如果数据库select数据，不一定只选一条，很多时候选多条，比如按照id排序后选10条。</p>
<p><strong>这样如果是多条的话，B树需要做局部的中序遍历，可能需要跨层访问，</strong>而B+树由于所有数据都在叶子节点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>
<p><strong>存储密度：顺序存储结构是一个一个挨着，基本上是一个空间对应一个数据；而链式存储由于每个结点都含有指针区域，故存储空间占用比较大，存储密度也就相对来说比较少。</strong></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它是不稳定排序。</p>
<p>堆的性质<br>① 是一棵完全二叉树<br>② 每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</p>
<p><img src="https://i.loli.net/2021/08/17/zhuLKPnZQDM6VIx.png" alt="image-20210817155031261"></p>
<p>一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)&#x2F;2；其左右子结点分别为 (2i + 1)、(2i + 2)</p>
<p><img src="https://i.loli.net/2021/08/16/FBkb4rJcL5S9IGy.png" alt="image-20210816150908734"></p>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p>a.将<strong>无序序列</strong>构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p>
<p>b.将堆顶元素与末尾元素交换，<strong>将最大元素”沉”到数组末端;</strong></p>
<p>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int[] nums = &#123;4, 10, 3, 6, 1, 2&#125;;</span><br><span class="line">       heapsort(nums, nums.length);</span><br><span class="line">       System.out.println(Arrays.toString(nums));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void heapsort(int[] tree, int n) &#123;</span><br><span class="line">       build_heap(tree, n);</span><br><span class="line">       for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">           swap(tree, i, 0);</span><br><span class="line">           heapify(tree, i, 0);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void build_heap(int[] nums, int n) &#123;</span><br><span class="line">       int last = n - 1;</span><br><span class="line">       int par = (last - 1) / 2;</span><br><span class="line">       for (int j = par; j &gt;= 0; j--) &#123;</span><br><span class="line">           heapify(nums, n, j);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void heapify(int[] nums, int n, int i) &#123;</span><br><span class="line">       if (i &gt;= n) return;</span><br><span class="line">       int c1 = 2 * i + 1;</span><br><span class="line">       int c2 = 2 * i + 2;</span><br><span class="line">       int max = i;</span><br><span class="line">       if (c1 &lt; n &amp;&amp; nums[c1] &gt; nums[max]) &#123;</span><br><span class="line">           max = c1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (c2 &lt; n &amp;&amp; nums[c2] &gt; nums[max]) &#123;</span><br><span class="line">           max = c2;</span><br><span class="line">       &#125;</span><br><span class="line">       if (max != i) &#123;</span><br><span class="line">           swap(nums, i, max);</span><br><span class="line">           heapify(nums, n, max);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>一.初始化建堆<br>　　初始化建堆只需要对二叉树的非叶子节点调用build_heap()函数，由下至上，由右至左选取非叶子节点来调用函数。那么倒数第二层的最右边的非叶子节点就是最后一个非叶子结点。<br>　　假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；高层也是这样逐渐递归。<br>　　那么总的时间计算为：s &#x3D; 2^( i - 1 ) * ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要下调比较的次数。<br>　　S &#x3D; 2^(k-2) * 1 + 2^(k-3)2…..+2(k-2)+2^(0)*(k-1) &#x3D;&#x3D;&#x3D;&gt; 因为叶子层不用交换，所以i从 k-1 开始到 1；<br>　　S &#x3D; 2^k -k -1；又因为k为完全二叉树的深度，而log(n) &#x3D;k，把此式带入；<br>　　得到：S &#x3D; n - log(n) -1，所以时间复杂度为：O(n)</p>
<p>二.排序重建堆<br>　　在取出堆顶点放到对应位置并把原堆的最后一个节点填充到堆顶点之后，需要对堆进行重建，只需要对堆的顶点调用heapify()函数。<br>　　每次重建意味着有一个节点出堆，所以需要将堆的容量减一。重建堆一共需要n-1次循环，每次循环的比较次数为log(i)，则相加为：log2+log3+…+log(n-1)+log(n)≈log(n!)。可以证明log(n!)和nlog(n)是同阶函数：<br>∵(n&#x2F;2)^n&#x2F;2≤n!≤n^n,∵(n&#x2F;2)^n&#x2F;2≤n!≤n^n,<br>∴n&#x2F;4log(n)&#x3D;n&#x2F;2log(n1&#x2F;2)≤n&#x2F;2log(n&#x2F;2)≤log(n!)≤nlog(n)∴n&#x2F;4log⁡(n)&#x3D;n&#x2F;2log⁡(n1&#x2F;2)≤n&#x2F;2log⁡(n&#x2F;2)≤log⁡(n!)≤nlog⁡(n)<br>　　所以时间复杂度为O(nlogn)</p>
<p>　　初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为**O(n+nlogn)&#x3D;O(nlogn)**。另外堆排序的比较次数和序列的初始状态有关，但只是在序列初始状态为堆的情况下比较次数显著减少，在序列有序或逆序的情况下比较次数不会发生明显变化。</p>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>选取基准值，左边小于其，右边大于其。左右子序列重复此过程。<br>大量数据时表现良好。<br>数据越乱表现越好。数据接近有序是退化成冒泡排序。<br>一种不稳定的排序方式。<br>也是一种交换排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] nums) &#123;</span><br><span class="line">    quicksort(nums, 0, nums.length - 1);</span><br><span class="line">    return nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void quicksort(int[] nums, int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right) return;</span><br><span class="line">    int pindex = partition(nums, left, right);</span><br><span class="line">    quicksort(nums, left, pindex - 1);</span><br><span class="line">    quicksort(nums, pindex + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    Random r = new Random();</span><br><span class="line">    int rindex = left + r.nextInt(right - left + 1);</span><br><span class="line">    swap(nums, rindex, left);</span><br><span class="line"></span><br><span class="line">    int pivot = nums[left];</span><br><span class="line">    int l = left;</span><br><span class="line">    for (int i = left + 1; i &lt;= right; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            swap(nums, i, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, l);</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次都选择最大（最小）的元素放在最前面，依次往后。<br>堆排序亦是选择排序：利用堆来选择数据。时间复杂度降低。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    int min = i;</span><br><span class="line">    for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">        if (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">            min = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, min, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>始终维持一个有序的队列。</p>
<p>元素越接近于稳定时，效率越高。<br>稳定的排序方式。<br>希尔排序是对直接插入排序的优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; len; i++) &#123;//第一个数有序</span><br><span class="line">    int temp=nums[i];</span><br><span class="line">    int j=i;</span><br><span class="line">    while (j&gt;0&amp;&amp;nums[j-1]&gt;temp)&#123;</span><br><span class="line">        nums[j]=nums[j-1];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>比较相邻两个值的大小，出现逆序就交换。<br>稳定的排序。<br>慢：每次只能移动相邻的两个数据。<br>一种交换排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; len; i++) &#123;//扫苗多少趟</span><br><span class="line">    for (int j = 0; j &lt; len-1; j++) &#123;</span><br><span class="line">        if (nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line">            swap(nums, j, j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治法的应用。<br>合并有序的子序列。<br>o(n)的空间复杂度。更多考虑解决磁盘外部排序的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] nums)&#123;</span><br><span class="line">    int[] temp=new int[nums.length];</span><br><span class="line">    mergesort(nums,0,nums.length-1,temp);</span><br><span class="line">    return nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void mergesort(int[] nums, int left, int right, int[] temp) &#123;</span><br><span class="line">    if (left&gt;=right)return;</span><br><span class="line">    int mid=left+(right-left)&gt;&gt;1;</span><br><span class="line">    mergesort(nums, left,mid,temp);</span><br><span class="line">    mergesort(nums,mid+1,right,temp);</span><br><span class="line">    //数组有序，不用merge</span><br><span class="line">    if (nums[mid]&lt;=nums[mid+1])&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    merge(nums,left,mid,right,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] nums, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line">    //System.arraycopy(nums,left,temp,left,right-left+1);</span><br><span class="line">    for (int i = left; i &lt;= right; i++) &#123;</span><br><span class="line">        temp[i]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //左右两半的起点</span><br><span class="line">    int i=left;</span><br><span class="line">    int j=mid+1;</span><br><span class="line">    for (int k = left; k &lt;= right; k++) &#123;</span><br><span class="line">        if (i==mid+1)nums[k]=temp[j++];</span><br><span class="line">        else if (j==right+1)nums[k]=temp[i++];</span><br><span class="line">        else if (temp[i]&lt;=temp[j])nums[k]=temp[i++];</span><br><span class="line">        else nums[k]=temp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>稳定性：相同数值的元素经过排序以后，相对的位置保持不变。</li>
<li>内部排序：数据全部放在内存中。</li>
<li>外部排序：内存装不下</li>
</ul>
<p><img src="https://i.loli.net/2021/08/05/ojG8w5gRxvYDzrB.png" alt="image-20210805144637116"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><blockquote>
<p>深度优先便利–广度优先遍历</p>
</blockquote>
<blockquote>
<p>前序：preorder根-左-右</p>
</blockquote>
<blockquote>
<p>中序：inorder左-根-右</p>
</blockquote>
<blockquote>
<p>后序：postorder左-右-根</p>
</blockquote>
<blockquote>
<p>层序：levelorder</p>
</blockquote>
<ul>
<li>前序遍历</li>
<li>递归</li>
<li>迭代</li>
<li>中序遍历</li>
<li>递归</li>
<li>迭代</li>
<li>后序遍历</li>
<li>递归</li>
<li>迭代</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//递归版本</span><br><span class="line">public static List&lt;Integer&gt; preorder2(TreeNode root)&#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    helper(root,res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">public static void helper(TreeNode root,List&lt;Integer&gt;res) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    helper(root.left,res);</span><br><span class="line">    helper(root.right,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void preorder(TreeNode root)&#123;</span><br><span class="line">    if (root==null)return;</span><br><span class="line">    System.out.print(root.val+&quot; &quot;);</span><br><span class="line">    preorder(root.left);</span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line">//迭代统一写法</span><br><span class="line">public static List&lt;Integer&gt; preorder3(TreeNode root)&#123;</span><br><span class="line">    List&lt;Integer&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    if (root==null)return res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while (!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode top = stack.peek();</span><br><span class="line">        if (top!=null)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            if (top.right!=null)stack.push(top.right);</span><br><span class="line">            if (top.left!=null)stack.push(top.left);</span><br><span class="line">            stack.push(top);</span><br><span class="line">            stack.push(null);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            TreeNode pop = stack.pop();</span><br><span class="line">            res.add(pop.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; levelorder(TreeNode root)&#123;</span><br><span class="line">    if (root==null)return null;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty())&#123;</span><br><span class="line">        int size=queue.size();</span><br><span class="line">        List&lt;Integer&gt; temp=new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode poll = queue.poll();</span><br><span class="line">            temp.add(poll.val);</span><br><span class="line">            if (poll.left!=null)queue.offer(poll.left);</span><br><span class="line">            if (poll.right!=null)queue.offer(poll.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>右视图-只需要判断一下是否是最后一个。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">    TreeNode node = queue.poll();</span><br><span class="line">    if (node.left != null) queue.offer(node.left);</span><br><span class="line">    if (node.right != null) queue.offer(node.right);</span><br><span class="line">    if (i == size - 1)  //将当前层的最后一个节点放入结果列表</span><br><span class="line">        res.add(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="n叉数层序遍历"><a href="#n叉数层序遍历" class="headerlink" title="n叉数层序遍历"></a>n叉数层序遍历</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Node&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">    if (root == null) return res;</span><br><span class="line">    que.offer(root);</span><br><span class="line">    while (!que.isEmpty()) &#123;</span><br><span class="line">        int size = que.size();</span><br><span class="line">        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            Node poll = que.poll();</span><br><span class="line">            temp.add(poll.val);</span><br><span class="line"></span><br><span class="line">            List&lt;Node&gt; children = poll.children;</span><br><span class="line">            if (children == null || children.size() == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (Node child : children) &#123;</span><br><span class="line">                if (child != null) que.offer(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; children;</span><br><span class="line">    public Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="锯齿形层序遍历"><a href="#锯齿形层序遍历" class="headerlink" title="锯齿形层序遍历"></a>锯齿形层序遍历</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * z字形遍历-偶数层倒序遍历</span><br><span class="line"> * @param root</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        // 该层的节点数量</span><br><span class="line">        int size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            // 根据层次来判断顺序</span><br><span class="line">            if (result.size() % 2 == 0) &#123;</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp.add(0, node.val);//插到最前面</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left != null) queue.add(node.left);</span><br><span class="line">            if (node.right != null)queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>理解使用队列进行层序遍历的本质。</li>
<li>z字形遍历时，result.size一开始是0，第二层时为1，所以奇数时插到前面。</li>
</ul>
<h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    return helper(root,p,q);</span><br><span class="line">&#125;</span><br><span class="line">private static TreeNode helper(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    if (root==null||root==p||root==q)return root;</span><br><span class="line">    TreeNode left=helper(root.left,p,q);</span><br><span class="line">    TreeNode right=helper(root.right,p,q);</span><br><span class="line">    if (left!=null&amp;&amp;right!=null)return root;</span><br><span class="line">    if (left==null)return right;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两节点最近路径"><a href="#两节点最近路径" class="headerlink" title="两节点最近路径"></a>两节点最近路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findDistance(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    if (p == q) &#123;</span><br><span class="line">        return new ArrayList&lt;&gt;(p.val);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; list1 = findPath(root, p);</span><br><span class="line">    List&lt;TreeNode&gt; list2 = findPath(root, q);</span><br><span class="line"></span><br><span class="line">    //单独考虑在同一条路径的情况</span><br><span class="line">    if (list1.containsAll(list2) || list2.containsAll(list1)) &#123;</span><br><span class="line">        int max = Math.max(list1.size(), list2.size());</span><br><span class="line">        List&lt;TreeNode&gt; llist = list1.size() == max ? list1 : list2;</span><br><span class="line">        List&lt;TreeNode&gt; slist = list1.size() == max ? list2 : list1;</span><br><span class="line">        for (int i = 0; i &lt; slist.size(); i++) &#123;</span><br><span class="line">            System.out.print(slist.get(i).val+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int i = 0; i &lt; llist.size(); i++) &#123;</span><br><span class="line">            System.out.print(llist.get(i).val+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = slist.size()-1; i &lt; llist.size(); i++) &#123;</span><br><span class="line">            res.add(llist.get(i).val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //去重</span><br><span class="line">        int lastSame = 0;</span><br><span class="line">        for (int i = 0; i &lt; list1.size(); i++) &#123;</span><br><span class="line">            if (list1.get(i) == list2.get(i)) &#123;</span><br><span class="line">                lastSame = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = list1.size() - 1; i &gt; lastSame; i--) &#123;</span><br><span class="line">            res.add(list1.get(i).val);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = lastSame; i &lt; list2.size(); i++) &#123;</span><br><span class="line">            res.add(list2.get(i).val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static List&lt;TreeNode&gt; findPath(TreeNode root, TreeNode node) &#123;</span><br><span class="line">    List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    getPathFromRoot(root, node, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean getPathFromRoot(TreeNode root, TreeNode node, List&lt;TreeNode&gt; pathArray) &#123;</span><br><span class="line">    if (root == null || node == null) return false;</span><br><span class="line">    pathArray.add(root);</span><br><span class="line">    if (root == node) return true;</span><br><span class="line">    if (root.left != null &amp;&amp; getPathFromRoot(root.left, node, pathArray) == true)</span><br><span class="line">        return true;</span><br><span class="line">    if (root.right != null &amp;&amp; getPathFromRoot(root.right, node, pathArray) == true)</span><br><span class="line">        return true;</span><br><span class="line">    //回溯</span><br><span class="line">    pathArray.remove(pathArray.size() - 1);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="是平衡二叉树吗？"><a href="#是平衡二叉树吗？" class="headerlink" title="是平衡二叉树吗？"></a>是平衡二叉树吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">    return getHeight(root) != -1;</span><br><span class="line">&#125;</span><br><span class="line">//返回以该节点为根节点二叉树的深度</span><br><span class="line">private static int getHeight(TreeNode root) &#123;</span><br><span class="line">    if (root==null)return 0;</span><br><span class="line">    int left=getHeight(root.left);</span><br><span class="line">    if (left==-1)return -1;</span><br><span class="line">    int right=getHeight(root.right);</span><br><span class="line">    if (right==-1)return -1;</span><br><span class="line">    if (Math.abs(left-right)&gt;1)return -1;</span><br><span class="line">    return Math.max(left,right)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最大路径和？（任意节点出发）</p>
</li>
<li><p>最大深度</p>
</li>
<li><p>前序遍历中序（中序和后序）遍历构造二叉树</p>
</li>
<li><p>路径和等于target的路径（根节点出发）</p>
</li>
<li><p>翻转二叉树</p>
</li>
<li><p>根节点到叶子结点的数字之和</p>
</li>
<li><p>对称二叉树？</p>
</li>
<li><p>二叉搜索树？</p>
</li>
<li><p>二叉搜索树第k大节点？</p>
</li>
</ul>
<h4 id="第二小的节点（根节点-x3D-左右节点较小的值）"><a href="#第二小的节点（根节点-x3D-左右节点较小的值）" class="headerlink" title="第二小的节点（根节点&#x3D;左右节点较小的值）"></a>第二小的节点（根节点&#x3D;左右节点较小的值）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int findSecondMinimumValue(TreeNode root) &#123;</span><br><span class="line">    if (root == null || (root.left == null &amp;&amp; root.right == null)) return -1;//没有最小节点</span><br><span class="line">    //找出候选数，默认就是子节点值，如果子节点值和root值相同，递归，在子树中寻找候选数</span><br><span class="line">    int left = root.left.val;</span><br><span class="line">    int right = root.right.val;</span><br><span class="line">    if (root.left.val == root.val) left = findSecondMinimumValue(root.left);</span><br><span class="line">    if (root.right.val == root.val) right = findSecondMinimumValue(root.right);</span><br><span class="line">    //如果左右候选数都正常，返回较小值就可</span><br><span class="line">    if (left != -1 &amp;&amp; right != -1) &#123;</span><br><span class="line">        return Math.min(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果候选数有-1，说明整个子树中没有可供候选的数</span><br><span class="line">    if (left != -1) &#123;</span><br><span class="line">        //左子树正常，答案就是左边的候选数</span><br><span class="line">        return left;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //右子树正常，返回答案</span><br><span class="line">        //或者右子树也没有候选数，返回-1，即right</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><h5 id="路径总和3-不限起点"><a href="#路径总和3-不限起点" class="headerlink" title="路径总和3-不限起点"></a>路径总和3-不限起点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int pathnumber;</span><br><span class="line">public int pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    if (root == null) return 0;</span><br><span class="line">    Sum(root, sum);</span><br><span class="line">    pathSum(root.left, sum);</span><br><span class="line">    pathSum(root.right, sum);</span><br><span class="line">    return pathnumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void Sum(TreeNode root, int sum) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    sum -= root.val;</span><br><span class="line">    if (sum == 0) &#123;</span><br><span class="line">        pathnumber++;</span><br><span class="line">    &#125;</span><br><span class="line">    Sum(root.left, sum);</span><br><span class="line">    Sum(root.right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="路径总和2（根节点到叶子节点有无）"><a href="#路径总和2（根节点到叶子节点有无）" class="headerlink" title="路径总和2（根节点到叶子节点有无）"></a>路径总和2（根节点到叶子节点有无）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static boolean hasPathSum2(TreeNode root, int sum) &#123;</span><br><span class="line">    if (root == null) return false;</span><br><span class="line">    return traversal(root, sum - root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean traversal(TreeNode cur, int count) &#123;</span><br><span class="line">    if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; count == 0)return true;</span><br><span class="line">    if (cur.left == null &amp;&amp; cur.right == null) return false;</span><br><span class="line">    if (cur.left != null) &#123;</span><br><span class="line">        count = count - cur.left.val;</span><br><span class="line">        if (traversal(cur.left, count)) return true;</span><br><span class="line">        count = count + cur.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cur.right != null) &#123;</span><br><span class="line">        count = count - cur.right.val;</span><br><span class="line">        if (traversal(cur.right, count)) return true;</span><br><span class="line">        count = count + cur.right.val;//回溯</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    if (root == null) return false;</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean l = hasPathSum(root.left, sum - root.val);</span><br><span class="line">    boolean r = hasPathSum(root.right, sum - root.val);</span><br><span class="line">    return l || r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="路径总和（打印上一题的路径）"><a href="#路径总和（打印上一题的路径）" class="headerlink" title="路径总和（打印上一题的路径）"></a>路径总和（打印上一题的路径）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    dfs(root, sum, 0, new ArrayList&lt;&gt;(), res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void dfs(TreeNode root, int sum, int total,</span><br><span class="line">                        List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    total = total + root.val;</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">        if (sum == total) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(list.size() - 1);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left, sum, total, list, res);</span><br><span class="line">    dfs(root.right, sum, total, list, res);</span><br><span class="line">    list.remove(list.size() - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="路径总和（打印所有路径）"><a href="#路径总和（打印所有路径）" class="headerlink" title="路径总和（打印所有路径）"></a>路径总和（打印所有路径）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    if (root == null)return res;</span><br><span class="line">    List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();</span><br><span class="line">    traversal(root, paths, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) &#123;</span><br><span class="line">    paths.add(root.val);</span><br><span class="line">    // 叶子结点</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; paths.size() - 1; i++) &#123;</span><br><span class="line">            sb.append(paths.get(i)).append(&quot;-&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths.get(paths.size() - 1));</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">        traversal(root.left, paths, res);</span><br><span class="line">        paths.remove(paths.size() - 1);// 回溯</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null) &#123;</span><br><span class="line">        traversal(root.right, paths, res);</span><br><span class="line">        paths.remove(paths.size() - 1);// 回溯</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树的本质其实也是对概念模型：<strong>2-3-4树</strong>的一种实现。</p>
<p><strong>2-3-4树是阶数为4的B树</strong>，B树，全名BalanceTree，平衡树。这种结构主要用来做查找。</p>
<p>红黑树也是<strong>二叉查找树</strong>，它是<strong>自平衡</strong>的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。</p>
<p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<p>性质1：每个节点要么是黑色，要么是红色。<br>性质2：根节点是黑色。<br>性质3：每个叶子节点（NIL）是黑色。<br>性质4：每个红色结点的两个子结点一定都是黑色。<br>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</p>
<h2 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h2><p>双堆找中位数：</p>
<p>如果一个数字要添加到小根堆，就先添加到大根堆，再将大根堆堆顶的元素转移至小根堆；反之亦然，以此能够保证小根堆中的元素永远大于大根堆中的元素。</p>
<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表+1"></a>单链表+1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode plusOne(ListNode head) &#123;</span><br><span class="line">      //翻转链表</span><br><span class="line">      ListNode newHead = null;</span><br><span class="line">      while (head != null) &#123;</span><br><span class="line">          ListNode temp = head.next;</span><br><span class="line">          head.next = newHead;</span><br><span class="line">          newHead = head;</span><br><span class="line">          head = temp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int count = 1;</span><br><span class="line">      ListNode temp = newHead;</span><br><span class="line">      while (count &gt; 0) &#123;</span><br><span class="line">          temp.val += count;</span><br><span class="line">          count = 0;</span><br><span class="line">          if (temp.val &gt;= 10) &#123;</span><br><span class="line">              temp.val -= 10;</span><br><span class="line">              count = 1;</span><br><span class="line">          &#125;</span><br><span class="line">          if (count &gt; 0 &amp;&amp; temp.next == null) &#123;</span><br><span class="line">              temp.next = new ListNode(count);</span><br><span class="line">              count = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          temp = temp.next;</span><br><span class="line">      &#125;</span><br><span class="line">      //再次反转</span><br><span class="line">      head = null;</span><br><span class="line">      while (newHead != null) &#123;</span><br><span class="line">          temp = newHead.next;</span><br><span class="line">          newHead.next = head;</span><br><span class="line">          head = newHead;</span><br><span class="line">          newHead = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      return head;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode temp = null;</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="k个一组反转链表"><a href="#k个一组反转链表" class="headerlink" title="k个一组反转链表"></a>k个一组反转链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">    ListNode dummy = new ListNode(0);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    ListNode end = dummy;</span><br><span class="line">    while (end.next != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; k &amp;&amp; end != null; i++) &#123;</span><br><span class="line">            end = end.next;//分组，end指向小组最后一个节点</span><br><span class="line">        &#125;</span><br><span class="line">        if (end == null) &#123;</span><br><span class="line">            break;//链表长度小于k，不翻转</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = end.next;//下一组起点</span><br><span class="line">        end.next = null;//断开</span><br><span class="line">        ListNode start = pre.next;//要翻转的头结点</span><br><span class="line"></span><br><span class="line">        pre.next = reverse(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        pre = start;//要翻转节点的上一个节点</span><br><span class="line">        end = start;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">       ListNode fast = head;</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           if (fast == null || fast.next == null) return null;//无环</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           if (fast == slow) break;</span><br><span class="line">       &#125;</span><br><span class="line">       //到这里一定有环</span><br><span class="line">       fast = head;</span><br><span class="line">       while (slow != fast) &#123;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return slow;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">       if (headA == null || headB == null) return null;</span><br><span class="line">       ListNode a = headA;</span><br><span class="line">       ListNode b = headB;</span><br><span class="line">       while (a != b) &#123;</span><br><span class="line">           a = a == null ? headB : a.next;</span><br><span class="line">           b = b == null ? headA : b.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode mergeTwoLists(ListNode n1, ListNode n2) &#123;</span><br><span class="line">    ListNode dummy = new ListNode(-1);</span><br><span class="line">    ListNode head = dummy;</span><br><span class="line">    while (n1 != null &amp;&amp; n2 != null) &#123;</span><br><span class="line">        if (n1.val &gt;= n2.val) &#123;</span><br><span class="line">            head.next = n2;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head.next = n1;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n1 == null) &#123;</span><br><span class="line">        head.next = n2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        head.next = n1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">    if (lists.length == 0) return null;</span><br><span class="line">    ListNode dummyHead = new ListNode(0);</span><br><span class="line">    ListNode curr = dummyHead;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(ListNode o1, ListNode o2) &#123;</span><br><span class="line">            return o1.val - o2.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    for (ListNode list : lists) &#123;</span><br><span class="line">        if (list == null) continue;</span><br><span class="line">        pq.add(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!pq.isEmpty()) &#123;</span><br><span class="line">        ListNode nextNode = pq.poll();</span><br><span class="line">        curr.next = nextNode;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        if (nextNode.next != null) &#123;</span><br><span class="line">            pq.add(nextNode.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String addStrings(String num1, String num2) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    int c = 0;</span><br><span class="line">    int i = num1.length() - 1;</span><br><span class="line">    int j = num2.length() - 1;</span><br><span class="line"></span><br><span class="line">    while (i &gt;= 0 || j &gt;= 0 || c != 0) &#123;</span><br><span class="line">        int n1 = i &gt;= 0 ? num1.charAt(i--) - &#x27;0&#x27; : 0;</span><br><span class="line">        int n2 = j &gt;= 0 ? num2.charAt(j--) - &#x27;0&#x27; : 0;</span><br><span class="line">        int temp = n1 + n2 + c;</span><br><span class="line">        sb.append(temp % 10);</span><br><span class="line">        c = temp / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    int[] res = new int[2];</span><br><span class="line">    if (nums.length == 0) return null;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    int temp=0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        temp=target-nums[i];</span><br><span class="line">        if (map.containsKey(temp)) &#123;</span><br><span class="line">            res[1] = i;</span><br><span class="line">            res[0] = map.get(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="无重复字符最大子串"><a href="#无重复字符最大子串" class="headerlink" title="无重复字符最大子串"></a>无重复字符最大子串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    for (int r = 0, l = 0; r &lt; s.length(); r++) &#123;</span><br><span class="line">        char c = s.charAt(r);</span><br><span class="line">        while (set.contains(c)) &#123;</span><br><span class="line">            set.remove(s.charAt(l));</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(c);</span><br><span class="line">        res = Math.max(res, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int[] reverse(int[] nums, int i) &#123;</span><br><span class="line">       rev(nums, 0, nums.length - 1);</span><br><span class="line">       rev(nums, 0, i - 1);</span><br><span class="line">       rev(nums, i, nums.length - 1);</span><br><span class="line">       return nums;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static int[] rev(int[] nums, int start, int end) &#123;</span><br><span class="line">       int l = start;</span><br><span class="line">       int r = end;</span><br><span class="line">       while (r &gt; l) &#123;</span><br><span class="line">           int temp = nums[l];</span><br><span class="line">           nums[l] = nums[r];</span><br><span class="line">           nums[r] = temp;</span><br><span class="line">           r--;</span><br><span class="line">           l++;</span><br><span class="line">       &#125;</span><br><span class="line">       return nums;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><blockquote>
<p>顺序集合的查找</p>
</blockquote>
<blockquote>
<p>循环不变量</p>
</blockquote>
<p>1，[left,right]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (l&lt;=r)&#123;</span><br><span class="line">    int mid=l+(r-l)/2;</span><br><span class="line">    if (nums[mid]&gt;target)&#123;</span><br><span class="line">        r=mid-1;</span><br><span class="line">    &#125;else if (nums[mid]&lt;target)&#123;</span><br><span class="line">        l=mid+1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2，[left,right)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (l&lt;r)&#123;</span><br><span class="line">    int mid=l+(r-l)/2;</span><br><span class="line">    if (nums[mid]&gt;target)&#123;</span><br><span class="line">        r=mid;</span><br><span class="line">    &#125;else if (nums[mid]&lt;target)&#123;</span><br><span class="line">        l=mid+1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">       if (nums.length == 0) return new int[0];</span><br><span class="line">       int[] res = new int[nums.length - k + 1];</span><br><span class="line">       LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">       for (int i = 0, j = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">           if (!queue.isEmpty() &amp;&amp; i - queue.peekFirst() &gt;= k) &#123;</span><br><span class="line">               queue.pollFirst();</span><br><span class="line">           &#125;</span><br><span class="line">           while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) &#123;</span><br><span class="line">               queue.pollLast();</span><br><span class="line">           &#125;</span><br><span class="line">           queue.addLast(i);</span><br><span class="line">           if (i &gt;= k - 1) &#123;</span><br><span class="line">               res[j] = nums[queue.peek()];</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int l = 0;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int r = 0; r &lt; s.length(); r++) &#123;</span><br><span class="line">        if (map.containsKey(s.charAt(r))) &#123;</span><br><span class="line">            l = Math.max(l, map.get(s.charAt(r)));</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, r - l + 1);</span><br><span class="line">        map.put(s.charAt(r), r + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        // 记录字符上一次出现的位置</span><br><span class="line">        int[] last = new int[128];</span><br><span class="line">        for(int i = 0; i &lt; 128; i++) &#123;</span><br><span class="line">            last[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = s.length();</span><br><span class="line"></span><br><span class="line">        int res = 0;</span><br><span class="line">        int start = 0; // 窗口开始位置</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int index = s.charAt(i);</span><br><span class="line">            start = Math.max(start, last[index] + 1);</span><br><span class="line">            res   = Math.max(res, i - start + 1);</span><br><span class="line">            last[index] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><ul>
<li>斐波拉切数列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int fib(int n) &#123;</span><br><span class="line">    if (n==0)return 0;</span><br><span class="line">    if (n==1)return 1;</span><br><span class="line">    int[] dp=new int[n+1];</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    dp[1]=1;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int fib2(int n)&#123;</span><br><span class="line">    if (n==0)return 0;</span><br><span class="line">    if (n==1)return 1;</span><br><span class="line">    int dp0=0;</span><br><span class="line">    int dp1=1;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        int sum=dp0+dp1;</span><br><span class="line">        dp0=dp1;</span><br><span class="line">        dp1=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>爬楼梯</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static int climb(int n) &#123;</span><br><span class="line">    if (n &lt;= 1) return n;</span><br><span class="line">    int[] dp = new int[n + 1];</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    dp[2] = 2;</span><br><span class="line">    for (int i = 3; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br><span class="line">//dp[0]在此没有意义。</span><br><span class="line">//拓展：最少花费爬楼梯</span><br><span class="line">public static int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">    if (cost == null || cost.length == 0) return 0;</span><br><span class="line">    if (cost.length == 1) return cost[0];</span><br><span class="line"></span><br><span class="line">    int[] dp = new int[cost.length];</span><br><span class="line">    dp[0] = cost[0];</span><br><span class="line">    dp[1] = cost[1];</span><br><span class="line">    for (int i = 2; i &lt; cost.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //最后一步，如果是由倒数第二步爬，则最后一步的体力花费可以不用算</span><br><span class="line">    return Math.min(dp[cost.length - 1], dp[cost.length - 2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不同路径</li>
</ul>
<p><img src="https://i.loli.net/2021/08/13/6AaWL3Hr7gosuOK.png" alt="image-20210813160649637"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static int uniquepaths2(int m, int n) &#123;</span><br><span class="line">    int[][] dp = new int[m][n];</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//考虑某些位置有障碍</span><br><span class="line">int m=grid.length();</span><br><span class="line">int n=grud[0].length();</span><br><span class="line">//初始化</span><br><span class="line">for (int i = 0; i &lt; m&amp;&amp;grid[i][0]==0; i++) &#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">   &#125;</span><br><span class="line">for (int i = 0; i &lt; n&amp;&amp;grid[0][j]==0; i++) &#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">   &#125;</span><br><span class="line">//遍历-加上判断条件即可</span><br><span class="line">if(grid[i][j]==1)continue;</span><br></pre></td></tr></table></figure>

<ul>
<li>整数拆分</li>
</ul>
<p>1，贪心算法-拆成3<em>3</em>3*3……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(n==2)return 1;</span><br><span class="line">if(n==3)return 2;</span><br><span class="line">if(n==4)return 4;</span><br><span class="line">int res=1;</span><br><span class="line">while(n&gt;4)&#123;</span><br><span class="line">    res=res*3;</span><br><span class="line">    n=n-3;</span><br><span class="line">&#125;</span><br><span class="line">res=res*n;</span><br><span class="line">return res;</span><br><span class="line">//数学证明？</span><br></pre></td></tr></table></figure>

<ul>
<li>2，动态规划</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int[] dp=new int[n+1];</span><br><span class="line">dp[2]=1;</span><br><span class="line">for(int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">    for(int j=1;j&lt;i-1;j++)&#123;</span><br><span class="line">        dp[i]=max(dp[i],max(j*(i-j),j*dp[i-j]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">return dp[n];</span><br></pre></td></tr></table></figure>



<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul>
<li>01背包</li>
</ul>
<p>问题描述：物品N件，背包重量W，物品的价值与重量为value[i]，weight[i]。</p>
<p>dp[i][j]表示在下标[0,i-1]的物品中任意取，存放到容量为j的背包的最大价值。</p>
<p>1，递推公式。</p>
<p>dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])。</p>
<p>第i个物品不取。</p>
<p>第i个物品取。dp[i-1][j-weight[i]]+value[i]为背包放i物品的最大价值。</p>
<p>2，初始化。</p>
<p>dp[i][0]&#x3D;0,背包容量为0，一定是0。</p>
<p>dp[0][j]&#x3D;?存放0号物品时，最大价值？</p>
<p>dp[0][j]&#x3D;dp[0][j-weight[0]]+value[0]</p>
<p>倒序遍历！</p>
<p>3，遍历顺序。</p>
<p>先遍历物品好理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int bag(int bagweight, int[] weight, int[] value) &#123;</span><br><span class="line">    int[][] dp = new int[weight.length][bagweight + 1];</span><br><span class="line">    for (int i = bagweight; i &gt;= weight[0]; i--) &#123;</span><br><span class="line">        dp[0][i] = dp[0][i - weight[0]] + value[0];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; weight.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= bagweight; j++) &#123;</span><br><span class="line">            if (j &gt;= weight[i]) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[weight.length-1][bagweight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] w = &#123;1, 3, 4&#125;;</span><br><span class="line">    int[] v = &#123;15, 20, 30&#125;;</span><br><span class="line">    System.out.println(bag(4, w, v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/13/A5q8CkLMDeo1B6F.png" alt="image-20210813160820472"></p>
<blockquote>
<p>一维dp[ ]数组。</p>
</blockquote>
<blockquote>
<p>遍历背包大小时倒序遍历-为了保证每个物品只用一次。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int bag1(int bagweight, int[] weight, int[] value)&#123;</span><br><span class="line">    int[] dp=new int[bagweight+1];</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i++) &#123;</span><br><span class="line">        for (int j = bagweight; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">            dp[j]= Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[bagweight];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cr1c7chgh5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ3OTM2ZWM4NmQ4ODc5MjNkN2FjOTcwMjdkNTRhZmNfNzhkTThMUHltY09UY0VUN1RVcFpPNTNNVG1NenRwYzZfVG9rZW46Ym94Y25JVDhmT0ZuTWFGMDExY3g4S0h4OURkXzE2Mjg4NDE5NjE6MTYyODg0NTU2MV9WNA" alt="img"></p>
<ul>
<li>完全背包-每个物品都可以被放入无数次。</li>
<li>只需要改变遍历背包时的遍历顺序。</li>
</ul>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int bag2(int bagweight, int[] weight, int[] value) &#123;</span><br><span class="line">    int[] dp = new int[bagweight + 1];</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i++) &#123;</span><br><span class="line">        for (int j = weight[i]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[bagweight];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>零钱兑换（1,2,5）</li>
<li>可以先遍历总金额吗？不能。</li>
<li>如果求<strong>组合数</strong>就是外层for循环遍历物品，内层for遍历背包。</li>
<li>如果求<strong>排列数</strong>就是外层for遍历背包，内层for循环遍历物品</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int coinnum(int[] coins,int money)&#123;</span><br><span class="line">    int[] dp=new int[money+1];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    for (int i = 0; i &lt; coins.length; i++) &#123;//遍历物品</span><br><span class="line">        for (int j = coins[i]; j &lt;= money; j++) &#123;//遍历容量</span><br><span class="line">            dp[j]=dp[j-coins[i]]+dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[money];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>爬楼梯进阶</li>
<li>每次都可以爬1,2,3,4，，，，n步？</li>
<li>等价于完全背包问题。</li>
<li>物品就是一步两步三步。</li>
<li>总量就是总的台阶步数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int climb3(int n, int m) &#123;</span><br><span class="line">    int[] dp = new int[n + 1];</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    //排列问题-先遍历背包</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;//遍历物品</span><br><span class="line">            if (i - j &gt;= 0) &#123;</span><br><span class="line">                dp[i] = dp[i] + dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>零钱兑换最少的硬币数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int coinmin(int[] coins, int sum) &#123;</span><br><span class="line">    int[] dp = new int[sum + 1];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for (int i = 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">        for (int j = coins[i]; j &lt;= sum; j++) &#123;</span><br><span class="line">            if (dp[j - coins[i]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[sum] == Integer.MAX_VALUE) return -1;</span><br><span class="line">    return dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构成完全平方数的最小个数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int sqmin(int n) &#123;</span><br><span class="line">    int[] dp = new int[n + 1];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for (int i = 0; i &lt;= n; i++) &#123;//遍历背包</span><br><span class="line">        for (int j = 1; j * j &lt;= i; j++) &#123;//遍历物品</span><br><span class="line">            dp[j] = Math.min(dp[i - j * j] + 1, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><h4 id="初级打家劫舍"><a href="#初级打家劫舍" class="headerlink" title="初级打家劫舍"></a>初级打家劫舍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int rob(int[] nums) &#123;</span><br><span class="line">    if (nums.length == 0) return 0;</span><br><span class="line">    if (nums.length == 1) return nums[0];</span><br><span class="line">    int[] dp = new int[nums.length];</span><br><span class="line">    dp[0] = nums[0];</span><br><span class="line">    dp[1] = Math.max(nums[0], nums[1]);</span><br><span class="line">    for (int i = 2; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="环形打家劫舍"><a href="#环形打家劫舍" class="headerlink" title="环形打家劫舍"></a>环形打家劫舍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int rob(int[] nums) &#123;</span><br><span class="line">    int len=nums.length;</span><br><span class="line">    if (len==0)return 0;</span><br><span class="line">    if (len==1)return nums[0];</span><br><span class="line">    int res1=helper(nums,0,nums.length-2);</span><br><span class="line">    int res2=helper(nums,1,nums.length-1);</span><br><span class="line">    return Math.max(res1,res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int helper(int[] nums, int start, int end) &#123;</span><br><span class="line">    if (start==end)return nums[start];</span><br><span class="line">    int[] dp=new int[nums.length];</span><br><span class="line">    dp[start]=nums[start];</span><br><span class="line">    dp[start+1]=Math.max(nums[start],nums[start+1]);</span><br><span class="line">    for (int i = start+2; i &lt;= end; i++) &#123;</span><br><span class="line">        dp[i]= Math.max(dp[i-2]+nums[i],dp[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="树形打家劫舍"><a href="#树形打家劫舍" class="headerlink" title="树形打家劫舍"></a>树形打家劫舍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int rob(TreeNode root)&#123;</span><br><span class="line">   //表示偷某个节点和不偷某个节点的最大值</span><br><span class="line">    int[] res=robtree(root);</span><br><span class="line">    return Math.max(res[0],res[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] robtree(TreeNode cur) &#123;</span><br><span class="line">    if (cur==null)return new int[2];</span><br><span class="line">    int[] left = robtree(cur.left);</span><br><span class="line">    int[] right = robtree(cur.right);</span><br><span class="line">    </span><br><span class="line">    int val1=cur.val+left[0]+right[0];</span><br><span class="line">    int val2=Math.max(left[0],left[1])+Math.max(right[0],right[1]);</span><br><span class="line">    return new int[]&#123;val2,val1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><h4 id="买股票最佳时机（只能买卖一次）"><a href="#买股票最佳时机（只能买卖一次）" class="headerlink" title="买股票最佳时机（只能买卖一次）"></a>买股票最佳时机（只能买卖一次）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int maxProfit(int[] prices) &#123;</span><br><span class="line">    int low=prices[0];</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=1;i&lt;prices.length;i++)&#123;</span><br><span class="line">        low=Math.min(prices[i],low);</span><br><span class="line">        res=Math.max(res,prices[i]-low);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（可以买卖多次）"><a href="#买股票最佳时机（可以买卖多次）" class="headerlink" title="买股票最佳时机（可以买卖多次）"></a>买股票最佳时机（可以买卖多次）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">        if (prices[i]&gt;prices[i-1])&#123;</span><br><span class="line">            res=res+(prices[i]-prices[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（最多买卖2次，同时只能有一支）"><a href="#买股票最佳时机（最多买卖2次，同时只能有一支）" class="headerlink" title="买股票最佳时机（最多买卖2次，同时只能有一支）"></a>买股票最佳时机（最多买卖2次，同时只能有一支）</h4><blockquote>
<p>动态规划：每天有5个状态，第一&#x2F;二天买入&#x2F;出，无操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    if (prices.length == 0) return 0;</span><br><span class="line">    int[][] dp = new int[prices.length][5];</span><br><span class="line">    dp[0][1] = -prices[0];</span><br><span class="line">    dp[0][3] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0];</span><br><span class="line">        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);</span><br><span class="line">        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</span><br><span class="line">        dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[prices.length - 1][4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（最多买卖k次，同时只能有一支）"><a href="#买股票最佳时机（最多买卖k次，同时只能有一支）" class="headerlink" title="买股票最佳时机（最多买卖k次，同时只能有一支）"></a>买股票最佳时机（最多买卖k次，同时只能有一支）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">    if (prices.length == 0) return 0;</span><br><span class="line">    int[][] dp = new int[prices.length][2 * k + 1];</span><br><span class="line">    //奇数代表卖入，偶数代表买</span><br><span class="line">    for (int i = 1; i &lt; 2 * k; i += 2) &#123;</span><br><span class="line">        dp[0][i] = -prices[0];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 2 * k - 1; j += 2) &#123;</span><br><span class="line">            dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);</span><br><span class="line">            dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[prices.length - 1][2 * k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（买卖多次，冷冻期一天）"><a href="#买股票最佳时机（买卖多次，冷冻期一天）" class="headerlink" title="买股票最佳时机（买卖多次，冷冻期一天）"></a>买股票最佳时机（买卖多次，冷冻期一天）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    if (prices.length == 0) return 0;</span><br><span class="line">    //状态：买入，卖出（两天前就卖出，今天卖出），冷冻期</span><br><span class="line">    int[][] dp = new int[prices.length][4];</span><br><span class="line">    dp[0][0] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);</span><br><span class="line">        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);</span><br><span class="line">        dp[i][2] = dp[i - 1][0] + prices[i];</span><br><span class="line">        dp[i][3] = dp[i - 1][2];</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(dp[prices.length - 1][3],</span><br><span class="line">            Math.max(dp[prices.length - 1][1], dp[prices.length - 1][2]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int maxlts(int[] nums) &#123;</span><br><span class="line">    if (nums.length &lt;= 1) return nums.length;</span><br><span class="line">    int[] dp = new int[nums.length];</span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(dp));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static int maxlts(int[] nums) &#123;</span><br><span class="line">    if (nums.length == 0) return 0;</span><br><span class="line">    int[] dp = new int[nums.length];</span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line">    int res = 1;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">        if (nums[i + 1] &gt; nums[i]) &#123;</span><br><span class="line">            dp[i + 1] = dp[i] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(dp));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//贪心算法</span><br><span class="line">public static int maxlts2(int[] nums) &#123;</span><br><span class="line">    if (nums.length == 0) return 0;</span><br><span class="line">    int res = 1;</span><br><span class="line">    int count = 1;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">        if (nums[i + 1] &gt; nums[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            count = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int maxarray(int[] nums1,int[] nums2)&#123;</span><br><span class="line">    int[][] dp=new int[nums1.length+1][nums2.length+1];</span><br><span class="line">    int res=0;</span><br><span class="line">    for (int i = 1; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">            if (nums1[i-1]==nums2[j-1])&#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">            &#125;</span><br><span class="line">            res= Math.max(res,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; dp.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; dp[0].length; j++) &#123;</span><br><span class="line">            System.out.print(dp[i][j]+&quot;   &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int maxarray(int[] nums1,int[] nums2)&#123;</span><br><span class="line">    int[][] dp=new int[nums1.length+1][nums2.length+1];</span><br><span class="line">    int res=0;</span><br><span class="line">    for (int i = 1; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">            if (nums1[i-1]==nums2[j-1])&#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">            res= Math.max(res,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; dp.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; dp[0].length; j++) &#123;</span><br><span class="line">            System.out.print(dp[i][j]+&quot;   &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int maxsubarray(int[] nums)&#123;</span><br><span class="line">    int res=Integer.MIN_VALUE;</span><br><span class="line">    int count=0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        count=count+nums[i];</span><br><span class="line">        if (count&gt;res)&#123;</span><br><span class="line">            res=count;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count&lt;=0)count=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int maxsubarray2(int[] nums)&#123;</span><br><span class="line">    if (nums.length==0)return 0;</span><br><span class="line">    int[] dp=new int[nums.length];</span><br><span class="line">    dp[0]=nums[0];</span><br><span class="line">    int res=nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i]= Math.max(dp[i-1]+nums[i],nums[i]);</span><br><span class="line">        res= Math.max(res,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public static int countSubstrings(String s)&#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">        res=res+extend(s,i,i,s.length());</span><br><span class="line">        res=res+extend(s,i,i+1,s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int extend(String s, int i, int j, int length) &#123;</span><br><span class="line">     int re=0;</span><br><span class="line">     while (i&gt;=0&amp;&amp;j&lt;length&amp;&amp;s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">         i++;</span><br><span class="line">         j--;</span><br><span class="line">         re++;</span><br><span class="line">     &#125;</span><br><span class="line">     return re;</span><br><span class="line">&#125;</span><br><span class="line">public static int huiwen(String s)&#123;</span><br><span class="line">    boolean[][] dp=new boolean[s.length()][s.length()];</span><br><span class="line">    int res=0;</span><br><span class="line">    for (int i = s.length()-1; i &gt;=0; i--) &#123;</span><br><span class="line">        for (int j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">            if (s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                if (j-i&lt;=1)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dp[i][j]=true;</span><br><span class="line">                &#125;else if(dp[i+1][j-1])&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dp[i][j]=true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//最长回文子串</span><br><span class="line">public static String maxhuiwen(String s)&#123;</span><br><span class="line">    if (s.length()&lt;2)return s;</span><br><span class="line">    int start=0;</span><br><span class="line">    int max=1;</span><br><span class="line">    int len=s.length();</span><br><span class="line">    for (int i = 0; i &lt; len; ) &#123;</span><br><span class="line">        //剩下的已经不可能更长了。</span><br><span class="line">        if (len-i&lt;=max/2)break;</span><br><span class="line">        int l=i;</span><br><span class="line">        int r=i;</span><br><span class="line">        while (r&lt;len-1&amp;&amp;s.charAt(r)==s.charAt(r+1))&#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        i=r+1;</span><br><span class="line">        while (r&lt;len-1&amp;&amp;l&gt;0&amp;&amp;s.charAt(r+1)==s.charAt(l-1))&#123;</span><br><span class="line">            r++;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r-l+1&gt;max)&#123;</span><br><span class="line">            max=r-l+1;</span><br><span class="line">            start=l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substring(start,start+max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">    int[][] dp = new int[s.length()][s.length()];</span><br><span class="line">    for (int i = s.length() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        dp[i][i] = 1;</span><br><span class="line">        for (int j = i + 1; j &lt; s.length(); j++) &#123;</span><br><span class="line">            if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + 1][j - 1] + 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][s.length() - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">       if (s.length() == 0) return true;</span><br><span class="line">       int ss = 0;</span><br><span class="line">       for (int i = 0; i &lt; t.length(); i++) &#123;</span><br><span class="line">           if (s.charAt(ss) == t.charAt(i)) &#123;</span><br><span class="line">               ss++;</span><br><span class="line">               if (ss == s.length()) return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int minDistance(String s1,String s2)&#123;</span><br><span class="line">    int[][] dp=new int[s1.length()+1][s2.length()+1];</span><br><span class="line">    for (int i = 0; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">        dp[i][0]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;= s2.length(); i++) &#123;</span><br><span class="line">        dp[0][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">            if (s1.charAt(i-1)==s2.charAt(j-1))&#123;</span><br><span class="line">                dp[i][j]=dp[i-1][j-1];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //s1增加一个元素dp[i-1][j]+1==as asd</span><br><span class="line">                //s2添加一个元素dp[i][j-1]+1==asd as</span><br><span class="line">                //替换元素dp[i-1][j-1]+1==asd ase</span><br><span class="line">                dp[i][j]= Math.min(Math.min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1), dp[i][j - 1] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s1.length()][s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="hotcode"><a href="#hotcode" class="headerlink" title="hotcode"></a>hotcode</h3><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class LRUCache &#123;</span><br><span class="line">    private class node &#123;</span><br><span class="line">        //双向链表类</span><br><span class="line">        int val;</span><br><span class="line">        int key;</span><br><span class="line">        node pre;</span><br><span class="line">        node next;</span><br><span class="line">        public node(int key, int val) &#123;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private HashMap&lt;Integer, node&gt; map;</span><br><span class="line">    private int capacity;</span><br><span class="line">    private node dummyfirst;</span><br><span class="line">    private node dummylast;</span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(capacity);</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        dummyfirst = new node(-1, -1);</span><br><span class="line">        dummylast = new node(-1, -1);</span><br><span class="line"></span><br><span class="line">        dummyfirst.next = dummylast;</span><br><span class="line">        dummylast.pre = dummyfirst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        if (!map.containsKey(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存中有</span><br><span class="line">        node n = map.get(key);</span><br><span class="line">        //删除该节点</span><br><span class="line">        n.pre.next = n.next;</span><br><span class="line">        n.next.pre = n.pre;</span><br><span class="line">        //移到最后面</span><br><span class="line">        movetolast(n);</span><br><span class="line">        return n.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        if (get(key) != -1) &#123;//已经有了</span><br><span class="line">            map.get(key).val = value;//更新值就可以</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //之前没有</span><br><span class="line">        node add = new node(key, value);</span><br><span class="line">        map.put(key, add);</span><br><span class="line">        //移到最后面</span><br><span class="line">        movetolast(add);</span><br><span class="line">        //满了就移除</span><br><span class="line">        if (map.size() &gt; capacity) &#123;</span><br><span class="line">            //删除最前面的（最久未用）</span><br><span class="line">            map.remove(dummyfirst.next.key);</span><br><span class="line">            dummyfirst.next = dummyfirst.next.next;</span><br><span class="line">            dummyfirst.next.pre = dummyfirst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void movetolast(node n) &#123;</span><br><span class="line">        n.next = dummylast;</span><br><span class="line">        n.pre = dummylast.pre;</span><br><span class="line">        dummylast.pre = n;</span><br><span class="line">        n.pre.next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int trap(int[] height) &#123;</span><br><span class="line">    int len = height.length;</span><br><span class="line">    int[] maxl = new int[len];</span><br><span class="line">    int[] maxr = new int[len];</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        maxl[i] = Math.max(maxl[i - 1], height[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = len - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        maxr[i] = Math.max(maxr[i + 1], height[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        int h = Math.min(maxl[i], maxr[i]);</span><br><span class="line">        if (h &gt; height[i]) &#123;</span><br><span class="line">            res = res + h - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton uniqueInstance;</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getUniqueInstance()&#123;</span><br><span class="line">        if (uniqueInstance==null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if (uniqueInstance==null)&#123;</span><br><span class="line">                    uniqueInstance=new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TOPK问题"><a href="#TOPK问题" class="headerlink" title="TOPK问题"></a>TOPK问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minheap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; a - b);//默认最小堆</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        minheap.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len - k; i++) &#123;</span><br><span class="line">        minheap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    return minheap.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int findKthLargest2(int[] nums, int k) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    // 最小堆</span><br><span class="line">    PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(k + 1, (a, b) -&gt; (a - b));</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        priorityQueue.add(num);</span><br><span class="line">        if (priorityQueue.size() == k + 1) &#123;</span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return priorityQueue.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; getRow(int rowIndex) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    while (rowIndex &gt;= 0) &#123;</span><br><span class="line">        rowIndex--;</span><br><span class="line">        list.add(1);</span><br><span class="line">        for (int i = list.size() - 2; i &gt; 0; i--) &#123;</span><br><span class="line">            list.set(i, list.get(i) + list.get(i - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第一个缺失的正数"><a href="#第一个缺失的正数" class="headerlink" title="第一个缺失的正数"></a>第一个缺失的正数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">   Set&lt;Integer&gt; set=new HashSet&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        if (!set.contains(i))&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length+1;</span><br><span class="line">&#125;</span><br><span class="line">public static int firstMissingPositive2(int[] nums) &#123;</span><br><span class="line">    int len=nums.length;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (nums[i]&lt;=0)nums[i]=len+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        int num= Math.abs(nums[i]);</span><br><span class="line">        if (num&lt;=len)&#123;</span><br><span class="line">            nums[num-1]=-Math.abs(nums[num-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (nums[i]&gt;0)&#123;</span><br><span class="line">            return i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int majorityElement(int[] nums) &#123;</span><br><span class="line">       int major=nums[0];</span><br><span class="line">       int count=0;</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">           if(count==0)&#123;</span><br><span class="line">               major=nums[i];</span><br><span class="line">               count=1;</span><br><span class="line">           &#125;else if(major==nums[i])&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               count--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       count=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]==major)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count&gt;nums.length/2?major:-1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XieYi</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">263k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:59</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
