

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/wztx.png">
  <link rel="icon" href="/img/wztx.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="XieYi">
  <meta name="keywords" content="">
  
    <meta name="description" content="[TOC] 常见数据结构根据数据访问的特点，可分为线性数据结构和非线性数据结构。 线性结构：数组、链表、栈、队列等。 非线性结构：散列表、树、堆、图等。  数组最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。 数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。 数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。">
<meta property="og:type" content="article">
<meta property="og:title" content="常见数据结构和算法">
<meta property="og:url" content="https://xieyi123456.github.io/2021/08/05/atop-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="XieYi&#39;s Blog">
<meta property="og:description" content="[TOC] 常见数据结构根据数据访问的特点，可分为线性数据结构和非线性数据结构。 线性结构：数组、链表、栈、队列等。 非线性结构：散列表、树、堆、图等。  数组最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。 数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。 数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/08/20/sPgipbEXy4NtQZj.png">
<meta property="og:image" content="https://i.loli.net/2021/08/20/MHYs3ytOh1wdNif.png">
<meta property="og:image" content="https://i.loli.net/2021/08/20/3XwCZTpGfWFVg2d.png">
<meta property="og:image" content="https://i.loli.net/2021/08/20/WiLGwKbvPEm1StC.png">
<meta property="og:image" content="https://i.loli.net/2021/08/20/7TJMQVSFXtUiNBd.png">
<meta property="og:image" content="https://i.loli.net/2021/08/20/X5xm7lJnV92RusH.png">
<meta property="og:image" content="https://i.loli.net/2021/08/20/k3M98f5eJFWzZjH.png">
<meta property="og:image" content="https://i.loli.net/2021/08/17/zhuLKPnZQDM6VIx.png">
<meta property="og:image" content="https://i.loli.net/2021/08/16/FBkb4rJcL5S9IGy.png">
<meta property="og:image" content="https://i.loli.net/2021/08/05/ojG8w5gRxvYDzrB.png">
<meta property="og:image" content="https://i.loli.net/2021/08/13/6AaWL3Hr7gosuOK.png">
<meta property="og:image" content="https://i.loli.net/2021/08/13/A5q8CkLMDeo1B6F.png">
<meta property="og:image" content="https://cr1c7chgh5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ3OTM2ZWM4NmQ4ODc5MjNkN2FjOTcwMjdkNTRhZmNfNzhkTThMUHltY09UY0VUN1RVcFpPNTNNVG1NenRwYzZfVG9rZW46Ym94Y25JVDhmT0ZuTWFGMDExY3g4S0h4OURkXzE2Mjg4NDE5NjE6MTYyODg0NTU2MV9WNA">
<meta property="article:published_time" content="2021-08-05T06:39:32.000Z">
<meta property="article:modified_time" content="2024-03-27T08:31:59.287Z">
<meta property="article:author" content="XieYi">
<meta property="article:tag" content="basic">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/08/20/sPgipbEXy4NtQZj.png">
  
  
  
  <title>常见数据结构和算法 - XieYi&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xieyi123456.github.io","root":"/","version":"1.9.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="XieYi's Blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>XieYi&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">常见数据结构和算法</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-08-05 14:39" pubdate>
          2021年8月5日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">常见数据结构和算法</h1>
            
            
              <div class="markdown-body">
                
                <p>[TOC]</p>
<h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>根据数据访问的特点，可分为线性数据结构和非线性数据结构。</p>
<p>线性结构：数组、链表、栈、队列等。</p>
<p>非线性结构：散列表、树、堆、图等。</p>
<p><img src="https://i.loli.net/2021/08/20/sPgipbEXy4NtQZj.png" srcset="/img/loading.gif" lazyload alt="image-20210820104323459"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。</p>
<p>数组中元素的存储是按照先后顺序进行的，<strong>同时在内存中也是按照这个顺序进行连续存放。</strong></p>
<p>数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。</p>
<p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比与线性数据表结构，操作复杂。</p>
<p>由于不必须按顺序存储，链表在插入的时候可以达到 O(1)的复杂度，比另一种线性表顺序表快得多，但是<strong>查找一个节点或者访问特定编号的节点则需要 O(n)的时间</strong>，而线性表和顺序表相应的时间复杂度分别是 O(logn)和 O(1)。</p>
<p>链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。</p>
<p>这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。</p>
<p>一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p>
<p><img src="https://i.loli.net/2021/08/20/MHYs3ytOh1wdNif.png" srcset="/img/loading.gif" lazyload alt="image-20210820104600004"></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>跳表也叫跳跃表，是一种动态的数据结构。如果我们需要在有序链表中进行查找某个值，需要遍历整个链表，二分查找对链表不支持，二分查找的底层要求为数组，遍历整个链表的时间复杂度为 O(n)。</p>
<p>我们可以<strong>把链表改造成 B 树、红黑树、AVL 树等数据结构来提升查询效率</strong>，但是 B 树、红黑树、AVL 树这些数据结构实现起来非常复杂，里面的细节也比较多。</p>
<p>跳表就是为了提升有序链表的查询速度产生的一种动态数据结构，跳表相对 B 树、红黑树、AVL 树这些数据结构实现起来比较简单，但时间复杂度与 B 树、红黑树、AVL 树这些数据结构不相上下，时间复杂度能够达到 O(logn)。</p>
<p>跳表一般使用<strong>单链表来实现，这样比较节约空间</strong>。我使用双向链表来实现跳表，因为双向链表相对单向链表来说比较容易理解跳表的实现。</p>
<p>跳表的性质：</p>
<p>由很多层结构组成<br>每一层都是一个有序的链表<br>最底层(Level 1)的链表包含所有元素<br>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。<br>从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从 O(n)提升至 O(logn)。</p>
<p><img src="https://i.loli.net/2021/08/20/3XwCZTpGfWFVg2d.png" srcset="/img/loading.gif" lazyload alt="image-20210820104806454"></p>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>在二叉树的概念下又衍生出<strong>满二叉树和完全二叉树</strong>的概念</p>
<p><img src="https://i.loli.net/2021/08/20/WiLGwKbvPEm1StC.png" srcset="/img/loading.gif" lazyload alt="image-20210820105029787"></p>
<p><strong>完全二叉树：</strong>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上（除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。</p>
<p><strong>满二叉树：</strong>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边（除了最后一层，其它层的结点都有两个子结点）。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树又被称为 AVL 树，<strong>它是一棵二叉排序树</strong>，且具有以下性质：</p>
<p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</strong></p>
<p><strong>二叉排序树：</strong>是一棵空树，或者：</p>
<p><strong>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</strong></p>
<p><strong>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</strong></p>
<p>它的左、右子树也分别为二叉排序树。</p>
<p>树的高度：结点层次的最大值。</p>
<p><strong>二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。</strong></p>
<p> 平衡二叉树的产生是为了<strong>解决二叉排序树在插入时发生线性排列的现象</strong>。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>先序遍历：先根节点-&gt;遍历左子树-&gt;遍历右子树</p>
<p>中序遍历：遍历左子树-&gt;根节点-&gt;遍历右子树</p>
<p>后序遍历：遍历左子树-&gt;遍历右子树-&gt;根节点</p>
<h4 id="深度优先搜索（DFS）与广度优先搜索（BFS）"><a href="#深度优先搜索（DFS）与广度优先搜索（BFS）" class="headerlink" title="深度优先搜索（DFS）与广度优先搜索（BFS）"></a>深度优先搜索（DFS）与广度优先搜索（BFS）</h4><p>实现：</p>
<p><strong>bfs</strong>＝队列，入队列，出队列 一次访问一条路径；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">queue.add(root);<br>   while (!queue.isEmpty())&#123;<br>       int size=queue.size();<br>       List&lt;Integer&gt; temp=new ArrayList&lt;&gt;();<br>       for (int i = 0; i &lt; size; i++) &#123;<br>           TreeNode poll = queue.poll();<br>           temp.add(poll.val);<br>           if (poll.left!=null)queue.offer(poll.left);<br>           if (poll.right!=null)queue.offer(poll.right);<br>       &#125;<br>       res.add(temp);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>dfs</strong>&#x3D;栈，压栈，出栈 一次访问多条路径；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">//递归<br>public static void helper(TreeNode root,List&lt;Integer&gt;res) &#123;<br>    if (root == null) return;<br>    res.add(root.val);<br>    helper(root.left,res);<br>    helper(root.right,res);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。这样出栈的时候才是中左右的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">st.push(root);<br>   while (!st.isEmpty()) &#123;<br>       TreeNode node = st.pop();                       // 中 <br>       result.add(node-&gt;val);<br>       if (node.right) st.push(node.right);           // 右（空节点不入栈）<br>       if (node.left) st.push(node.left);             // 左（空节点不入栈）<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>因为前序遍历的顺序是<strong>中左右</strong>，先访问的元素是中间节点，要处理的元素也是中间节点，所以才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p>
<p>那么再看看中序遍历，中序遍历是<strong>左中右</strong>，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进 result 数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p>
<p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">TreeNode cur = root;<br>     while (cur != NULL || !st.isEmpty()) &#123;<br>         if (cur != NULL) &#123; // 指针来访问节点，访问到最底层<br>             st.push(cur); // 将访问的节点放进栈<br>             cur = cur.left;                // 左<br>         &#125; else &#123;<br>             cur = st.pop(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）<br>             result.add(cur.val);     // 中<br>             cur = cur.right;               // 右<br>         &#125;<br>     &#125;<br>     return result;<br></code></pre></td></tr></table></figure>

<p>​		1</p>
<p>​	2 	3</p>
<p>4	 5  6   7</p>
<p>1-2-4</p>
<p>再来看后序遍历，先序遍历是<strong>中左右</strong>，后续遍历是<strong>左右中</strong>，那么我们只需要调整一下先序遍历的代码顺序，就变成<strong>中右左</strong>的遍历顺序，然后在反转 result 数组，输出的结果顺序就是左右中了。</p>
<p>关系：</p>
<p>用 DFS 解决的问题都可以用 BFS 解决。<strong>DFS 易于编写（递归）</strong>，时间消耗较少但是容易发生爆栈，而 BFS 可以控制队列的长度。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于 1。高度平衡带来的好处是能够提供更高的搜索效率，<strong>其最坏的查找时间复杂度都是 O(logN)<strong>。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，</strong>需要经过多次旋转实现复衡</strong>。这导致 AVL 的<strong>插入和删除</strong>效率并不高。</p>
<p>为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？红黑树可以解决。</p>
<p>红黑树具有五个特性：   </p>
<p>每个结点要么是红的要么是黑的。<br>根结点是黑的。<br>每个叶结点（叶结点即指树尾端 NIL 指针或 NULL 结点）都是黑的。<br>如果一个结点是红的，那么它的两个儿子都是黑的。<br>对于任意结点而言，其到叶结点树尾端 NIL 指针的每条路径都包含相同数目的黑结点。</p>
<p><img src="https://i.loli.net/2021/08/20/7TJMQVSFXtUiNBd.png" srcset="/img/loading.gif" lazyload alt="image-20210820112252998"></p>
<p>红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。</p>
<p><img src="https://i.loli.net/2021/08/20/X5xm7lJnV92RusH.png" srcset="/img/loading.gif" lazyload alt="image-20210820112333170"></p>
<h3 id="散列表（hash-表）"><a href="#散列表（hash-表）" class="headerlink" title="散列表（hash 表）"></a>散列表（hash 表）</h3><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。</p>
<p>散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，<strong>实现 O(1)的数据访问效率</strong>。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。</p>
<p>确定好散列函数之后，通过某个 key 值的确会得到一个唯一的 value 地址。但是却会出现一些特殊情况。即通过不同的 key 值可能会访问到同一个地址，这个现象称之为冲突。</p>
<p>冲突在发生之后，当在对不同的 key 值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p>
<p><strong>hash 冲突：</strong></p>
<p><strong>开放地址法（也叫开放寻址法）</strong>：实际上就是当需要存储值时，对 Key 哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的<strong>增列序量。</strong></p>
<p><strong>再哈希法：</strong>在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p>
<p><strong>链地址法：</strong>链地址法其实就是对 Key 通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p>
<p><strong>公共溢出区：</strong>这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。目前比较<strong>常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。</strong></p>
<p>考虑到链表过长造成的问题，<strong>还可以使用红黑树替换链表进行冲突数据的处理操作</strong>，来提高散列表的查询稳定性。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>B 树是一种多路搜索树，它的每个节点可以拥有多于两个孩子节点。M 路的 B 树最多拥有 M 个孩子节点。</p>
<p><img src="https://i.loli.net/2021/08/20/k3M98f5eJFWzZjH.png" srcset="/img/loading.gif" lazyload alt="image-20210820113238166"></p>
<p>文件系统和数据库的索引都是<strong>存在硬盘上的</strong>，并且如果数据量大的话，不一定能一次性加载到内存中</p>
<p>如果一棵树都无法一次性加载进内存，该怎么查找呢？</p>
<p>B 树的多路存储的威力就在于此，<strong>可以每次加载 B 树的一个节点</strong>，然后，一步步往下找。</p>
<p>查找时候，每次载入一个节点进内存就行，<strong>如果在内存中，红黑树比 B 树效率更高，但是涉及到磁盘操作，B 树就更优了。</strong></p>
<p>B+树是在 B 树基础上进行改造的，<strong>它的数据都在叶子节点</strong>，同时叶子节点之间还加了指针形成链表。</p>
<p>B+树在数据库的索引中用的比较多，如果数据库 select 数据，不一定只选一条，很多时候选多条，比如按照 id 排序后选 10 条。</p>
<p><strong>这样如果是多条的话，B 树需要做局部的中序遍历，可能需要跨层访问，</strong>而 B+树由于所有数据都在叶子节点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>
<p><strong>存储密度：顺序存储结构是一个一个挨着，基本上是一个空间对应一个数据；而链式存储由于每个结点都含有指针区域，故存储空间占用比较大，存储密度也就相对来说比较少。</strong></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 O(nlogn)，它是不稳定排序。</p>
<p>堆的性质<br>① 是一棵完全二叉树<br>② 每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</p>
<p><img src="https://i.loli.net/2021/08/17/zhuLKPnZQDM6VIx.png" srcset="/img/loading.gif" lazyload alt="image-20210817155031261"></p>
<p>一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)&#x2F;2；其左右子结点分别为 (2i + 1)、(2i + 2)</p>
<p><img src="https://i.loli.net/2021/08/16/FBkb4rJcL5S9IGy.png" srcset="/img/loading.gif" lazyload alt="image-20210816150908734"></p>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p>a.将<strong>无序序列</strong>构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p>
<p>b.将堆顶元素与末尾元素交换，<strong>将最大元素”沉”到数组末端;</strong></p>
<p>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static void main(String[] args) &#123;<br>       int[] nums = &#123;4, 10, 3, 6, 1, 2&#125;;<br>       heapsort(nums, nums.length);<br>       System.out.println(Arrays.toString(nums));<br>   &#125;<br><br>   public static void heapsort(int[] tree, int n) &#123;<br>       build_heap(tree, n);<br>       for (int i = n - 1; i &gt;= 0; i--) &#123;<br>           swap(tree, i, 0);<br>           heapify(tree, i, 0);<br>       &#125;<br>   &#125;<br><br>   public static void build_heap(int[] nums, int n) &#123;<br>       int last = n - 1;<br>       int par = (last - 1) / 2;<br>       for (int j = par; j &gt;= 0; j--) &#123;<br>           heapify(nums, n, j);<br>       &#125;<br>   &#125;<br><br>   public static void heapify(int[] nums, int n, int i) &#123;<br>       if (i &gt;= n) return;<br>       int c1 = 2 * i + 1;<br>       int c2 = 2 * i + 2;<br>       int max = i;<br>       if (c1 &lt; n &amp;&amp; nums[c1] &gt; nums[max]) &#123;<br>           max = c1;<br>       &#125;<br>       if (c2 &lt; n &amp;&amp; nums[c2] &gt; nums[max]) &#123;<br>           max = c2;<br>       &#125;<br>       if (max != i) &#123;<br>           swap(nums, i, max);<br>           heapify(nums, n, max);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>一.初始化建堆<br>　　初始化建堆只需要对二叉树的非叶子节点调用 build_heap()函数，由下至上，由右至左选取非叶子节点来调用函数。那么倒数第二层的最右边的非叶子节点就是最后一个非叶子结点。<br>　　假设高度为 k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；高层也是这样逐渐递归。<br>　　那么总的时间计算为：s &#x3D; 2^( i - 1 ) * ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要下调比较的次数。<br>　　S &#x3D; 2^(k-2) * 1 + 2^(k-3)2……..+2(k-2)+2^(0)*(k-1) &#x3D;&#x3D;&#x3D;&gt; 因为叶子层不用交换，所以 i 从 k-1 开始到 1；<br>　　S &#x3D; 2^k -k -1；又因为 k 为完全二叉树的深度，而 log(n) &#x3D;k，把此式带入；<br>　　得到：S &#x3D; n - log(n) -1，所以时间复杂度为：O(n)</p>
<p>二.排序重建堆<br>　　在取出堆顶点放到对应位置并把原堆的最后一个节点填充到堆顶点之后，需要对堆进行重建，只需要对堆的顶点调用 heapify()函数。<br>　　每次重建意味着有一个节点出堆，所以需要将堆的容量减一。重建堆一共需要 n-1 次循环，每次循环的比较次数为 log(i)，则相加为：log2+log3+……+log(n-1)+log(n)≈log(n!)。可以证明 log(n!)和 nlog(n)是同阶函数：<br>∵(n&#x2F;2)^n&#x2F;2≤n!≤n^n,∵(n&#x2F;2)^n&#x2F;2≤n!≤n^n,<br>∴n&#x2F;4log(n)&#x3D;n&#x2F;2log(n1&#x2F;2)≤n&#x2F;2log(n&#x2F;2)≤log(n!)≤nlog(n)∴n&#x2F;4log⁡(n)&#x3D;n&#x2F;2log⁡(n1&#x2F;2)≤n&#x2F;2log⁡(n&#x2F;2)≤log⁡(n!)≤nlog⁡(n)<br>　　所以时间复杂度为 O(nlogn)</p>
<p>　　初始化建堆的时间复杂度为 O(n)，排序重建堆的时间复杂度为 nlog(n)，所以总的时间复杂度为**O(n+nlogn)&#x3D;O(nlogn)**。另外堆排序的比较次数和序列的初始状态有关，但只是在序列初始状态为堆的情况下比较次数显著减少，在序列有序或逆序的情况下比较次数不会发生明显变化。</p>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>选取基准值，左边小于其，右边大于其。左右子序列重复此过程。<br>大量数据时表现良好。<br>数据越乱表现越好。数据接近有序是退化成冒泡排序。<br>一种不稳定的排序方式。<br>也是一种交换排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int[] sort(int[] nums) &#123;<br>    quicksort(nums, 0, nums.length - 1);<br>    return nums;<br>&#125;<br><br>private static void quicksort(int[] nums, int left, int right) &#123;<br>    if (left &gt;= right) return;<br>    int pindex = partition(nums, left, right);<br>    quicksort(nums, left, pindex - 1);<br>    quicksort(nums, pindex + 1, right);<br>&#125;<br><br>private static int partition(int[] nums, int left, int right) &#123;<br>    Random r = new Random();<br>    int rindex = left + r.nextInt(right - left + 1);<br>    swap(nums, rindex, left);<br><br>    int pivot = nums[left];<br>    int l = left;<br>    for (int i = left + 1; i &lt;= right; i++) &#123;<br>        if (nums[i] &lt; pivot) &#123;<br>            l++;<br>            swap(nums, i, l);<br>        &#125;<br>    &#125;<br>    swap(nums, left, l);<br>    return l;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次都选择最大（最小）的元素放在最前面，依次往后。<br>堆排序亦是选择排序：利用堆来选择数据。时间复杂度降低。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (int i = 0; i &lt; len; i++) &#123;<br>    int min = i;<br>    for (int j = i + 1; j &lt; len; j++) &#123;<br>        if (nums[j] &lt; nums[min]) &#123;<br>            min = j;<br>        &#125;<br>    &#125;<br>    swap(nums, min, i);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>始终维持一个有序的队列。</p>
<p>元素越接近于稳定时，效率越高。<br>稳定的排序方式。<br>希尔排序是对直接插入排序的优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (int i = 1; i &lt; len; i++) &#123;//第一个数有序<br>    int temp=nums[i];<br>    int j=i;<br>    while (j&gt;0&amp;&amp;nums[j-1]&gt;temp)&#123;<br>        nums[j]=nums[j-1];<br>        j--;<br>    &#125;<br>    nums[j]=temp;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>比较相邻两个值的大小，出现逆序就交换。<br>稳定的排序。<br>慢：每次只能移动相邻的两个数据。<br>一种交换排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (int i = 0; i &lt; len; i++) &#123;//扫苗多少趟<br>    for (int j = 0; j &lt; len-1; j++) &#123;<br>        if (nums[j] &gt; nums[j + 1]) &#123;<br>            swap(nums, j, j + 1);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治法的应用。<br>合并有序的子序列。<br>o(n)的空间复杂度。更多考虑解决磁盘外部排序的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int[] sort(int[] nums)&#123;<br>    int[] temp=new int[nums.length];<br>    mergesort(nums,0,nums.length-1,temp);<br>    return nums;<br>&#125;<br><br>private static void mergesort(int[] nums, int left, int right, int[] temp) &#123;<br>    if (left&gt;=right)return;<br>    int mid=left+(right-left)&gt;&gt;1;<br>    mergesort(nums, left,mid,temp);<br>    mergesort(nums,mid+1,right,temp);<br>    //数组有序，不用merge<br>    if (nums[mid]&lt;=nums[mid+1])&#123;<br>        return;<br>    &#125;<br>    merge(nums,left,mid,right,temp);<br>&#125;<br><br>private static void merge(int[] nums, int left, int mid, int right, int[] temp) &#123;<br>    //System.arraycopy(nums,left,temp,left,right-left+1);<br>    for (int i = left; i &lt;= right; i++) &#123;<br>        temp[i]=nums[i];<br>    &#125;<br>    //左右两半的起点<br>    int i=left;<br>    int j=mid+1;<br>    for (int k = left; k &lt;= right; k++) &#123;<br>        if (i==mid+1)nums[k]=temp[j++];<br>        else if (j==right+1)nums[k]=temp[i++];<br>        else if (temp[i]&lt;=temp[j])nums[k]=temp[i++];<br>        else nums[k]=temp[j++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>稳定性：相同数值的元素经过排序以后，相对的位置保持不变。</li>
<li>内部排序：数据全部放在内存中。</li>
<li>外部排序：内存装不下</li>
</ul>
<p><img src="https://i.loli.net/2021/08/05/ojG8w5gRxvYDzrB.png" srcset="/img/loading.gif" lazyload alt="image-20210805144637116"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><blockquote>
<p>深度优先便利–广度优先遍历</p>
</blockquote>
<blockquote>
<p>前序：preorder 根-左-右</p>
</blockquote>
<blockquote>
<p>中序：inorder 左-根-右</p>
</blockquote>
<blockquote>
<p>后序：postorder 左-右-根</p>
</blockquote>
<blockquote>
<p>层序：levelorder</p>
</blockquote>
<ul>
<li>前序遍历</li>
<li>递归</li>
<li>迭代</li>
<li>中序遍历</li>
<li>递归</li>
<li>迭代</li>
<li>后序遍历</li>
<li>递归</li>
<li>迭代</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">//递归版本<br>public static List&lt;Integer&gt; preorder2(TreeNode root)&#123;<br>    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();<br>    helper(root,res);<br>    return res;<br>&#125;<br>public static void helper(TreeNode root,List&lt;Integer&gt;res) &#123;<br>    if (root == null) return;<br>    res.add(root.val);<br>    helper(root.left,res);<br>    helper(root.right,res);<br>&#125;<br><br>public static void preorder(TreeNode root)&#123;<br>    if (root==null)return;<br>    System.out.print(root.val+&quot; &quot;);<br>    preorder(root.left);<br>    preorder(root.right);<br>&#125;<br>//迭代统一写法<br>public static List&lt;Integer&gt; preorder3(TreeNode root)&#123;<br>    List&lt;Integer&gt; res=new ArrayList&lt;&gt;();<br>    if (root==null)return res;<br>    Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();<br>    stack.push(root);<br>    while (!stack.isEmpty())&#123;<br>        TreeNode top = stack.peek();<br>        if (top!=null)&#123;<br>            stack.pop();<br>            if (top.right!=null)stack.push(top.right);<br>            if (top.left!=null)stack.push(top.left);<br>            stack.push(top);<br>            stack.push(null);<br>        &#125;else&#123;<br>            stack.pop();<br>            TreeNode pop = stack.pop();<br>            res.add(pop.val);<br>        &#125;<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static List&lt;List&lt;Integer&gt;&gt; levelorder(TreeNode root)&#123;<br>    if (root==null)return null;<br>    List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;();<br>    LinkedList&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while (!queue.isEmpty())&#123;<br>        int size=queue.size();<br>        List&lt;Integer&gt; temp=new ArrayList&lt;&gt;();<br>        for (int i = 0; i &lt; size; i++) &#123;<br>            TreeNode poll = queue.poll();<br>            temp.add(poll.val);<br>            if (poll.left!=null)queue.offer(poll.left);<br>            if (poll.right!=null)queue.offer(poll.right);<br>        &#125;<br>        res.add(temp);<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>右视图-只需要判断一下是否是最后一个。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain"> for (int i = 0; i &lt; size; i++) &#123;<br>    TreeNode node = queue.poll();<br>    if (node.left != null) queue.offer(node.left);<br>    if (node.right != null) queue.offer(node.right);<br>    if (i == size - 1)  //将当前层的最后一个节点放入结果列表<br>        res.add(node.val);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><h5 id="n-叉数层序遍历"><a href="#n-叉数层序遍历" class="headerlink" title="n 叉数层序遍历"></a>n 叉数层序遍历</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br>    Deque&lt;Node&gt; que = new LinkedList&lt;&gt;();<br>    if (root == null) return res;<br>    que.offer(root);<br>    while (!que.isEmpty()) &#123;<br>        int size = que.size();<br>        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();<br>        for (int i = 0; i &lt; size; i++) &#123;<br>            Node poll = que.poll();<br>            temp.add(poll.val);<br><br>            List&lt;Node&gt; children = poll.children;<br>            if (children == null || children.size() == 0) &#123;<br>                continue;<br>            &#125;<br>            for (Node child : children) &#123;<br>                if (child != null) que.offer(child);<br>            &#125;<br>        &#125;<br>        res.add(temp);<br>    &#125;<br>    return res;<br>&#125;<br><br>class Node &#123;<br>    public int val;<br>    public List&lt;Node&gt; children;<br>    public Node() &#123;<br>    &#125;<br>    public Node(int _val) &#123;<br>        val = _val;<br>    &#125;<br>    public Node(int _val, List&lt;Node&gt; _children) &#123;<br>        val = _val;<br>        children = _children;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><h5 id="锯齿形层序遍历"><a href="#锯齿形层序遍历" class="headerlink" title="锯齿形层序遍历"></a>锯齿形层序遍历</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">/**<br> * z字形遍历-偶数层倒序遍历<br> * @param root<br> * @return<br> */<br>public static List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();<br>    if (root == null) &#123;<br>        return result;<br>    &#125;<br>    LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();<br>    queue.add(root);<br>    while (!queue.isEmpty()) &#123;<br>        // 该层的节点数量<br>        int size = queue.size();<br>        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();<br>        for (int i = 0; i &lt; size; i++) &#123;<br>            TreeNode node = queue.poll();<br>            // 根据层次来判断顺序<br>            if (result.size() % 2 == 0) &#123;<br>                temp.add(node.val);<br>            &#125; else &#123;<br>                temp.add(0, node.val);//插到最前面<br>            &#125;<br>            if (node.left != null) queue.add(node.left);<br>            if (node.right != null)queue.add(node.right);<br>        &#125;<br>        result.add(temp);<br>    &#125;<br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>理解使用队列进行层序遍历的本质。</li>
<li>z 字形遍历时，result.size 一开始是 0，第二层时为 1，所以奇数时插到前面。</li>
</ul>
<h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) &#123;<br>    return helper(root,p,q);<br>&#125;<br>private static TreeNode helper(TreeNode root, TreeNode p, TreeNode q) &#123;<br>    if (root==null||root==p||root==q)return root;<br>    TreeNode left=helper(root.left,p,q);<br>    TreeNode right=helper(root.right,p,q);<br>    if (left!=null&amp;&amp;right!=null)return root;<br>    if (left==null)return right;<br>    return left;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="两节点最近路径"><a href="#两节点最近路径" class="headerlink" title="两节点最近路径"></a>两节点最近路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static List&lt;Integer&gt; findDistance(TreeNode root, TreeNode p, TreeNode q) &#123;<br>    if (p == q) &#123;<br>        return new ArrayList&lt;&gt;(p.val);<br>    &#125;<br>    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();<br>    List&lt;TreeNode&gt; list1 = findPath(root, p);<br>    List&lt;TreeNode&gt; list2 = findPath(root, q);<br><br>    //单独考虑在同一条路径的情况<br>    if (list1.containsAll(list2) || list2.containsAll(list1)) &#123;<br>        int max = Math.max(list1.size(), list2.size());<br>        List&lt;TreeNode&gt; llist = list1.size() == max ? list1 : list2;<br>        List&lt;TreeNode&gt; slist = list1.size() == max ? list2 : list1;<br>        for (int i = 0; i &lt; slist.size(); i++) &#123;<br>            System.out.print(slist.get(i).val+&quot; &quot;);<br>        &#125;<br>        System.out.println();<br>        for (int i = 0; i &lt; llist.size(); i++) &#123;<br>            System.out.print(llist.get(i).val+&quot; &quot;);<br>        &#125;<br>        for (int i = slist.size()-1; i &lt; llist.size(); i++) &#123;<br>            res.add(llist.get(i).val);<br>        &#125;<br>    &#125; else &#123;<br>        //去重<br>        int lastSame = 0;<br>        for (int i = 0; i &lt; list1.size(); i++) &#123;<br>            if (list1.get(i) == list2.get(i)) &#123;<br>                lastSame = i;<br>            &#125; else &#123;<br>                break;<br>            &#125;<br>        &#125;<br>        for (int i = list1.size() - 1; i &gt; lastSame; i--) &#123;<br>            res.add(list1.get(i).val);<br>        &#125;<br>        for (int i = lastSame; i &lt; list2.size(); i++) &#123;<br>            res.add(list2.get(i).val);<br>        &#125;<br>    &#125;<br>    return res;<br>&#125;<br><br>private static List&lt;TreeNode&gt; findPath(TreeNode root, TreeNode node) &#123;<br>    List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();<br>    getPathFromRoot(root, node, res);<br>    return res;<br>&#125;<br><br>public static boolean getPathFromRoot(TreeNode root, TreeNode node, List&lt;TreeNode&gt; pathArray) &#123;<br>    if (root == null || node == null) return false;<br>    pathArray.add(root);<br>    if (root == node) return true;<br>    if (root.left != null &amp;&amp; getPathFromRoot(root.left, node, pathArray) == true)<br>        return true;<br>    if (root.right != null &amp;&amp; getPathFromRoot(root.right, node, pathArray) == true)<br>        return true;<br>    //回溯<br>    pathArray.remove(pathArray.size() - 1);<br>    return false;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="是平衡二叉树吗？"><a href="#是平衡二叉树吗？" class="headerlink" title="是平衡二叉树吗？"></a>是平衡二叉树吗？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static boolean isBalanced(TreeNode root) &#123;<br>    return getHeight(root) != -1;<br>&#125;<br>//返回以该节点为根节点二叉树的深度<br>private static int getHeight(TreeNode root) &#123;<br>    if (root==null)return 0;<br>    int left=getHeight(root.left);<br>    if (left==-1)return -1;<br>    int right=getHeight(root.right);<br>    if (right==-1)return -1;<br>    if (Math.abs(left-right)&gt;1)return -1;<br>    return Math.max(left,right)+1;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>最大路径和？（任意节点出发）</p>
</li>
<li><p>最大深度</p>
</li>
<li><p>前序遍历中序（中序和后序）遍历构造二叉树</p>
</li>
<li><p>路径和等于 target 的路径（根节点出发）</p>
</li>
<li><p>翻转二叉树</p>
</li>
<li><p>根节点到叶子结点的数字之和</p>
</li>
<li><p>对称二叉树？</p>
</li>
<li><p>二叉搜索树？</p>
</li>
<li><p>二叉搜索树第 k 大节点？</p>
</li>
</ul>
<h4 id="第二小的节点（根节点-x3D-左右节点较小的值）"><a href="#第二小的节点（根节点-x3D-左右节点较小的值）" class="headerlink" title="第二小的节点（根节点&#x3D;左右节点较小的值）"></a>第二小的节点（根节点&#x3D;左右节点较小的值）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">public int findSecondMinimumValue(TreeNode root) &#123;<br>    if (root == null || (root.left == null &amp;&amp; root.right == null)) return -1;//没有最小节点<br>    //找出候选数，默认就是子节点值，如果子节点值和root值相同，递归，在子树中寻找候选数<br>    int left = root.left.val;<br>    int right = root.right.val;<br>    if (root.left.val == root.val) left = findSecondMinimumValue(root.left);<br>    if (root.right.val == root.val) right = findSecondMinimumValue(root.right);<br>    //如果左右候选数都正常，返回较小值就可<br>    if (left != -1 &amp;&amp; right != -1) &#123;<br>        return Math.min(left, right);<br>    &#125;<br>    //如果候选数有-1，说明整个子树中没有可供候选的数<br>    if (left != -1) &#123;<br>        //左子树正常，答案就是左边的候选数<br>        return left;<br>    &#125; else &#123;<br>        //右子树正常，返回答案<br>        //或者右子树也没有候选数，返回-1，即right<br>        return right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><h5 id="路径总和-3-不限起点"><a href="#路径总和-3-不限起点" class="headerlink" title="路径总和 3-不限起点"></a>路径总和 3-不限起点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">int pathnumber;<br>public int pathSum(TreeNode root, int sum) &#123;<br>    if (root == null) return 0;<br>    Sum(root, sum);<br>    pathSum(root.left, sum);<br>    pathSum(root.right, sum);<br>    return pathnumber;<br>&#125;<br><br><br>public void Sum(TreeNode root, int sum) &#123;<br>    if (root == null) return;<br>    sum -= root.val;<br>    if (sum == 0) &#123;<br>        pathnumber++;<br>    &#125;<br>    Sum(root.left, sum);<br>    Sum(root.right, sum);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="路径总和-2（根节点到叶子节点有无）"><a href="#路径总和-2（根节点到叶子节点有无）" class="headerlink" title="路径总和 2（根节点到叶子节点有无）"></a>路径总和 2（根节点到叶子节点有无）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static boolean hasPathSum2(TreeNode root, int sum) &#123;<br>    if (root == null) return false;<br>    return traversal(root, sum - root.val);<br>&#125;<br><br>private static boolean traversal(TreeNode cur, int count) &#123;<br>    if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; count == 0)return true;<br>    if (cur.left == null &amp;&amp; cur.right == null) return false;<br>    if (cur.left != null) &#123;<br>        count = count - cur.left.val;<br>        if (traversal(cur.left, count)) return true;<br>        count = count + cur.left.val;<br>    &#125;<br>    if (cur.right != null) &#123;<br>        count = count - cur.right.val;<br>        if (traversal(cur.right, count)) return true;<br>        count = count + cur.right.val;//回溯<br>    &#125;<br>    return false;<br>&#125;<br><br>public static boolean hasPathSum(TreeNode root, int sum) &#123;<br>    if (root == null) return false;<br>    if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val) &#123;<br>        return true;<br>    &#125;<br>    boolean l = hasPathSum(root.left, sum - root.val);<br>    boolean r = hasPathSum(root.right, sum - root.val);<br>    return l || r;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="路径总和（打印上一题的路径）"><a href="#路径总和（打印上一题的路径）" class="headerlink" title="路径总和（打印上一题的路径）"></a>路径总和（打印上一题的路径）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br>    dfs(root, sum, 0, new ArrayList&lt;&gt;(), res);<br>    return res;<br>&#125;<br><br>private static void dfs(TreeNode root, int sum, int total,<br>                        List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) &#123;<br>    if (root == null) return;<br>    list.add(root.val);<br>    total = total + root.val;<br>    if (root.left == null &amp;&amp; root.right == null) &#123;<br>        if (sum == total) &#123;<br>            res.add(new ArrayList&lt;&gt;(list));<br>        &#125;<br>        list.remove(list.size() - 1);<br>        return;<br>    &#125;<br>    dfs(root.left, sum, total, list, res);<br>    dfs(root.right, sum, total, list, res);<br>    list.remove(list.size() - 1);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="路径总和（打印所有路径）"><a href="#路径总和（打印所有路径）" class="headerlink" title="路径总和（打印所有路径）"></a>路径总和（打印所有路径）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plain">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br>    List&lt;String&gt; res = new ArrayList&lt;&gt;();<br>    if (root == null)return res;<br>    List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();<br>    traversal(root, paths, res);<br>    return res;<br>&#125;<br><br>private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) &#123;<br>    paths.add(root.val);<br>    // 叶子结点<br>    if (root.left == null &amp;&amp; root.right == null) &#123;<br>        StringBuilder sb = new StringBuilder();<br>        for (int i = 0; i &lt; paths.size() - 1; i++) &#123;<br>            sb.append(paths.get(i)).append(&quot;-&gt;&quot;);<br>        &#125;<br>        sb.append(paths.get(paths.size() - 1));<br>        res.add(sb.toString());<br>        return;<br>    &#125;<br>    if (root.left != null) &#123;<br>        traversal(root.left, paths, res);<br>        paths.remove(paths.size() - 1);// 回溯<br>    &#125;<br>    if (root.right != null) &#123;<br>        traversal(root.right, paths, res);<br>        paths.remove(paths.size() - 1);// 回溯<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树的本质其实也是对概念模型：<strong>2-3-4 树</strong>的一种实现。</p>
<p><strong>2-3-4 树是阶数为 4 的 B 树</strong>，B 树，全名 BalanceTree，平衡树。这种结构主要用来做查找。</p>
<p>红黑树也是<strong>二叉查找树</strong>，它是<strong>自平衡</strong>的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。</p>
<p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<p>性质 1：每个节点要么是黑色，要么是红色。<br>性质 2：根节点是黑色。<br>性质 3：每个叶子节点（NIL）是黑色。<br>性质 4：每个红色结点的两个子结点一定都是黑色。<br>性质 5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>双堆找中位数：</p>
<p>如果一个数字要添加到小根堆，就先添加到大根堆，再将大根堆堆顶的元素转移至小根堆；反之亦然，以此能够保证小根堆中的元素永远大于大根堆中的元素。</p>
<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表+1"></a>单链表+1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static ListNode plusOne(ListNode head) &#123;<br>      //翻转链表<br>      ListNode newHead = null;<br>      while (head != null) &#123;<br>          ListNode temp = head.next;<br>          head.next = newHead;<br>          newHead = head;<br>          head = temp;<br>      &#125;<br><br>      int count = 1;<br>      ListNode temp = newHead;<br>      while (count &gt; 0) &#123;<br>          temp.val += count;<br>          count = 0;<br>          if (temp.val &gt;= 10) &#123;<br>              temp.val -= 10;<br>              count = 1;<br>          &#125;<br>          if (count &gt; 0 &amp;&amp; temp.next == null) &#123;<br>              temp.next = new ListNode(count);<br>              count = 0;<br>          &#125;<br>          temp = temp.next;<br>      &#125;<br>      //再次反转<br>      head = null;<br>      while (newHead != null) &#123;<br>          temp = newHead.next;<br>          newHead.next = head;<br>          head = newHead;<br>          newHead = temp;<br>      &#125;<br>      return head;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static ListNode reverseList(ListNode head) &#123;<br>    ListNode cur = head;<br>    ListNode pre = null;<br>    ListNode temp = null;<br>    while (cur != null) &#123;<br>        temp = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = temp;<br>    &#125;<br>    return pre;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="k-个一组反转链表"><a href="#k-个一组反转链表" class="headerlink" title="k 个一组反转链表"></a>k 个一组反转链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static ListNode reverseKGroup(ListNode head, int k) &#123;<br>    ListNode dummy = new ListNode(0);<br>    dummy.next = head;<br>    ListNode pre = dummy;<br>    ListNode end = dummy;<br>    while (end.next != null) &#123;<br>        for (int i = 0; i &lt; k &amp;&amp; end != null; i++) &#123;<br>            end = end.next;//分组，end指向小组最后一个节点<br>        &#125;<br>        if (end == null) &#123;<br>            break;//链表长度小于k，不翻转<br>        &#125;<br>        ListNode next = end.next;//下一组起点<br>        end.next = null;//断开<br>        ListNode start = pre.next;//要翻转的头结点<br><br>        pre.next = reverse(start);<br>        start.next = next;<br>        pre = start;//要翻转节点的上一个节点<br>        end = start;<br>    &#125;<br>    return dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static ListNode detectCycle(ListNode head) &#123;<br>       ListNode fast = head;<br>       ListNode slow = head;<br>       while (true) &#123;<br>           if (fast == null || fast.next == null) return null;//无环<br>           fast = fast.next.next;<br>           slow = slow.next;<br>           if (fast == slow) break;<br>       &#125;<br>       //到这里一定有环<br>       fast = head;<br>       while (slow != fast) &#123;<br>           slow = slow.next;<br>           fast = fast.next;<br>       &#125;<br>       return slow;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;<br>       if (headA == null || headB == null) return null;<br>       ListNode a = headA;<br>       ListNode b = headB;<br>       while (a != b) &#123;<br>           a = a == null ? headB : a.next;<br>           b = b == null ? headA : b.next;<br>       &#125;<br>       return a;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h3 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static ListNode mergeTwoLists(ListNode n1, ListNode n2) &#123;<br>    ListNode dummy = new ListNode(-1);<br>    ListNode head = dummy;<br>    while (n1 != null &amp;&amp; n2 != null) &#123;<br>        if (n1.val &gt;= n2.val) &#123;<br>            head.next = n2;<br>            n2 = n2.next;<br>        &#125; else &#123;<br>            head.next = n1;<br>            n1 = n1.next;<br>        &#125;<br>        head = head.next;<br>    &#125;<br>    if (n1 == null) &#123;<br>        head.next = n2;<br>    &#125; else &#123;<br>        head.next = n1;<br>    &#125;<br>    return dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="合并-k-个有序链表"><a href="#合并-k-个有序链表" class="headerlink" title="合并 k 个有序链表"></a>合并 k 个有序链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static ListNode mergeKLists(ListNode[] lists) &#123;<br>    if (lists.length == 0) return null;<br>    ListNode dummyHead = new ListNode(0);<br>    ListNode curr = dummyHead;<br>    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;() &#123;<br>        @Override<br>        public int compare(ListNode o1, ListNode o2) &#123;<br>            return o1.val - o2.val;<br>        &#125;<br>    &#125;);<br>    for (ListNode list : lists) &#123;<br>        if (list == null) continue;<br>        pq.add(list);<br>    &#125;<br><br>    while (!pq.isEmpty()) &#123;<br>        ListNode nextNode = pq.poll();<br>        curr.next = nextNode;<br>        curr = curr.next;<br>        if (nextNode.next != null) &#123;<br>            pq.add(nextNode.next);<br>        &#125;<br>    &#125;<br>    return dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static String addStrings(String num1, String num2) &#123;<br>    StringBuilder sb = new StringBuilder();<br>    int c = 0;<br>    int i = num1.length() - 1;<br>    int j = num2.length() - 1;<br><br>    while (i &gt;= 0 || j &gt;= 0 || c != 0) &#123;<br>        int n1 = i &gt;= 0 ? num1.charAt(i--) - &#x27;0&#x27; : 0;<br>        int n2 = j &gt;= 0 ? num2.charAt(j--) - &#x27;0&#x27; : 0;<br>        int temp = n1 + n2 + c;<br>        sb.append(temp % 10);<br>        c = temp / 10;<br>    &#125;<br>    return sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int[] twoSum(int[] nums, int target) &#123;<br>    int[] res = new int[2];<br>    if (nums.length == 0) return null;<br>    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>    int temp=0;<br>    for (int i = 0; i &lt; nums.length; i++) &#123;<br>        temp=target-nums[i];<br>        if (map.containsKey(temp)) &#123;<br>            res[1] = i;<br>            res[0] = map.get(temp);<br>        &#125;<br>        map.put(nums[i], i);<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="无重复字符最大子串"><a href="#无重复字符最大子串" class="headerlink" title="无重复字符最大子串"></a>无重复字符最大子串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int lengthOfLongestSubstring(String s) &#123;<br>    int res = 0;<br>    Set&lt;Character&gt; set = new HashSet&lt;&gt;();<br>    for (int r = 0, l = 0; r &lt; s.length(); r++) &#123;<br>        char c = s.charAt(r);<br>        while (set.contains(c)) &#123;<br>            set.remove(s.charAt(l));<br>            l++;<br>        &#125;<br>        set.add(c);<br>        res = Math.max(res, r - l + 1);<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int[] reverse(int[] nums, int i) &#123;<br>       rev(nums, 0, nums.length - 1);<br>       rev(nums, 0, i - 1);<br>       rev(nums, i, nums.length - 1);<br>       return nums;<br>   &#125;<br><br>   public static int[] rev(int[] nums, int start, int end) &#123;<br>       int l = start;<br>       int r = end;<br>       while (r &gt; l) &#123;<br>           int temp = nums[l];<br>           nums[l] = nums[r];<br>           nums[r] = temp;<br>           r--;<br>           l++;<br>       &#125;<br>       return nums;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><blockquote>
<p>顺序集合的查找</p>
</blockquote>
<blockquote>
<p>循环不变量</p>
</blockquote>
<p>1，[left,right]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">while (l&lt;=r)&#123;<br>    int mid=l+(r-l)/2;<br>    if (nums[mid]&gt;target)&#123;<br>        r=mid-1;<br>    &#125;else if (nums[mid]&lt;target)&#123;<br>        l=mid+1;<br>    &#125;else &#123;<br>        return mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2，[left,right)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">while (l&lt;r)&#123;<br>    int mid=l+(r-l)/2;<br>    if (nums[mid]&gt;target)&#123;<br>        r=mid;<br>    &#125;else if (nums[mid]&lt;target)&#123;<br>        l=mid+1;<br>    &#125;else &#123;<br>        return mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int[] maxSlidingWindow(int[] nums, int k) &#123;<br>       if (nums.length == 0) return new int[0];<br>       int[] res = new int[nums.length - k + 1];<br>       LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();<br>       for (int i = 0, j = 0; i &lt; nums.length; i++) &#123;<br>           if (!queue.isEmpty() &amp;&amp; i - queue.peekFirst() &gt;= k) &#123;<br>               queue.pollFirst();<br>           &#125;<br>           while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()]) &#123;<br>               queue.pollLast();<br>           &#125;<br>           queue.addLast(i);<br>           if (i &gt;= k - 1) &#123;<br>               res[j] = nums[queue.peek()];<br>               j++;<br>           &#125;<br>       &#125;<br>       return res;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int lengthOfLongestSubstring(String s) &#123;<br>    int res = 0;<br>    int l = 0;<br>    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();<br>    for (int r = 0; r &lt; s.length(); r++) &#123;<br>        if (map.containsKey(s.charAt(r))) &#123;<br>            l = Math.max(l, map.get(s.charAt(r)));<br>        &#125;<br>        res = Math.max(res, r - l + 1);<br>        map.put(s.charAt(r), r + 1);<br>    &#125;<br>    return res;<br>&#125;<br><br> public int lengthOfLongestSubstring(String s) &#123;<br>        // 记录字符上一次出现的位置<br>        int[] last = new int[128];<br>        for(int i = 0; i &lt; 128; i++) &#123;<br>            last[i] = -1;<br>        &#125;<br>        int n = s.length();<br><br>        int res = 0;<br>        int start = 0; // 窗口开始位置<br>        for(int i = 0; i &lt; n; i++) &#123;<br>            int index = s.charAt(i);<br>            start = Math.max(start, last[index] + 1);<br>            res   = Math.max(res, i - start + 1);<br>            last[index] = i;<br>        &#125;<br>        return res;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><ul>
<li>斐波拉切数列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int fib(int n) &#123;<br>    if (n==0)return 0;<br>    if (n==1)return 1;<br>    int[] dp=new int[n+1];<br>    dp[0]=0;<br>    dp[1]=1;<br>    for (int i = 2; i &lt;= n; i++) &#123;<br>        dp[i]=dp[i-1]+dp[i-2];<br>    &#125;<br>    return dp[n];<br>&#125;<br><br>public static int fib2(int n)&#123;<br>    if (n==0)return 0;<br>    if (n==1)return 1;<br>    int dp0=0;<br>    int dp1=1;<br>    for (int i = 2; i &lt;= n; i++) &#123;<br>        int sum=dp0+dp1;<br>        dp0=dp1;<br>        dp1=sum;<br>    &#125;<br>    return dp1;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>爬楼梯</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int climb(int n) &#123;<br>    if (n &lt;= 1) return n;<br>    int[] dp = new int[n + 1];<br>    dp[1] = 1;<br>    dp[2] = 2;<br>    for (int i = 3; i &lt; n; i++) &#123;<br>        dp[i] = dp[i - 1] + dp[i - 2];<br>    &#125;<br>    return dp[n];<br>&#125;<br>//dp[0]在此没有意义。<br>//拓展：最少花费爬楼梯<br>public static int minCostClimbingStairs(int[] cost) &#123;<br>    if (cost == null || cost.length == 0) return 0;<br>    if (cost.length == 1) return cost[0];<br><br>    int[] dp = new int[cost.length];<br>    dp[0] = cost[0];<br>    dp[1] = cost[1];<br>    for (int i = 2; i &lt; cost.length; i++) &#123;<br>        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];<br>    &#125;<br>    //最后一步，如果是由倒数第二步爬，则最后一步的体力花费可以不用算<br>    return Math.min(dp[cost.length - 1], dp[cost.length - 2]);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>不同路径</li>
</ul>
<p><img src="https://i.loli.net/2021/08/13/6AaWL3Hr7gosuOK.png" srcset="/img/loading.gif" lazyload alt="image-20210813160649637"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int uniquepaths2(int m, int n) &#123;<br>    int[][] dp = new int[m][n];<br>    for (int i = 0; i &lt; m; i++) &#123;<br>        dp[i][0] = 1;<br>    &#125;<br>    for (int i = 0; i &lt; n; i++) &#123;<br>        dp[0][i] = 1;<br>    &#125;<br>    for (int i = 1; i &lt; m; i++) &#123;<br>        for (int j = 1; j &lt; n; j++) &#123;<br>            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br>        &#125;<br>    &#125;<br>    return dp[m - 1][n - 1];<br>&#125;<br><br>//考虑某些位置有障碍<br>int m=grid.length();<br>int n=grud[0].length();<br>//初始化<br>for (int i = 0; i &lt; m&amp;&amp;grid[i][0]==0; i++) &#123;<br>        dp[i][0] = 1;<br>   &#125;<br>for (int i = 0; i &lt; n&amp;&amp;grid[0][j]==0; i++) &#123;<br>        dp[0][i] = 1;<br>   &#125;<br>//遍历-加上判断条件即可<br>if(grid[i][j]==1)continue;<br></code></pre></td></tr></table></figure>

<ul>
<li>整数拆分</li>
</ul>
<p>1，贪心算法-拆成 3<em>3</em>3*3……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">if(n==2)return 1;<br>if(n==3)return 2;<br>if(n==4)return 4;<br>int res=1;<br>while(n&gt;4)&#123;<br>    res=res*3;<br>    n=n-3;<br>&#125;<br>res=res*n;<br>return res;<br>//数学证明？<br></code></pre></td></tr></table></figure>

<ul>
<li>2，动态规划</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">int[] dp=new int[n+1];<br>dp[2]=1;<br>for(int i=3;i&lt;=n;i++)&#123;<br>    for(int j=1;j&lt;i-1;j++)&#123;<br>        dp[i]=max(dp[i],max(j*(i-j),j*dp[i-j]));<br>    &#125;<br>&#125; <br>return dp[n];<br></code></pre></td></tr></table></figure>



<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul>
<li>01 背包</li>
</ul>
<p>问题描述：物品 N 件，背包重量 W，物品的价值与重量为 value[i]，weight[i]。</p>
<p>dp[i][j]表示在下标[0,i-1]的物品中任意取，存放到容量为 j 的背包的最大价值。</p>
<p>1，递推公式。</p>
<p>dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])。</p>
<p>第 i 个物品不取。</p>
<p>第 i 个物品取。dp[i-1][j-weight[i]]+value[i]为背包放 i 物品的最大价值。</p>
<p>2，初始化。</p>
<p>dp[i][0]&#x3D;0,背包容量为 0，一定是 0。</p>
<p>dp[0][j]&#x3D;?存放 0 号物品时，最大价值？</p>
<p>dp[0][j]&#x3D;dp[0][j-weight[0]]+value[0]</p>
<p>倒序遍历！</p>
<p>3，遍历顺序。</p>
<p>先遍历物品好理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int bag(int bagweight, int[] weight, int[] value) &#123;<br>    int[][] dp = new int[weight.length][bagweight + 1];<br>    for (int i = bagweight; i &gt;= weight[0]; i--) &#123;<br>        dp[0][i] = dp[0][i - weight[0]] + value[0];<br>    &#125;<br>    for (int i = 1; i &lt; weight.length; i++) &#123;<br>        for (int j = 0; j &lt;= bagweight; j++) &#123;<br>            if (j &gt;= weight[i]) &#123;<br>                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return dp[weight.length-1][bagweight];<br>&#125;<br><br>public static void main(String[] args) &#123;<br>    int[] w = &#123;1, 3, 4&#125;;<br>    int[] v = &#123;15, 20, 30&#125;;<br>    System.out.println(bag(4, w, v));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/13/A5q8CkLMDeo1B6F.png" srcset="/img/loading.gif" lazyload alt="image-20210813160820472"></p>
<blockquote>
<p>一维 dp[ ]数组。</p>
</blockquote>
<blockquote>
<p>遍历背包大小时倒序遍历-为了保证每个物品只用一次。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int bag1(int bagweight, int[] weight, int[] value)&#123;<br>    int[] dp=new int[bagweight+1];<br>    for (int i = 0; i &lt; weight.length; i++) &#123;<br>        for (int j = bagweight; j &gt;= weight[i]; j--) &#123;<br>            dp[j]= Math.max(dp[j],dp[j-weight[i]]+value[i]);<br>        &#125;<br>    &#125;<br>    return dp[bagweight];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cr1c7chgh5.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ3OTM2ZWM4NmQ4ODc5MjNkN2FjOTcwMjdkNTRhZmNfNzhkTThMUHltY09UY0VUN1RVcFpPNTNNVG1NenRwYzZfVG9rZW46Ym94Y25JVDhmT0ZuTWFGMDExY3g4S0h4OURkXzE2Mjg4NDE5NjE6MTYyODg0NTU2MV9WNA" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>完全背包-每个物品都可以被放入无数次。</li>
<li>只需要改变遍历背包时的遍历顺序。</li>
</ul>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int bag2(int bagweight, int[] weight, int[] value) &#123;<br>    int[] dp = new int[bagweight + 1];<br>    for (int i = 0; i &lt; weight.length; i++) &#123;<br>        for (int j = weight[i]; j &lt;= bagweight; j++) &#123;<br>            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    return dp[bagweight];<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>零钱兑换（1,2,5）</li>
<li>可以先遍历总金额吗？不能。</li>
<li>如果求<strong>组合数</strong>就是外层 for 循环遍历物品，内层 for 遍历背包。</li>
<li>如果求<strong>排列数</strong>就是外层 for 遍历背包，内层 for 循环遍历物品</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int coinnum(int[] coins,int money)&#123;<br>    int[] dp=new int[money+1];<br>    dp[0]=1;<br>    for (int i = 0; i &lt; coins.length; i++) &#123;//遍历物品<br>        for (int j = coins[i]; j &lt;= money; j++) &#123;//遍历容量<br>            dp[j]=dp[j-coins[i]]+dp[j];<br>        &#125;<br>    &#125;<br>    return dp[money];<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>爬楼梯进阶</li>
<li>每次都可以爬 1,2,3,4，，，，n 步？</li>
<li>等价于完全背包问题。</li>
<li>物品就是一步两步三步。</li>
<li>总量就是总的台阶步数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int climb3(int n, int m) &#123;<br>    int[] dp = new int[n + 1];<br>    dp[0] = 1;<br>    //排列问题-先遍历背包<br>    for (int i = 1; i &lt;= n; i++) &#123;<br>        for (int j = 1; j &lt;= m; j++) &#123;//遍历物品<br>            if (i - j &gt;= 0) &#123;<br>                dp[i] = dp[i] + dp[i - j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    return dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>零钱兑换最少的硬币数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int coinmin(int[] coins, int sum) &#123;<br>    int[] dp = new int[sum + 1];<br>    Arrays.fill(dp, Integer.MAX_VALUE);<br>    dp[0] = 0;<br>    for (int i = 0; i &lt; coins.length; i++) &#123;<br>        for (int j = coins[i]; j &lt;= sum; j++) &#123;<br>            if (dp[j - coins[i]] != Integer.MAX_VALUE) &#123;<br>                dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    if (dp[sum] == Integer.MAX_VALUE) return -1;<br>    return dp[sum];<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>构成完全平方数的最小个数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int sqmin(int n) &#123;<br>    int[] dp = new int[n + 1];<br>    Arrays.fill(dp, Integer.MAX_VALUE);<br>    dp[0] = 0;<br>    for (int i = 0; i &lt;= n; i++) &#123;//遍历背包<br>        for (int j = 1; j * j &lt;= i; j++) &#123;//遍历物品<br>            dp[j] = Math.min(dp[i - j * j] + 1, dp[i]);<br>        &#125;<br>    &#125;<br>    return dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><h4 id="初级打家劫舍"><a href="#初级打家劫舍" class="headerlink" title="初级打家劫舍"></a>初级打家劫舍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int rob(int[] nums) &#123;<br>    if (nums.length == 0) return 0;<br>    if (nums.length == 1) return nums[0];<br>    int[] dp = new int[nums.length];<br>    dp[0] = nums[0];<br>    dp[1] = Math.max(nums[0], nums[1]);<br>    for (int i = 2; i &lt; nums.length; i++) &#123;<br>        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);<br>    &#125;<br>    return dp[nums.length - 1];<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="环形打家劫舍"><a href="#环形打家劫舍" class="headerlink" title="环形打家劫舍"></a>环形打家劫舍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int rob(int[] nums) &#123;<br>    int len=nums.length;<br>    if (len==0)return 0;<br>    if (len==1)return nums[0];<br>    int res1=helper(nums,0,nums.length-2);<br>    int res2=helper(nums,1,nums.length-1);<br>    return Math.max(res1,res2);<br>&#125;<br><br>private static int helper(int[] nums, int start, int end) &#123;<br>    if (start==end)return nums[start];<br>    int[] dp=new int[nums.length];<br>    dp[start]=nums[start];<br>    dp[start+1]=Math.max(nums[start],nums[start+1]);<br>    for (int i = start+2; i &lt;= end; i++) &#123;<br>        dp[i]= Math.max(dp[i-2]+nums[i],dp[i-1]);<br>    &#125;<br>    return dp[end];<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="树形打家劫舍"><a href="#树形打家劫舍" class="headerlink" title="树形打家劫舍"></a>树形打家劫舍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int rob(TreeNode root)&#123;<br>   //表示偷某个节点和不偷某个节点的最大值<br>    int[] res=robtree(root);<br>    return Math.max(res[0],res[1]);<br>&#125;<br><br>private static int[] robtree(TreeNode cur) &#123;<br>    if (cur==null)return new int[2];<br>    int[] left = robtree(cur.left);<br>    int[] right = robtree(cur.right);<br>    <br>    int val1=cur.val+left[0]+right[0];<br>    int val2=Math.max(left[0],left[1])+Math.max(right[0],right[1]);<br>    return new int[]&#123;val2,val1&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><h4 id="买股票最佳时机（只能买卖一次）"><a href="#买股票最佳时机（只能买卖一次）" class="headerlink" title="买股票最佳时机（只能买卖一次）"></a>买股票最佳时机（只能买卖一次）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int maxProfit(int[] prices) &#123;<br>    int low=prices[0];<br>    int res=0;<br>    for(int i=1;i&lt;prices.length;i++)&#123;<br>        low=Math.min(prices[i],low);<br>        res=Math.max(res,prices[i]-low);<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（可以买卖多次）"><a href="#买股票最佳时机（可以买卖多次）" class="headerlink" title="买股票最佳时机（可以买卖多次）"></a>买股票最佳时机（可以买卖多次）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">public int maxProfit(int[] prices) &#123;<br>    int res=0;<br>    for (int i = 1; i &lt; prices.length; i++) &#123;<br>        if (prices[i]&gt;prices[i-1])&#123;<br>            res=res+(prices[i]-prices[i-1]);<br>        &#125;<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（最多买卖-2-次，同时只能有一支）"><a href="#买股票最佳时机（最多买卖-2-次，同时只能有一支）" class="headerlink" title="买股票最佳时机（最多买卖 2 次，同时只能有一支）"></a>买股票最佳时机（最多买卖 2 次，同时只能有一支）</h4><blockquote>
<p>动态规划：每天有 5 个状态，第一&#x2F;二天买入&#x2F;出，无操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">public int maxProfit(int[] prices) &#123;<br>    if (prices.length == 0) return 0;<br>    int[][] dp = new int[prices.length][5];<br>    dp[0][1] = -prices[0];<br>    dp[0][3] = -prices[0];<br>    for (int i = 1; i &lt; prices.length; i++) &#123;<br>        dp[i][0] = dp[i - 1][0];<br>        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);<br>        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);<br>        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);<br>        dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);<br>    &#125;<br>    return dp[prices.length - 1][4];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（最多买卖-k-次，同时只能有一支）"><a href="#买股票最佳时机（最多买卖-k-次，同时只能有一支）" class="headerlink" title="买股票最佳时机（最多买卖 k 次，同时只能有一支）"></a>买股票最佳时机（最多买卖 k 次，同时只能有一支）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">public int maxProfit(int k, int[] prices) &#123;<br>    if (prices.length == 0) return 0;<br>    int[][] dp = new int[prices.length][2 * k + 1];<br>    //奇数代表卖入，偶数代表买<br>    for (int i = 1; i &lt; 2 * k; i += 2) &#123;<br>        dp[0][i] = -prices[0];<br>    &#125;<br>    for (int i = 1; i &lt; prices.length; i++) &#123;<br>        for (int j = 0; j &lt; 2 * k - 1; j += 2) &#123;<br>            dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);<br>            dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);<br>        &#125;<br>    &#125;<br>    return dp[prices.length - 1][2 * k];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="买股票最佳时机（买卖多次，冷冻期一天）"><a href="#买股票最佳时机（买卖多次，冷冻期一天）" class="headerlink" title="买股票最佳时机（买卖多次，冷冻期一天）"></a>买股票最佳时机（买卖多次，冷冻期一天）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">public int maxProfit(int[] prices) &#123;<br>    if (prices.length == 0) return 0;<br>    //状态：买入，卖出（两天前就卖出，今天卖出），冷冻期<br>    int[][] dp = new int[prices.length][4];<br>    dp[0][0] = -prices[0];<br>    for (int i = 1; i &lt; prices.length; i++) &#123;<br>        dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);<br>        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);<br>        dp[i][2] = dp[i - 1][0] + prices[i];<br>        dp[i][3] = dp[i - 1][2];<br>    &#125;<br>    return Math.max(dp[prices.length - 1][3],<br>            Math.max(dp[prices.length - 1][1], dp[prices.length - 1][2]));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int maxlts(int[] nums) &#123;<br>    if (nums.length &lt;= 1) return nums.length;<br>    int[] dp = new int[nums.length];<br>    Arrays.fill(dp, 1);<br>    int res = 0;<br>    for (int i = 1; i &lt; nums.length; i++) &#123;<br>        for (int j = 0; j &lt; i; j++) &#123;<br>            if (nums[i] &gt; nums[j]) &#123;<br>                dp[i] = Math.max(dp[i], dp[j] + 1);<br>            &#125;<br>            res = Math.max(res, dp[i]);<br>        &#125;<br>    &#125;<br>    System.out.println(Arrays.toString(dp));<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int maxlts(int[] nums) &#123;<br>    if (nums.length == 0) return 0;<br>    int[] dp = new int[nums.length];<br>    Arrays.fill(dp, 1);<br>    int res = 1;<br>    for (int i = 0; i &lt; nums.length - 1; i++) &#123;<br>        if (nums[i + 1] &gt; nums[i]) &#123;<br>            dp[i + 1] = dp[i] + 1;<br>        &#125;<br>        res = Math.max(res, dp[i]);<br>    &#125;<br>    System.out.println(Arrays.toString(dp));<br>    return res;<br>&#125;<br><br>//贪心算法<br>public static int maxlts2(int[] nums) &#123;<br>    if (nums.length == 0) return 0;<br>    int res = 1;<br>    int count = 1;<br>    for (int i = 0; i &lt; nums.length - 1; i++) &#123;<br>        if (nums[i + 1] &gt; nums[i]) &#123;<br>            count++;<br>        &#125; else &#123;<br>            count = 1;<br>        &#125;<br>        res = Math.max(res, count);<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int maxarray(int[] nums1,int[] nums2)&#123;<br>    int[][] dp=new int[nums1.length+1][nums2.length+1];<br>    int res=0;<br>    for (int i = 1; i &lt;= nums1.length; i++) &#123;<br>        for (int j = 1; j &lt;= nums2.length; j++) &#123;<br>            if (nums1[i-1]==nums2[j-1])&#123;<br>                dp[i][j]=dp[i-1][j-1]+1;<br>            &#125;<br>            res= Math.max(res,dp[i][j]);<br>        &#125;<br>    &#125;<br>    for (int i = 0; i &lt; dp.length; i++) &#123;<br>        for (int j = 0; j &lt; dp[0].length; j++) &#123;<br>            System.out.print(dp[i][j]+&quot;   &quot;);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int maxarray(int[] nums1,int[] nums2)&#123;<br>    int[][] dp=new int[nums1.length+1][nums2.length+1];<br>    int res=0;<br>    for (int i = 1; i &lt;= nums1.length; i++) &#123;<br>        for (int j = 1; j &lt;= nums2.length; j++) &#123;<br>            if (nums1[i-1]==nums2[j-1])&#123;<br>                dp[i][j]=dp[i-1][j-1]+1;<br>            &#125;else&#123;<br>                dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);<br>            &#125;<br>            res= Math.max(res,dp[i][j]);<br>        &#125;<br>    &#125;<br>    for (int i = 0; i &lt; dp.length; i++) &#123;<br>        for (int j = 0; j &lt; dp[0].length; j++) &#123;<br>            System.out.print(dp[i][j]+&quot;   &quot;);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int maxsubarray(int[] nums)&#123;<br>    int res=Integer.MIN_VALUE;<br>    int count=0;<br>    for (int i = 0; i &lt; nums.length; i++) &#123;<br>        count=count+nums[i];<br>        if (count&gt;res)&#123;<br>            res=count;<br>        &#125;<br>        if (count&lt;=0)count=0;<br>    &#125;<br>    return res;<br>&#125;<br><br>public static int maxsubarray2(int[] nums)&#123;<br>    if (nums.length==0)return 0;<br>    int[] dp=new int[nums.length];<br>    dp[0]=nums[0];<br>    int res=nums[0];<br>    for (int i = 1; i &lt; nums.length; i++) &#123;<br>        dp[i]= Math.max(dp[i-1]+nums[i],nums[i]);<br>        res= Math.max(res,dp[i]);<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int countSubstrings(String s)&#123;<br>    int res=0;<br>    for (int i = 0; i &lt; s.length(); i++) &#123;<br>        res=res+extend(s,i,i,s.length());<br>        res=res+extend(s,i,i+1,s.length());<br>    &#125;<br>    return res;<br>&#125;<br><br>private static int extend(String s, int i, int j, int length) &#123;<br>     int re=0;<br>     while (i&gt;=0&amp;&amp;j&lt;length&amp;&amp;s.charAt(i)==s.charAt(j))&#123;<br>         i++;<br>         j--;<br>         re++;<br>     &#125;<br>     return re;<br>&#125;<br>public static int huiwen(String s)&#123;<br>    boolean[][] dp=new boolean[s.length()][s.length()];<br>    int res=0;<br>    for (int i = s.length()-1; i &gt;=0; i--) &#123;<br>        for (int j = i; j &lt; s.length(); j++) &#123;<br>            if (s.charAt(i)==s.charAt(j))&#123;<br>                if (j-i&lt;=1)&#123;<br>                    res++;<br>                    dp[i][j]=true;<br>                &#125;else if(dp[i+1][j-1])&#123;<br>                    res++;<br>                    dp[i][j]=true;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return res;<br>&#125;<br>//最长回文子串<br>public static String maxhuiwen(String s)&#123;<br>    if (s.length()&lt;2)return s;<br>    int start=0;<br>    int max=1;<br>    int len=s.length();<br>    for (int i = 0; i &lt; len; ) &#123;<br>        //剩下的已经不可能更长了。<br>        if (len-i&lt;=max/2)break;<br>        int l=i;<br>        int r=i;<br>        while (r&lt;len-1&amp;&amp;s.charAt(r)==s.charAt(r+1))&#123;<br>            r++;<br>        &#125;<br>        i=r+1;<br>        while (r&lt;len-1&amp;&amp;l&gt;0&amp;&amp;s.charAt(r+1)==s.charAt(l-1))&#123;<br>            r++;<br>            l--;<br>        &#125;<br>        if (r-l+1&gt;max)&#123;<br>            max=r-l+1;<br>            start=l;<br>        &#125;<br>    &#125;<br>    return s.substring(start,start+max);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int longestPalindromeSubseq(String s) &#123;<br>    int[][] dp = new int[s.length()][s.length()];<br>    for (int i = s.length() - 1; i &gt;= 0; i--) &#123;<br>        dp[i][i] = 1;<br>        for (int j = i + 1; j &lt; s.length(); j++) &#123;<br>            if (s.charAt(i) == s.charAt(j)) &#123;<br>                dp[i][j] = dp[i + 1][j - 1] + 2;<br>            &#125; else &#123;<br>                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return dp[0][s.length() - 1];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static boolean isSubsequence(String s, String t) &#123;<br>       if (s.length() == 0) return true;<br>       int ss = 0;<br>       for (int i = 0; i &lt; t.length(); i++) &#123;<br>           if (s.charAt(ss) == t.charAt(i)) &#123;<br>               ss++;<br>               if (ss == s.length()) return true;<br>           &#125;<br>       &#125;<br>       return false;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int minDistance(String s1,String s2)&#123;<br>    int[][] dp=new int[s1.length()+1][s2.length()+1];<br>    for (int i = 0; i &lt;= s1.length(); i++) &#123;<br>        dp[i][0]=i;<br>    &#125;<br>    for (int i = 0; i &lt;= s2.length(); i++) &#123;<br>        dp[0][i]=i;<br>    &#125;<br>    for (int i = 1; i &lt;= s1.length(); i++) &#123;<br>        for (int j = 1; j &lt;= s2.length(); j++) &#123;<br>            if (s1.charAt(i-1)==s2.charAt(j-1))&#123;<br>                dp[i][j]=dp[i-1][j-1];<br>            &#125;else &#123;<br>                //s1增加一个元素dp[i-1][j]+1==as asd<br>                //s2添加一个元素dp[i][j-1]+1==asd as<br>                //替换元素dp[i-1][j-1]+1==asd ase<br>                dp[i][j]= Math.min(Math.min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1), dp[i][j - 1] + 1);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return dp[s1.length()][s2.length()];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="hotcode"><a href="#hotcode" class="headerlink" title="hotcode"></a>hotcode</h3><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class LRUCache &#123;<br>    private class node &#123;<br>        //双向链表类<br>        int val;<br>        int key;<br>        node pre;<br>        node next;<br>        public node(int key, int val) &#123;<br>            this.val = val;<br>            this.key = key;<br>        &#125;<br>    &#125;<br><br>    private HashMap&lt;Integer, node&gt; map;<br>    private int capacity;<br>    private node dummyfirst;<br>    private node dummylast;<br><br>    public LRUCache(int capacity) &#123;<br>        map = new HashMap&lt;&gt;(capacity);<br>        this.capacity = capacity;<br>        dummyfirst = new node(-1, -1);<br>        dummylast = new node(-1, -1);<br><br>        dummyfirst.next = dummylast;<br>        dummylast.pre = dummyfirst;<br>    &#125;<br><br>    public int get(int key) &#123;<br>        if (!map.containsKey(key)) &#123;<br>            return -1;<br>        &#125;<br>        //缓存中有<br>        node n = map.get(key);<br>        //删除该节点<br>        n.pre.next = n.next;<br>        n.next.pre = n.pre;<br>        //移到最后面<br>        movetolast(n);<br>        return n.val;<br>    &#125;<br><br>    public void put(int key, int value) &#123;<br>        if (get(key) != -1) &#123;//已经有了<br>            map.get(key).val = value;//更新值就可以<br>            return;<br>        &#125;<br>        //之前没有<br>        node add = new node(key, value);<br>        map.put(key, add);<br>        //移到最后面<br>        movetolast(add);<br>        //满了就移除<br>        if (map.size() &gt; capacity) &#123;<br>            //删除最前面的（最久未用）<br>            map.remove(dummyfirst.next.key);<br>            dummyfirst.next = dummyfirst.next.next;<br>            dummyfirst.next.pre = dummyfirst;<br>        &#125;<br>    &#125;<br><br>    private void movetolast(node n) &#123;<br>        n.next = dummylast;<br>        n.pre = dummylast.pre;<br>        dummylast.pre = n;<br>        n.pre.next = n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int trap(int[] height) &#123;<br>    int len = height.length;<br>    int[] maxl = new int[len];<br>    int[] maxr = new int[len];<br>    int res = 0;<br>    for (int i = 1; i &lt; len; i++) &#123;<br>        maxl[i] = Math.max(maxl[i - 1], height[i - 1]);<br>    &#125;<br>    for (int i = len - 2; i &gt;= 0; i--) &#123;<br>        maxr[i] = Math.max(maxr[i + 1], height[i + 1]);<br>    &#125;<br><br>    for (int i = 0; i &lt; len; i++) &#123;<br>        int h = Math.min(maxl[i], maxr[i]);<br>        if (h &gt; height[i]) &#123;<br>            res = res + h - height[i];<br>        &#125;<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class Singleton &#123;<br>    private volatile static Singleton uniqueInstance;<br>    private Singleton()&#123;<br>        <br>    &#125;<br>    public static Singleton getUniqueInstance()&#123;<br>        if (uniqueInstance==null)&#123;<br>            synchronized (Singleton.class)&#123;<br>                if (uniqueInstance==null)&#123;<br>                    uniqueInstance=new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="TOPK-问题"><a href="#TOPK-问题" class="headerlink" title="TOPK 问题"></a>TOPK 问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int findKthLargest(int[] nums, int k) &#123;<br>    int len = nums.length;<br>    PriorityQueue&lt;Integer&gt; minheap = new PriorityQueue&lt;&gt;(len, (a, b) -&gt; a - b);//默认最小堆<br>    for (int i = 0; i &lt; len; i++) &#123;<br>        minheap.add(nums[i]);<br>    &#125;<br>    for (int i = 0; i &lt; len - k; i++) &#123;<br>        minheap.poll();<br>    &#125;<br>    return minheap.peek();<br>&#125;<br><br>public int findKthLargest2(int[] nums, int k) &#123;<br>    int len = nums.length;<br>    // 最小堆<br>    PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(k + 1, (a, b) -&gt; (a - b));<br>    for (int num : nums) &#123;<br>        priorityQueue.add(num);<br>        if (priorityQueue.size() == k + 1) &#123;<br>            priorityQueue.poll();<br>        &#125;<br>    &#125;<br>    return priorityQueue.peek();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public List&lt;Integer&gt; getRow(int rowIndex) &#123;<br>    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<br>    while (rowIndex &gt;= 0) &#123;<br>        rowIndex--;<br>        list.add(1);<br>        for (int i = list.size() - 2; i &gt; 0; i--) &#123;<br>            list.set(i, list.get(i) + list.get(i - 1));<br>        &#125;<br>    &#125;<br>    return list;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="第一个缺失的正数"><a href="#第一个缺失的正数" class="headerlink" title="第一个缺失的正数"></a>第一个缺失的正数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static int firstMissingPositive(int[] nums) &#123;<br>   Set&lt;Integer&gt; set=new HashSet&lt;&gt;();<br>    for (int i = 0; i &lt; nums.length; i++) &#123;<br>        set.add(nums[i]);<br>    &#125;<br>    for (int i = 1; i &lt;= nums.length; i++) &#123;<br>        if (!set.contains(i))&#123;<br>            return i;<br>        &#125;<br>    &#125;<br>    return nums.length+1;<br>&#125;<br>public static int firstMissingPositive2(int[] nums) &#123;<br>    int len=nums.length;<br>    for (int i = 0; i &lt; len; i++) &#123;<br>        if (nums[i]&lt;=0)nums[i]=len+1;<br>    &#125;<br>    for (int i = 0; i &lt; len; i++) &#123;<br>        int num= Math.abs(nums[i]);<br>        if (num&lt;=len)&#123;<br>            nums[num-1]=-Math.abs(nums[num-1]);<br>        &#125;<br>    &#125;<br>    for (int i = 0; i &lt; len; i++) &#123;<br>        if (nums[i]&gt;0)&#123;<br>            return i+1;<br>        &#125;<br>    &#125;<br>    return len+1;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">public int majorityElement(int[] nums) &#123;<br>       int major=nums[0];<br>       int count=0;<br>       for(int i=0;i&lt;nums.length;i++)&#123;<br>           if(count==0)&#123;<br>               major=nums[i];<br>               count=1;<br>           &#125;else if(major==nums[i])&#123;<br>               count++;<br>           &#125;else &#123;<br>               count--;<br>           &#125;<br>       &#125;<br>       count=0;<br>        for(int i=0;i&lt;nums.length;i++)&#123;<br>            if(nums[i]==major)&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        return count&gt;nums.length/2?major:-1;<br>   &#125;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/top/" class="category-chain-item">top</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/basic/" class="print-no-link">#basic</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20java/" title="设计模式">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设计模式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/04/Redis-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" title="Redis-缓存一致性">
                        <span class="hidden-mobile">Redis-缓存一致性</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"WrPC7xJfVpGUd8GjrKoxR34Q-gzGzoHsz","appKey":"1Ta1bWsuCydK80lVeBdHgrc6","path":"window.location.pathname","placeholder":"show me your view!","avatar":"wavatar","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
